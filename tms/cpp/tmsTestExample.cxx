

/*
WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.

This file was generated from tmsTestExample.idl using "rtiddsgen".
The rtiddsgen tool is part of the RTI Connext distribution.
For more information, type 'rtiddsgen -help' at a command shell
or consult the RTI Connext manual.
*/

#ifndef NDDS_STANDALONE_TYPE
#ifndef ndds_cpp_h
#include "ndds/ndds_cpp.h"
#endif
#ifndef dds_c_log_impl_h              
#include "dds_c/dds_c_log_impl.h"                                
#endif 
#ifndef dds_c_log_infrastructure_h                      
#include "dds_c/dds_c_infrastructure_impl.h"       
#endif 

#ifndef cdr_type_h
#include "cdr/cdr_type.h"
#endif    

#ifndef osapi_heap_h
#include "osapi/osapi_heap.h" 
#endif
#else
#include "ndds_standalone_type.h"
#endif

#include "tmsTestExample.h"

#ifndef NDDS_STANDALONE_TYPE
#include "tmsTestExamplePlugin.h"
#endif

#include <new>

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_TopicName_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_TopicName_g_tc_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_TopicName)));

    static DDS_TypeCode tms_TopicName_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::TopicName", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_TopicName */

    if (is_initialized) {
        return &tms_TopicName_g_tc;
    }

    tms_TopicName_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_TopicName_g_tc._data._typeCode =  (RTICdrTypeCode *)&tms_TopicName_g_tc_string;

    /* Initialize the values for member annotations. */
    tms_TopicName_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_TopicName_g_tc._data._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_TopicName_g_tc._data._sampleAccessInfo =
    tms_TopicName_get_sample_access_info();
    tms_TopicName_g_tc._data._typePlugin =
    tms_TopicName_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_TopicName_g_tc;
}

#define TSeq tms_TopicNameSeq
#define T tms_TopicName
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_TopicName_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_TopicName_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_TopicNameSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_TopicNameSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_TopicName_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_TopicName_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_TopicName_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_TopicName_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_TopicName_g_sampleAccessInfo;
    }

    tms_TopicName_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_TopicName_g_sampleAccessInfo.memberAccessInfos = 
    tms_TopicName_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_TopicName);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_TopicName_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_TopicName_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_TopicName_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_TopicName_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_TopicName_get_member_value_pointer;

    tms_TopicName_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_TopicName_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_TopicName_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_TopicName_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_TopicName_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_TopicName_finalize_w_return,
        NULL
    };

    return &tms_TopicName_g_typePlugin;
}
#endif

RTIBool tms_TopicName_initialize(
    tms_TopicName* sample) {
    return tms_TopicName_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_TopicName_initialize_ex(
    tms_TopicName* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_TopicName_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_TopicName_initialize_w_params(
    tms_TopicName* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        (*sample) = DDS_String_alloc(((tms_MAXLEN_TopicName)));
        RTICdrType_copyStringEx(
            &(*sample),
            "",
            ((tms_MAXLEN_TopicName)),
            RTI_FALSE);
        if ((*sample) == NULL) {
            return RTI_FALSE;
        }
    } else {
        if ((*sample) != NULL) {
            RTICdrType_copyStringEx(
                &(*sample),
                "",
                ((tms_MAXLEN_TopicName)),
                RTI_FALSE);
            if ((*sample) == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_TopicName_finalize_w_return(
    tms_TopicName* sample)
{
    tms_TopicName_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_TopicName_finalize(
    tms_TopicName* sample)
{

    tms_TopicName_finalize_ex(sample,RTI_TRUE);
}

void tms_TopicName_finalize_ex(
    tms_TopicName* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_TopicName_finalize_w_params(
        sample,&deallocParams);
}

void tms_TopicName_finalize_w_params(
    tms_TopicName* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if ((*sample) != NULL) {
        DDS_String_free((*sample));
        (*sample)=NULL;

    }
}

void tms_TopicName_finalize_optional_members(
    tms_TopicName* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_TopicName_copy(
    tms_TopicName* dst,
    const tms_TopicName* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyStringEx (
            &(*dst), (*src), 
            ((tms_MAXLEN_TopicName)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_TopicName' sequence class.
*/
#define T tms_TopicName
#define TSeq tms_TopicNameSeq

#define T_initialize_w_params tms_TopicName_initialize_w_params

#define T_finalize_w_params   tms_TopicName_finalize_w_params
#define T_copy       tms_TopicName_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_TopicList_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_TopicList_g_tc_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_TopicList)),NULL);

    static DDS_TypeCode tms_TopicList_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::TopicList", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_TopicList */

    if (is_initialized) {
        return &tms_TopicList_g_tc;
    }

    tms_TopicList_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_TopicList_g_tc_sequence._data._typeCode = (RTICdrTypeCode *)tms_TopicName_get_typecode();
    tms_TopicList_g_tc_sequence._data._sampleAccessInfo = tms_TopicName_get_sample_seq_access_info();
    tms_TopicList_g_tc._data._typeCode =  (RTICdrTypeCode *)& tms_TopicList_g_tc_sequence;

    /* Initialize the values for member annotations. */

    tms_TopicList_g_tc._data._sampleAccessInfo =
    tms_TopicList_get_sample_access_info();
    tms_TopicList_g_tc._data._typePlugin =
    tms_TopicList_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_TopicList_g_tc;
}

#define TSeq tms_TopicListSeq
#define T tms_TopicList
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_TopicList_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_TopicList_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_TopicListSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_TopicListSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_TopicList_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_TopicList_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_TopicList_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_TopicList_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_TopicList_g_sampleAccessInfo;
    }

    tms_TopicList_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_TopicList_g_sampleAccessInfo.memberAccessInfos = 
    tms_TopicList_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_TopicList);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_TopicList_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_TopicList_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_TopicList_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_TopicList_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_TopicList_get_member_value_pointer;

    tms_TopicList_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_TopicList_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_TopicList_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_TopicList_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_TopicList_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_TopicList_finalize_w_return,
        NULL
    };

    return &tms_TopicList_g_typePlugin;
}
#endif

RTIBool tms_TopicList_initialize(
    tms_TopicList* sample) {
    return tms_TopicList_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_TopicList_initialize_ex(
    tms_TopicList* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_TopicList_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_TopicList_initialize_w_params(
    tms_TopicList* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        if(!DDS_StringSeq_initialize(sample  )){
            return RTI_FALSE;
        }
        if(!DDS_StringSeq_set_absolute_maximum(sample , ((tms_MAXLEN_TopicList)))){
            return RTI_FALSE;
        }
        if (!DDS_StringSeq_set_maximum(sample , ((tms_MAXLEN_TopicList)))) {
            return RTI_FALSE;
        }
        buffer = DDS_StringSeq_get_contiguous_bufferI(
            sample );

        if (buffer != NULL) {
            if (!RTICdrType_initStringArray(buffer, 
            ((tms_MAXLEN_TopicList)),
            ((tms_MAXLEN_TopicName))+1,
            RTI_CDR_CHAR_TYPE)) {
                return RTI_FALSE;
            } 
        }
    } else { 
        if(!DDS_StringSeq_set_length(sample, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_TopicList_finalize_w_return(
    tms_TopicList* sample)
{
    tms_TopicList_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_TopicList_finalize(
    tms_TopicList* sample)
{

    tms_TopicList_finalize_ex(sample,RTI_TRUE);
}

void tms_TopicList_finalize_ex(
    tms_TopicList* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_TopicList_finalize_w_params(
        sample,&deallocParams);
}

void tms_TopicList_finalize_w_params(
    tms_TopicList* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!DDS_StringSeq_finalize(sample)){
        return;
    }

}

void tms_TopicList_finalize_optional_members(
    tms_TopicList* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_TopicList_copy(
    tms_TopicList* dst,
    const tms_TopicList* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!DDS_StringSeq_copy(dst ,
        src )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_TopicList' sequence class.
*/
#define T tms_TopicList
#define TSeq tms_TopicListSeq

#define T_initialize_w_params tms_TopicList_initialize_w_params

#define T_finalize_w_params   tms_TopicList_finalize_w_params
#define T_copy       tms_TopicList_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_Point2DTYPENAME = "tms::Point2D";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_Point2D_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_Point2D_g_tc_members[2]=
    {

        {
            (char *)"x",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"y",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_Point2D_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::Point2D", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_Point2D_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_Point2D*/

    if (is_initialized) {
        return &tms_Point2D_g_tc;
    }

    tms_Point2D_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_Point2D_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_Point2D_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */
    tms_Point2D_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_Point2D_g_tc_members[0]._annotations._defaultValue._u.float_value = 0.0f;
    tms_Point2D_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_Point2D_g_tc_members[0]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_Point2D_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_Point2D_g_tc_members[0]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_Point2D_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_Point2D_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_Point2D_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_Point2D_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_Point2D_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_Point2D_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_Point2D_g_tc._data._sampleAccessInfo =
    tms_Point2D_get_sample_access_info();
    tms_Point2D_g_tc._data._typePlugin =
    tms_Point2D_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_Point2D_g_tc;
}

#define TSeq tms_Point2DSeq
#define T tms_Point2D
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_Point2D_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_Point2D_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_Point2DSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_Point2DSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_Point2D_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_Point2D_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_Point2D *sample;

    static RTIXCdrMemberAccessInfo tms_Point2D_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_Point2D_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_Point2D_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_Point2D);
    if (sample == NULL) {
        return NULL;
    }

    tms_Point2D_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->x - (char *)sample);

    tms_Point2D_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->y - (char *)sample);

    tms_Point2D_g_sampleAccessInfo.memberAccessInfos = 
    tms_Point2D_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_Point2D);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_Point2D_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_Point2D_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_Point2D_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_Point2D_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_Point2D_get_member_value_pointer;

    tms_Point2D_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_Point2D_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_Point2D_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_Point2D_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_Point2D_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_Point2D_finalize_w_return,
        NULL
    };

    return &tms_Point2D_g_typePlugin;
}
#endif

RTIBool tms_Point2D_initialize(
    tms_Point2D* sample) {
    return tms_Point2D_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_Point2D_initialize_ex(
    tms_Point2D* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_Point2D_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_Point2D_initialize_w_params(
    tms_Point2D* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->x = 0.0f;

    sample->y = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_Point2D_finalize_w_return(
    tms_Point2D* sample)
{
    tms_Point2D_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_Point2D_finalize(
    tms_Point2D* sample)
{

    tms_Point2D_finalize_ex(sample,RTI_TRUE);
}

void tms_Point2D_finalize_ex(
    tms_Point2D* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_Point2D_finalize_w_params(
        sample,&deallocParams);
}

void tms_Point2D_finalize_w_params(
    tms_Point2D* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_Point2D_finalize_optional_members(
    tms_Point2D* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_Point2D_copy(
    tms_Point2D* dst,
    const tms_Point2D* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyFloat (
            &dst->x, &src->x)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->y, &src->y)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_Point2D' sequence class.
*/
#define T tms_Point2D
#define TSeq tms_Point2DSeq

#define T_initialize_w_params tms_Point2D_initialize_w_params

#define T_finalize_w_params   tms_Point2D_finalize_w_params
#define T_copy       tms_Point2D_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_Curve2DTYPENAME = "tms::Curve2D";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_Curve2D_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_Curve2D_g_tc_points_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_points)),NULL);

    static DDS_TypeCode_Member tms_Curve2D_g_tc_members[1]=
    {

        {
            (char *)"points",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_Curve2D_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::Curve2D", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            1, /* Number of members */
            tms_Curve2D_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_Curve2D*/

    if (is_initialized) {
        return &tms_Curve2D_g_tc;
    }

    tms_Curve2D_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_Curve2D_g_tc_points_sequence._data._typeCode = (RTICdrTypeCode *)tms_Point2D_get_typecode();
    tms_Curve2D_g_tc_points_sequence._data._sampleAccessInfo = tms_Point2D_get_sample_seq_access_info();
    tms_Curve2D_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)& tms_Curve2D_g_tc_points_sequence;

    /* Initialize the values for member annotations. */

    tms_Curve2D_g_tc._data._sampleAccessInfo =
    tms_Curve2D_get_sample_access_info();
    tms_Curve2D_g_tc._data._typePlugin =
    tms_Curve2D_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_Curve2D_g_tc;
}

#define TSeq tms_Curve2DSeq
#define T tms_Curve2D
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_Curve2D_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_Curve2D_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_Curve2DSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_Curve2DSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_Curve2D_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_Curve2D_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_Curve2D *sample;

    static RTIXCdrMemberAccessInfo tms_Curve2D_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_Curve2D_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_Curve2D_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_Curve2D);
    if (sample == NULL) {
        return NULL;
    }

    tms_Curve2D_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->points - (char *)sample);

    tms_Curve2D_g_sampleAccessInfo.memberAccessInfos = 
    tms_Curve2D_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_Curve2D);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_Curve2D_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_Curve2D_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_Curve2D_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_Curve2D_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_Curve2D_get_member_value_pointer;

    tms_Curve2D_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_Curve2D_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_Curve2D_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_Curve2D_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_Curve2D_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_Curve2D_finalize_w_return,
        NULL
    };

    return &tms_Curve2D_g_typePlugin;
}
#endif

RTIBool tms_Curve2D_initialize(
    tms_Curve2D* sample) {
    return tms_Curve2D_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_Curve2D_initialize_ex(
    tms_Curve2D* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_Curve2D_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_Curve2D_initialize_w_params(
    tms_Curve2D* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        if(!tms_Point2DSeq_initialize(&sample->points )){
            return RTI_FALSE;
        };
        if(!tms_Point2DSeq_set_element_allocation_params(&sample->points ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_Point2DSeq_set_absolute_maximum(&sample->points , ((tms_MAXLEN_points)))){
            return RTI_FALSE;
        }
        if (!tms_Point2DSeq_set_maximum(&sample->points, ((tms_MAXLEN_points)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_Point2DSeq_set_length(&sample->points, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_Curve2D_finalize_w_return(
    tms_Curve2D* sample)
{
    tms_Curve2D_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_Curve2D_finalize(
    tms_Curve2D* sample)
{

    tms_Curve2D_finalize_ex(sample,RTI_TRUE);
}

void tms_Curve2D_finalize_ex(
    tms_Curve2D* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_Curve2D_finalize_w_params(
        sample,&deallocParams);
}

void tms_Curve2D_finalize_w_params(
    tms_Curve2D* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!tms_Point2DSeq_set_element_deallocation_params(
        &sample->points,deallocParams)){
        return; 
    }
    if(!tms_Point2DSeq_finalize(&sample->points)){
        return;
    }

}

void tms_Curve2D_finalize_optional_members(
    tms_Curve2D* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_Curve2D_copy(
    tms_Curve2D* dst,
    const tms_Curve2D* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Point2DSeq_copy(&dst->points ,
        &src->points )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_Curve2D' sequence class.
*/
#define T tms_Curve2D
#define TSeq tms_Curve2DSeq

#define T_initialize_w_params tms_Curve2D_initialize_w_params

#define T_finalize_w_params   tms_Curve2D_finalize_w_params
#define T_copy       tms_Curve2D_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PublicKey_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_PublicKey_g_tc_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_PublicKey)),NULL);

    static DDS_TypeCode tms_PublicKey_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::PublicKey", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_PublicKey */

    if (is_initialized) {
        return &tms_PublicKey_g_tc;
    }

    tms_PublicKey_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PublicKey_g_tc_sequence._data._typeCode = (RTICdrTypeCode *)&DDS_g_tc_octet_w_new;
    tms_PublicKey_g_tc_sequence._data._sampleAccessInfo = &DDS_g_sai_octet_seq;
    tms_PublicKey_g_tc._data._typeCode =  (RTICdrTypeCode *)& tms_PublicKey_g_tc_sequence;

    /* Initialize the values for member annotations. */

    tms_PublicKey_g_tc._data._sampleAccessInfo =
    tms_PublicKey_get_sample_access_info();
    tms_PublicKey_g_tc._data._typePlugin =
    tms_PublicKey_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PublicKey_g_tc;
}

#define TSeq tms_PublicKeySeq
#define T tms_PublicKey
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PublicKey_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PublicKey_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PublicKeySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PublicKeySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PublicKey_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PublicKey_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PublicKey_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PublicKey_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PublicKey_g_sampleAccessInfo;
    }

    tms_PublicKey_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PublicKey_g_sampleAccessInfo.memberAccessInfos = 
    tms_PublicKey_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PublicKey);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PublicKey_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PublicKey_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PublicKey_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PublicKey_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PublicKey_get_member_value_pointer;

    tms_PublicKey_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PublicKey_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PublicKey_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PublicKey_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PublicKey_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PublicKey_finalize_w_return,
        NULL
    };

    return &tms_PublicKey_g_typePlugin;
}
#endif

RTIBool tms_PublicKey_initialize(
    tms_PublicKey* sample) {
    return tms_PublicKey_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PublicKey_initialize_ex(
    tms_PublicKey* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PublicKey_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PublicKey_initialize_w_params(
    tms_PublicKey* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        if(!DDS_OctetSeq_initialize(sample  )){
            return RTI_FALSE;
        }
        if(!DDS_OctetSeq_set_absolute_maximum(sample , ((tms_MAXLEN_PublicKey)))){
            return RTI_FALSE;
        }
        if (!DDS_OctetSeq_set_maximum(sample , ((tms_MAXLEN_PublicKey)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!DDS_OctetSeq_set_length(sample, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_PublicKey_finalize_w_return(
    tms_PublicKey* sample)
{
    tms_PublicKey_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PublicKey_finalize(
    tms_PublicKey* sample)
{

    tms_PublicKey_finalize_ex(sample,RTI_TRUE);
}

void tms_PublicKey_finalize_ex(
    tms_PublicKey* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PublicKey_finalize_w_params(
        sample,&deallocParams);
}

void tms_PublicKey_finalize_w_params(
    tms_PublicKey* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!DDS_OctetSeq_finalize(sample)){
        return;
    }

}

void tms_PublicKey_finalize_optional_members(
    tms_PublicKey* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PublicKey_copy(
    tms_PublicKey* dst,
    const tms_PublicKey* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!DDS_OctetSeq_copy(dst ,
        src )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PublicKey' sequence class.
*/
#define T tms_PublicKey
#define TSeq tms_PublicKeySeq

#define T_initialize_w_params tms_PublicKey_initialize_w_params

#define T_finalize_w_params   tms_PublicKey_finalize_w_params
#define T_copy       tms_PublicKey_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_Fingerprint_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_Fingerprint_g_tc_array =DDS_INITIALIZE_ARRAY_TYPECODE(1,(tms_LEN_Fingerprint), NULL,NULL);

    static DDS_TypeCode tms_Fingerprint_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::Fingerprint", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_Fingerprint */

    if (is_initialized) {
        return &tms_Fingerprint_g_tc;
    }

    tms_Fingerprint_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_Fingerprint_g_tc_array._data._typeCode =(RTICdrTypeCode *)&DDS_g_tc_octet_w_new;
    tms_Fingerprint_g_tc._data._typeCode =  (RTICdrTypeCode *)& tms_Fingerprint_g_tc_array;

    /* Initialize the values for member annotations. */

    tms_Fingerprint_g_tc._data._sampleAccessInfo =
    tms_Fingerprint_get_sample_access_info();
    tms_Fingerprint_g_tc._data._typePlugin =
    tms_Fingerprint_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_Fingerprint_g_tc;
}

#define ALIAS_OF_ARRAY

#define TSeq tms_FingerprintSeq
#define T tms_Fingerprint
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

#undef ALIAS_OF_ARRAY

RTIXCdrSampleAccessInfo *tms_Fingerprint_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_Fingerprint_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_FingerprintSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_FingerprintSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_Fingerprint_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_Fingerprint_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_Fingerprint_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_Fingerprint_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_Fingerprint_g_sampleAccessInfo;
    }

    tms_Fingerprint_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_Fingerprint_g_sampleAccessInfo.memberAccessInfos = 
    tms_Fingerprint_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_Fingerprint);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_Fingerprint_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_Fingerprint_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_Fingerprint_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_Fingerprint_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_Fingerprint_get_member_value_pointer;

    tms_Fingerprint_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_Fingerprint_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_Fingerprint_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_Fingerprint_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_Fingerprint_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_Fingerprint_finalize_w_return,
        NULL
    };

    return &tms_Fingerprint_g_typePlugin;
}
#endif

RTIBool tms_Fingerprint_initialize(
    tms_Fingerprint* sample) {
    return tms_Fingerprint_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_Fingerprint_initialize_ex(
    tms_Fingerprint* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_Fingerprint_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_Fingerprint_initialize_w_params(
    tms_Fingerprint* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!RTICdrType_initArray(
        (*sample), ((tms_LEN_Fingerprint)), RTI_CDR_OCTET_SIZE)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_Fingerprint_finalize_w_return(
    tms_Fingerprint* sample)
{
    tms_Fingerprint_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_Fingerprint_finalize(
    tms_Fingerprint* sample)
{

    tms_Fingerprint_finalize_ex(sample,RTI_TRUE);
}

void tms_Fingerprint_finalize_ex(
    tms_Fingerprint* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_Fingerprint_finalize_w_params(
        sample,&deallocParams);
}

void tms_Fingerprint_finalize_w_params(
    tms_Fingerprint* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_Fingerprint_finalize_optional_members(
    tms_Fingerprint* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_Fingerprint_copy(
    tms_Fingerprint* dst,
    const tms_Fingerprint* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyArray(
            (*dst) ,(*src),((tms_LEN_Fingerprint)), RTI_CDR_OCTET_SIZE)) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_Fingerprint' sequence class.
*/
#define T tms_Fingerprint
#define TSeq tms_FingerprintSeq

#define T_initialize_w_params tms_Fingerprint_initialize_w_params

#define T_finalize_w_params   tms_Fingerprint_finalize_w_params
#define T_copy       tms_Fingerprint_copy

#define T_no_get  
#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_no_get  

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_Signature_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_Signature_g_tc_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_Signature)),NULL);

    static DDS_TypeCode tms_Signature_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::Signature", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_Signature */

    if (is_initialized) {
        return &tms_Signature_g_tc;
    }

    tms_Signature_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_Signature_g_tc_sequence._data._typeCode = (RTICdrTypeCode *)&DDS_g_tc_octet_w_new;
    tms_Signature_g_tc_sequence._data._sampleAccessInfo = &DDS_g_sai_octet_seq;
    tms_Signature_g_tc._data._typeCode =  (RTICdrTypeCode *)& tms_Signature_g_tc_sequence;

    /* Initialize the values for member annotations. */

    tms_Signature_g_tc._data._sampleAccessInfo =
    tms_Signature_get_sample_access_info();
    tms_Signature_g_tc._data._typePlugin =
    tms_Signature_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_Signature_g_tc;
}

#define TSeq tms_SignatureSeq
#define T tms_Signature
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_Signature_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_Signature_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SignatureSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SignatureSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_Signature_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_Signature_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_Signature_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_Signature_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_Signature_g_sampleAccessInfo;
    }

    tms_Signature_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_Signature_g_sampleAccessInfo.memberAccessInfos = 
    tms_Signature_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_Signature);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_Signature_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_Signature_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_Signature_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_Signature_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_Signature_get_member_value_pointer;

    tms_Signature_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_Signature_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_Signature_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_Signature_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_Signature_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_Signature_finalize_w_return,
        NULL
    };

    return &tms_Signature_g_typePlugin;
}
#endif

RTIBool tms_Signature_initialize(
    tms_Signature* sample) {
    return tms_Signature_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_Signature_initialize_ex(
    tms_Signature* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_Signature_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_Signature_initialize_w_params(
    tms_Signature* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        if(!DDS_OctetSeq_initialize(sample  )){
            return RTI_FALSE;
        }
        if(!DDS_OctetSeq_set_absolute_maximum(sample , ((tms_MAXLEN_Signature)))){
            return RTI_FALSE;
        }
        if (!DDS_OctetSeq_set_maximum(sample , ((tms_MAXLEN_Signature)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!DDS_OctetSeq_set_length(sample, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_Signature_finalize_w_return(
    tms_Signature* sample)
{
    tms_Signature_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_Signature_finalize(
    tms_Signature* sample)
{

    tms_Signature_finalize_ex(sample,RTI_TRUE);
}

void tms_Signature_finalize_ex(
    tms_Signature* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_Signature_finalize_w_params(
        sample,&deallocParams);
}

void tms_Signature_finalize_w_params(
    tms_Signature* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!DDS_OctetSeq_finalize(sample)){
        return;
    }

}

void tms_Signature_finalize_optional_members(
    tms_Signature* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_Signature_copy(
    tms_Signature* dst,
    const tms_Signature* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!DDS_OctetSeq_copy(dst ,
        src )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_Signature' sequence class.
*/
#define T tms_Signature
#define TSeq tms_SignatureSeq

#define T_initialize_w_params tms_Signature_initialize_w_params

#define T_finalize_w_params   tms_Signature_finalize_w_params
#define T_copy       tms_Signature_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ClockMonotonicTYPENAME = "tms::ClockMonotonic";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ClockMonotonic_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ClockMonotonic_g_tc_members[2]=
    {

        {
            (char *)"seconds",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nanoseconds",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ClockMonotonic_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ClockMonotonic", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_ClockMonotonic_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ClockMonotonic*/

    if (is_initialized) {
        return &tms_ClockMonotonic_g_tc;
    }

    tms_ClockMonotonic_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ClockMonotonic_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;
    tms_ClockMonotonic_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;

    /* Initialize the values for member annotations. */
    tms_ClockMonotonic_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockMonotonic_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_ClockMonotonic_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockMonotonic_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_ClockMonotonic_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockMonotonic_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_ClockMonotonic_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockMonotonic_g_tc_members[1]._annotations._defaultValue._u.ulong_value = 0u;
    tms_ClockMonotonic_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockMonotonic_g_tc_members[1]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_ClockMonotonic_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockMonotonic_g_tc_members[1]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_ClockMonotonic_g_tc._data._sampleAccessInfo =
    tms_ClockMonotonic_get_sample_access_info();
    tms_ClockMonotonic_g_tc._data._typePlugin =
    tms_ClockMonotonic_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ClockMonotonic_g_tc;
}

#define TSeq tms_ClockMonotonicSeq
#define T tms_ClockMonotonic
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ClockMonotonic_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ClockMonotonic_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ClockMonotonicSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ClockMonotonicSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ClockMonotonic_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ClockMonotonic_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ClockMonotonic *sample;

    static RTIXCdrMemberAccessInfo tms_ClockMonotonic_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ClockMonotonic_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ClockMonotonic_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ClockMonotonic);
    if (sample == NULL) {
        return NULL;
    }

    tms_ClockMonotonic_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->seconds - (char *)sample);

    tms_ClockMonotonic_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nanoseconds - (char *)sample);

    tms_ClockMonotonic_g_sampleAccessInfo.memberAccessInfos = 
    tms_ClockMonotonic_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ClockMonotonic);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ClockMonotonic_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ClockMonotonic_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ClockMonotonic_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ClockMonotonic_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ClockMonotonic_get_member_value_pointer;

    tms_ClockMonotonic_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ClockMonotonic_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ClockMonotonic_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ClockMonotonic_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ClockMonotonic_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ClockMonotonic_finalize_w_return,
        NULL
    };

    return &tms_ClockMonotonic_g_typePlugin;
}
#endif

RTIBool tms_ClockMonotonic_initialize(
    tms_ClockMonotonic* sample) {
    return tms_ClockMonotonic_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ClockMonotonic_initialize_ex(
    tms_ClockMonotonic* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ClockMonotonic_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ClockMonotonic_initialize_w_params(
    tms_ClockMonotonic* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->seconds = 0u;

    sample->nanoseconds = 0u;

    return RTI_TRUE;
}

RTIBool tms_ClockMonotonic_finalize_w_return(
    tms_ClockMonotonic* sample)
{
    tms_ClockMonotonic_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ClockMonotonic_finalize(
    tms_ClockMonotonic* sample)
{

    tms_ClockMonotonic_finalize_ex(sample,RTI_TRUE);
}

void tms_ClockMonotonic_finalize_ex(
    tms_ClockMonotonic* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ClockMonotonic_finalize_w_params(
        sample,&deallocParams);
}

void tms_ClockMonotonic_finalize_w_params(
    tms_ClockMonotonic* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_ClockMonotonic_finalize_optional_members(
    tms_ClockMonotonic* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ClockMonotonic_copy(
    tms_ClockMonotonic* dst,
    const tms_ClockMonotonic* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->seconds, &src->seconds)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->nanoseconds, &src->nanoseconds)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ClockMonotonic' sequence class.
*/
#define T tms_ClockMonotonic
#define TSeq tms_ClockMonotonicSeq

#define T_initialize_w_params tms_ClockMonotonic_initialize_w_params

#define T_finalize_w_params   tms_ClockMonotonic_finalize_w_params
#define T_copy       tms_ClockMonotonic_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ClockRealtimeTYPENAME = "tms::ClockRealtime";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ClockRealtime_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ClockRealtime_g_tc_members[3]=
    {

        {
            (char *)"epoch",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"seconds",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nanoseconds",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ClockRealtime_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ClockRealtime", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_ClockRealtime_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ClockRealtime*/

    if (is_initialized) {
        return &tms_ClockRealtime_g_tc;
    }

    tms_ClockRealtime_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ClockRealtime_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ushort_w_new;
    tms_ClockRealtime_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;
    tms_ClockRealtime_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;

    /* Initialize the values for member annotations. */
    tms_ClockRealtime_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_ClockRealtime_g_tc_members[0]._annotations._defaultValue._u.ushort_value = 0;
    tms_ClockRealtime_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_ClockRealtime_g_tc_members[0]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_ClockRealtime_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_ClockRealtime_g_tc_members[0]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_ClockRealtime_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockRealtime_g_tc_members[1]._annotations._defaultValue._u.ulong_value = 0u;
    tms_ClockRealtime_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockRealtime_g_tc_members[1]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_ClockRealtime_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockRealtime_g_tc_members[1]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_ClockRealtime_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockRealtime_g_tc_members[2]._annotations._defaultValue._u.ulong_value = 0u;
    tms_ClockRealtime_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockRealtime_g_tc_members[2]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_ClockRealtime_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_ClockRealtime_g_tc_members[2]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_ClockRealtime_g_tc._data._sampleAccessInfo =
    tms_ClockRealtime_get_sample_access_info();
    tms_ClockRealtime_g_tc._data._typePlugin =
    tms_ClockRealtime_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ClockRealtime_g_tc;
}

#define TSeq tms_ClockRealtimeSeq
#define T tms_ClockRealtime
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ClockRealtime_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ClockRealtime_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ClockRealtimeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ClockRealtimeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ClockRealtime_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ClockRealtime_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ClockRealtime *sample;

    static RTIXCdrMemberAccessInfo tms_ClockRealtime_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ClockRealtime_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ClockRealtime_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ClockRealtime);
    if (sample == NULL) {
        return NULL;
    }

    tms_ClockRealtime_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->epoch - (char *)sample);

    tms_ClockRealtime_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->seconds - (char *)sample);

    tms_ClockRealtime_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nanoseconds - (char *)sample);

    tms_ClockRealtime_g_sampleAccessInfo.memberAccessInfos = 
    tms_ClockRealtime_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ClockRealtime);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ClockRealtime_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ClockRealtime_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ClockRealtime_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ClockRealtime_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ClockRealtime_get_member_value_pointer;

    tms_ClockRealtime_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ClockRealtime_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ClockRealtime_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ClockRealtime_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ClockRealtime_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ClockRealtime_finalize_w_return,
        NULL
    };

    return &tms_ClockRealtime_g_typePlugin;
}
#endif

RTIBool tms_ClockRealtime_initialize(
    tms_ClockRealtime* sample) {
    return tms_ClockRealtime_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ClockRealtime_initialize_ex(
    tms_ClockRealtime* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ClockRealtime_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ClockRealtime_initialize_w_params(
    tms_ClockRealtime* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->epoch = 0;

    sample->seconds = 0u;

    sample->nanoseconds = 0u;

    return RTI_TRUE;
}

RTIBool tms_ClockRealtime_finalize_w_return(
    tms_ClockRealtime* sample)
{
    tms_ClockRealtime_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ClockRealtime_finalize(
    tms_ClockRealtime* sample)
{

    tms_ClockRealtime_finalize_ex(sample,RTI_TRUE);
}

void tms_ClockRealtime_finalize_ex(
    tms_ClockRealtime* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ClockRealtime_finalize_w_params(
        sample,&deallocParams);
}

void tms_ClockRealtime_finalize_w_params(
    tms_ClockRealtime* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_ClockRealtime_finalize_optional_members(
    tms_ClockRealtime* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ClockRealtime_copy(
    tms_ClockRealtime* dst,
    const tms_ClockRealtime* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedShort (
            &dst->epoch, &src->epoch)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->seconds, &src->seconds)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->nanoseconds, &src->nanoseconds)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ClockRealtime' sequence class.
*/
#define T tms_ClockRealtime
#define TSeq tms_ClockRealtimeSeq

#define T_initialize_w_params tms_ClockRealtime_initialize_w_params

#define T_finalize_w_params   tms_ClockRealtime_finalize_w_params
#define T_copy       tms_ClockRealtime_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ClockMonotonicPersistenceTypeTYPENAME = "tms::ClockMonotonicPersistenceType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ClockMonotonicPersistenceType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ClockMonotonicPersistenceType_g_tc_members[4]=
    {

        {
            (char *)"CMPT_UNKNOWN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CMPT_UNKNOWN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CMPT_RESET",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CMPT_RESET, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CMPT_ACCUMULATE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CMPT_ACCUMULATE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CMPT_OTHER",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CMPT_OTHER, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ClockMonotonicPersistenceType_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ClockMonotonicPersistenceType", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_ClockMonotonicPersistenceType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ClockMonotonicPersistenceType*/

    if (is_initialized) {
        return &tms_ClockMonotonicPersistenceType_g_tc;
    }

    tms_ClockMonotonicPersistenceType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_ClockMonotonicPersistenceType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_ClockMonotonicPersistenceType_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_ClockMonotonicPersistenceType_g_tc._data._sampleAccessInfo =
    tms_ClockMonotonicPersistenceType_get_sample_access_info();
    tms_ClockMonotonicPersistenceType_g_tc._data._typePlugin =
    tms_ClockMonotonicPersistenceType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ClockMonotonicPersistenceType_g_tc;
}

#define TSeq tms_ClockMonotonicPersistenceTypeSeq
#define T tms_ClockMonotonicPersistenceType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ClockMonotonicPersistenceType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ClockMonotonicPersistenceType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ClockMonotonicPersistenceTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ClockMonotonicPersistenceTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ClockMonotonicPersistenceType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ClockMonotonicPersistenceType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_ClockMonotonicPersistenceType_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ClockMonotonicPersistenceType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ClockMonotonicPersistenceType_g_sampleAccessInfo;
    }

    tms_ClockMonotonicPersistenceType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_ClockMonotonicPersistenceType_g_sampleAccessInfo.memberAccessInfos = 
    tms_ClockMonotonicPersistenceType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ClockMonotonicPersistenceType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ClockMonotonicPersistenceType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ClockMonotonicPersistenceType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ClockMonotonicPersistenceType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ClockMonotonicPersistenceType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ClockMonotonicPersistenceType_get_member_value_pointer;

    tms_ClockMonotonicPersistenceType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ClockMonotonicPersistenceType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ClockMonotonicPersistenceType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ClockMonotonicPersistenceType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ClockMonotonicPersistenceType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ClockMonotonicPersistenceType_finalize_w_return,
        NULL
    };

    return &tms_ClockMonotonicPersistenceType_g_typePlugin;
}
#endif

RTIBool tms_ClockMonotonicPersistenceType_initialize(
    tms_ClockMonotonicPersistenceType* sample) {
    *sample = CMPT_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_ClockMonotonicPersistenceType_initialize_ex(
    tms_ClockMonotonicPersistenceType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ClockMonotonicPersistenceType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ClockMonotonicPersistenceType_initialize_w_params(
    tms_ClockMonotonicPersistenceType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = CMPT_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_ClockMonotonicPersistenceType_finalize_w_return(
    tms_ClockMonotonicPersistenceType* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_ClockMonotonicPersistenceType_finalize(
    tms_ClockMonotonicPersistenceType* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_ClockMonotonicPersistenceType_finalize_ex(
    tms_ClockMonotonicPersistenceType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ClockMonotonicPersistenceType_finalize_w_params(
        sample,&deallocParams);
}

void tms_ClockMonotonicPersistenceType_finalize_w_params(
    tms_ClockMonotonicPersistenceType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_ClockMonotonicPersistenceType_finalize_optional_members(
    tms_ClockMonotonicPersistenceType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ClockMonotonicPersistenceType_copy(
    tms_ClockMonotonicPersistenceType* dst,
    const tms_ClockMonotonicPersistenceType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ClockMonotonicPersistenceType' sequence class.
*/
#define T tms_ClockMonotonicPersistenceType
#define TSeq tms_ClockMonotonicPersistenceTypeSeq

#define T_initialize_w_params tms_ClockMonotonicPersistenceType_initialize_w_params

#define T_finalize_w_params   tms_ClockMonotonicPersistenceType_finalize_w_params
#define T_copy       tms_ClockMonotonicPersistenceType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ClockStatusTYPENAME = "tms::ClockStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ClockStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ClockStatus_g_tc_members[6]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"monotonic",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"monotonicPersistence",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realtime",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realtimeSource",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realtimeSetTime",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ClockStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ClockStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_ClockStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ClockStatus*/

    if (is_initialized) {
        return &tms_ClockStatus_g_tc;
    }

    tms_ClockStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ClockStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ClockStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_ClockStatus_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonicPersistenceType_get_typecode();
    tms_ClockStatus_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_ClockRealtime_get_typecode();
    tms_ClockStatus_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_octet_w_new;
    tms_ClockStatus_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_ClockRealtime_get_typecode();

    /* Initialize the values for member annotations. */

    tms_ClockStatus_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_ClockStatus_g_tc_members[2]._annotations._defaultValue._u.enumerated_value = 0;

    tms_ClockStatus_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_OCTET;
    tms_ClockStatus_g_tc_members[4]._annotations._defaultValue._u.octet_value = 0;
    tms_ClockStatus_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_OCTET;
    tms_ClockStatus_g_tc_members[4]._annotations._minValue._u.octet_value = RTIXCdrOctet_MIN;
    tms_ClockStatus_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_OCTET;
    tms_ClockStatus_g_tc_members[4]._annotations._maxValue._u.octet_value = RTIXCdrOctet_MAX;

    tms_ClockStatus_g_tc._data._sampleAccessInfo =
    tms_ClockStatus_get_sample_access_info();
    tms_ClockStatus_g_tc._data._typePlugin =
    tms_ClockStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ClockStatus_g_tc;
}

#define TSeq tms_ClockStatusSeq
#define T tms_ClockStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ClockStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ClockStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ClockStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ClockStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ClockStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ClockStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ClockStatus *sample;

    static RTIXCdrMemberAccessInfo tms_ClockStatus_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ClockStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ClockStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ClockStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_ClockStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_ClockStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->monotonic - (char *)sample);

    tms_ClockStatus_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->monotonicPersistence - (char *)sample);

    tms_ClockStatus_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realtime - (char *)sample);

    tms_ClockStatus_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realtimeSource - (char *)sample);

    tms_ClockStatus_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realtimeSetTime - (char *)sample);

    tms_ClockStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_ClockStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ClockStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ClockStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ClockStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ClockStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ClockStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ClockStatus_get_member_value_pointer;

    tms_ClockStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ClockStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ClockStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ClockStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ClockStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ClockStatus_finalize_w_return,
        NULL
    };

    return &tms_ClockStatus_g_typePlugin;
}
#endif

RTIBool tms_ClockStatus_initialize(
    tms_ClockStatus* sample) {
    return tms_ClockStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ClockStatus_initialize_ex(
    tms_ClockStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ClockStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ClockStatus_initialize_w_params(
    tms_ClockStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockMonotonic_initialize_w_params(&sample->monotonic,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->monotonicPersistence = CMPT_UNKNOWN;
    if (!tms_ClockRealtime_initialize_w_params(&sample->realtime,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->realtimeSource = 0;

    if (!tms_ClockRealtime_initialize_w_params(&sample->realtimeSetTime,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_ClockStatus_finalize_w_return(
    tms_ClockStatus* sample)
{
    tms_ClockStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ClockStatus_finalize(
    tms_ClockStatus* sample)
{

    tms_ClockStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_ClockStatus_finalize_ex(
    tms_ClockStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ClockStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_ClockStatus_finalize_w_params(
    tms_ClockStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->monotonic,deallocParams);

    tms_ClockMonotonicPersistenceType_finalize_w_params(&sample->monotonicPersistence,deallocParams);

    tms_ClockRealtime_finalize_w_params(&sample->realtime,deallocParams);

    tms_ClockRealtime_finalize_w_params(&sample->realtimeSetTime,deallocParams);

}

void tms_ClockStatus_finalize_optional_members(
    tms_ClockStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ClockStatus_copy(
    tms_ClockStatus* dst,
    const tms_ClockStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->monotonic,(const tms_ClockMonotonic*)&src->monotonic)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonicPersistenceType_copy(
            &dst->monotonicPersistence,(const tms_ClockMonotonicPersistenceType*)&src->monotonicPersistence)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockRealtime_copy(
            &dst->realtime,(const tms_ClockRealtime*)&src->realtime)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyOctet (
            &dst->realtimeSource, &src->realtimeSource)) { 
            return RTI_FALSE;
        }
        if (!tms_ClockRealtime_copy(
            &dst->realtimeSetTime,(const tms_ClockRealtime*)&src->realtimeSetTime)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ClockStatus' sequence class.
*/
#define T tms_ClockStatus
#define TSeq tms_ClockStatusSeq

#define T_initialize_w_params tms_ClockStatus_initialize_w_params

#define T_finalize_w_params   tms_ClockStatus_finalize_w_params
#define T_copy       tms_ClockStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_SampleIdTYPENAME = "tms::SampleId";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SampleId_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_SampleId_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"sequenceNumber",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_SampleId_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::SampleId", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_SampleId_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_SampleId*/

    if (is_initialized) {
        return &tms_SampleId_g_tc;
    }

    tms_SampleId_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_SampleId_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_SampleId_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulonglong_w_new;

    /* Initialize the values for member annotations. */

    tms_SampleId_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_SampleId_g_tc_members[1]._annotations._defaultValue._u.ulong_long_value = 0ull;
    tms_SampleId_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_SampleId_g_tc_members[1]._annotations._minValue._u.ulong_long_value = RTIXCdrUnsignedLongLong_MIN;
    tms_SampleId_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_SampleId_g_tc_members[1]._annotations._maxValue._u.ulong_long_value = RTIXCdrUnsignedLongLong_MAX;

    tms_SampleId_g_tc._data._sampleAccessInfo =
    tms_SampleId_get_sample_access_info();
    tms_SampleId_g_tc._data._typePlugin =
    tms_SampleId_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SampleId_g_tc;
}

#define TSeq tms_SampleIdSeq
#define T tms_SampleId
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SampleId_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SampleId_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SampleIdSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SampleIdSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SampleId_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SampleId_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_SampleId *sample;

    static RTIXCdrMemberAccessInfo tms_SampleId_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SampleId_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SampleId_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_SampleId);
    if (sample == NULL) {
        return NULL;
    }

    tms_SampleId_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_SampleId_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->sequenceNumber - (char *)sample);

    tms_SampleId_g_sampleAccessInfo.memberAccessInfos = 
    tms_SampleId_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SampleId);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SampleId_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SampleId_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SampleId_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SampleId_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SampleId_get_member_value_pointer;

    tms_SampleId_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SampleId_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SampleId_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SampleId_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SampleId_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SampleId_finalize_w_return,
        NULL
    };

    return &tms_SampleId_g_typePlugin;
}
#endif

RTIBool tms_SampleId_initialize(
    tms_SampleId* sample) {
    return tms_SampleId_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_SampleId_initialize_ex(
    tms_SampleId* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SampleId_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SampleId_initialize_w_params(
    tms_SampleId* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->sequenceNumber = 0ull;

    return RTI_TRUE;
}

RTIBool tms_SampleId_finalize_w_return(
    tms_SampleId* sample)
{
    tms_SampleId_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_SampleId_finalize(
    tms_SampleId* sample)
{

    tms_SampleId_finalize_ex(sample,RTI_TRUE);
}

void tms_SampleId_finalize_ex(
    tms_SampleId* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SampleId_finalize_w_params(
        sample,&deallocParams);
}

void tms_SampleId_finalize_w_params(
    tms_SampleId* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_SampleId_finalize_optional_members(
    tms_SampleId* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SampleId_copy(
    tms_SampleId* dst,
    const tms_SampleId* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedLongLong (
            &dst->sequenceNumber, &src->sequenceNumber)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SampleId' sequence class.
*/
#define T tms_SampleId
#define TSeq tms_SampleIdSeq

#define T_initialize_w_params tms_SampleId_initialize_w_params

#define T_finalize_w_params   tms_SampleId_finalize_w_params
#define T_copy       tms_SampleId_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ReplyStatusTYPENAME = "tms::ReplyStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ReplyStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_ReplyStatus_g_tc_reason_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_reason)));

    static DDS_TypeCode_Member tms_ReplyStatus_g_tc_members[2]=
    {

        {
            (char *)"code",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"reason",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ReplyStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ReplyStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_ReplyStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ReplyStatus*/

    if (is_initialized) {
        return &tms_ReplyStatus_g_tc;
    }

    tms_ReplyStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ReplyStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;
    tms_ReplyStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&tms_ReplyStatus_g_tc_reason_string;

    /* Initialize the values for member annotations. */
    tms_ReplyStatus_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_ReplyStatus_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_ReplyStatus_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_ReplyStatus_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_ReplyStatus_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_ReplyStatus_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_ReplyStatus_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ReplyStatus_g_tc_members[1]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ReplyStatus_g_tc._data._sampleAccessInfo =
    tms_ReplyStatus_get_sample_access_info();
    tms_ReplyStatus_g_tc._data._typePlugin =
    tms_ReplyStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ReplyStatus_g_tc;
}

#define TSeq tms_ReplyStatusSeq
#define T tms_ReplyStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ReplyStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ReplyStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ReplyStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ReplyStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ReplyStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ReplyStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ReplyStatus *sample;

    static RTIXCdrMemberAccessInfo tms_ReplyStatus_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ReplyStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ReplyStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ReplyStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_ReplyStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->code - (char *)sample);

    tms_ReplyStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->reason - (char *)sample);

    tms_ReplyStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_ReplyStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ReplyStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ReplyStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ReplyStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ReplyStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ReplyStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ReplyStatus_get_member_value_pointer;

    tms_ReplyStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ReplyStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ReplyStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ReplyStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ReplyStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ReplyStatus_finalize_w_return,
        NULL
    };

    return &tms_ReplyStatus_g_typePlugin;
}
#endif

RTIBool tms_ReplyStatus_initialize(
    tms_ReplyStatus* sample) {
    return tms_ReplyStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ReplyStatus_initialize_ex(
    tms_ReplyStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ReplyStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ReplyStatus_initialize_w_params(
    tms_ReplyStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->code = 0u;

    if (allocParams->allocate_memory) {
        sample->reason = DDS_String_alloc(((tms_MAXLEN_reason)));
        RTICdrType_copyStringEx(
            &sample->reason,
            "",
            ((tms_MAXLEN_reason)),
            RTI_FALSE);
        if (sample->reason == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->reason != NULL) {
            RTICdrType_copyStringEx(
                &sample->reason,
                "",
                ((tms_MAXLEN_reason)),
                RTI_FALSE);
            if (sample->reason == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_ReplyStatus_finalize_w_return(
    tms_ReplyStatus* sample)
{
    tms_ReplyStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ReplyStatus_finalize(
    tms_ReplyStatus* sample)
{

    tms_ReplyStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_ReplyStatus_finalize_ex(
    tms_ReplyStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ReplyStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_ReplyStatus_finalize_w_params(
    tms_ReplyStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if (sample->reason != NULL) {
        DDS_String_free(sample->reason);
        sample->reason=NULL;

    }
}

void tms_ReplyStatus_finalize_optional_members(
    tms_ReplyStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ReplyStatus_copy(
    tms_ReplyStatus* dst,
    const tms_ReplyStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->code, &src->code)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyStringEx (
            &dst->reason, src->reason, 
            ((tms_MAXLEN_reason)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ReplyStatus' sequence class.
*/
#define T tms_ReplyStatus
#define TSeq tms_ReplyStatusSeq

#define T_initialize_w_params tms_ReplyStatus_initialize_w_params

#define T_finalize_w_params   tms_ReplyStatus_finalize_w_params
#define T_copy       tms_ReplyStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_RequestResponseTYPENAME = "tms::RequestResponse";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_RequestResponse_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_RequestResponse_g_tc_members[2]=
    {

        {
            (char *)"relatedRequestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"status",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_RequestResponse_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::RequestResponse", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_RequestResponse_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_RequestResponse*/

    if (is_initialized) {
        return &tms_RequestResponse_g_tc;
    }

    tms_RequestResponse_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_RequestResponse_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_RequestResponse_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ReplyStatus_get_typecode();

    /* Initialize the values for member annotations. */

    tms_RequestResponse_g_tc._data._sampleAccessInfo =
    tms_RequestResponse_get_sample_access_info();
    tms_RequestResponse_g_tc._data._typePlugin =
    tms_RequestResponse_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_RequestResponse_g_tc;
}

#define TSeq tms_RequestResponseSeq
#define T tms_RequestResponse
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_RequestResponse_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_RequestResponse_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_RequestResponseSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_RequestResponseSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_RequestResponse_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_RequestResponse_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_RequestResponse *sample;

    static RTIXCdrMemberAccessInfo tms_RequestResponse_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_RequestResponse_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_RequestResponse_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_RequestResponse);
    if (sample == NULL) {
        return NULL;
    }

    tms_RequestResponse_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->relatedRequestId - (char *)sample);

    tms_RequestResponse_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->status - (char *)sample);

    tms_RequestResponse_g_sampleAccessInfo.memberAccessInfos = 
    tms_RequestResponse_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_RequestResponse);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_RequestResponse_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_RequestResponse_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_RequestResponse_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_RequestResponse_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_RequestResponse_get_member_value_pointer;

    tms_RequestResponse_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_RequestResponse_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_RequestResponse_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_RequestResponse_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_RequestResponse_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_RequestResponse_finalize_w_return,
        NULL
    };

    return &tms_RequestResponse_g_typePlugin;
}
#endif

RTIBool tms_RequestResponse_initialize(
    tms_RequestResponse* sample) {
    return tms_RequestResponse_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_RequestResponse_initialize_ex(
    tms_RequestResponse* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_RequestResponse_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_RequestResponse_initialize_w_params(
    tms_RequestResponse* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->relatedRequestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ReplyStatus_initialize_w_params(&sample->status,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_RequestResponse_finalize_w_return(
    tms_RequestResponse* sample)
{
    tms_RequestResponse_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_RequestResponse_finalize(
    tms_RequestResponse* sample)
{

    tms_RequestResponse_finalize_ex(sample,RTI_TRUE);
}

void tms_RequestResponse_finalize_ex(
    tms_RequestResponse* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_RequestResponse_finalize_w_params(
        sample,&deallocParams);
}

void tms_RequestResponse_finalize_w_params(
    tms_RequestResponse* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->relatedRequestId,deallocParams);

    tms_ReplyStatus_finalize_w_params(&sample->status,deallocParams);

}

void tms_RequestResponse_finalize_optional_members(
    tms_RequestResponse* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_RequestResponse_copy(
    tms_RequestResponse* dst,
    const tms_RequestResponse* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->relatedRequestId,(const tms_SampleId*)&src->relatedRequestId)) {
            return RTI_FALSE;
        } 
        if (!tms_ReplyStatus_copy(
            &dst->status,(const tms_ReplyStatus*)&src->status)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_RequestResponse' sequence class.
*/
#define T tms_RequestResponse
#define TSeq tms_RequestResponseSeq

#define T_initialize_w_params tms_RequestResponse_initialize_w_params

#define T_finalize_w_params   tms_RequestResponse_finalize_w_params
#define T_copy       tms_RequestResponse_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ParameterMetadataTYPENAME = "tms::ParameterMetadata";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ParameterMetadata_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_ParameterMetadata_g_tc_name_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_name)));
    static DDS_TypeCode tms_ParameterMetadata_g_tc_units_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_units)));

    static DDS_TypeCode_Member tms_ParameterMetadata_g_tc_members[7]=
    {

        {
            (char *)"name",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"units",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nominalMinValue",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nominalMaxValue",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"hardMinValue",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"hardMaxValue",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"resolution",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ParameterMetadata_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ParameterMetadata", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            7, /* Number of members */
            tms_ParameterMetadata_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ParameterMetadata*/

    if (is_initialized) {
        return &tms_ParameterMetadata_g_tc;
    }

    tms_ParameterMetadata_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ParameterMetadata_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&tms_ParameterMetadata_g_tc_name_string;
    tms_ParameterMetadata_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&tms_ParameterMetadata_g_tc_units_string;
    tms_ParameterMetadata_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ParameterMetadata_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ParameterMetadata_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ParameterMetadata_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ParameterMetadata_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */
    tms_ParameterMetadata_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ParameterMetadata_g_tc_members[0]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ParameterMetadata_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ParameterMetadata_g_tc_members[1]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ParameterMetadata_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ParameterMetadata_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ParameterMetadata_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ParameterMetadata_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ParameterMetadata_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ParameterMetadata_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ParameterMetadata_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ParameterMetadata_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ParameterMetadata_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ParameterMetadata_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[5]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ParameterMetadata_g_tc_members[5]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[5]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ParameterMetadata_g_tc_members[5]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[5]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ParameterMetadata_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[6]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ParameterMetadata_g_tc_members[6]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[6]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ParameterMetadata_g_tc_members[6]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterMetadata_g_tc_members[6]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ParameterMetadata_g_tc._data._sampleAccessInfo =
    tms_ParameterMetadata_get_sample_access_info();
    tms_ParameterMetadata_g_tc._data._typePlugin =
    tms_ParameterMetadata_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ParameterMetadata_g_tc;
}

#define TSeq tms_ParameterMetadataSeq
#define T tms_ParameterMetadata
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ParameterMetadata_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ParameterMetadata_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ParameterMetadataSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ParameterMetadataSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ParameterMetadata_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ParameterMetadata_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ParameterMetadata *sample;

    static RTIXCdrMemberAccessInfo tms_ParameterMetadata_g_memberAccessInfos[7] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ParameterMetadata_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ParameterMetadata_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ParameterMetadata);
    if (sample == NULL) {
        return NULL;
    }

    tms_ParameterMetadata_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->name - (char *)sample);

    tms_ParameterMetadata_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->units - (char *)sample);

    tms_ParameterMetadata_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nominalMinValue - (char *)sample);

    tms_ParameterMetadata_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nominalMaxValue - (char *)sample);

    tms_ParameterMetadata_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->hardMinValue - (char *)sample);

    tms_ParameterMetadata_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->hardMaxValue - (char *)sample);

    tms_ParameterMetadata_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->resolution - (char *)sample);

    tms_ParameterMetadata_g_sampleAccessInfo.memberAccessInfos = 
    tms_ParameterMetadata_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ParameterMetadata);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ParameterMetadata_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ParameterMetadata_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ParameterMetadata_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ParameterMetadata_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ParameterMetadata_get_member_value_pointer;

    tms_ParameterMetadata_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ParameterMetadata_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ParameterMetadata_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ParameterMetadata_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ParameterMetadata_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ParameterMetadata_finalize_w_return,
        NULL
    };

    return &tms_ParameterMetadata_g_typePlugin;
}
#endif

RTIBool tms_ParameterMetadata_initialize(
    tms_ParameterMetadata* sample) {
    return tms_ParameterMetadata_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ParameterMetadata_initialize_ex(
    tms_ParameterMetadata* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ParameterMetadata_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ParameterMetadata_initialize_w_params(
    tms_ParameterMetadata* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        sample->name = DDS_String_alloc(((tms_MAXLEN_name)));
        RTICdrType_copyStringEx(
            &sample->name,
            "",
            ((tms_MAXLEN_name)),
            RTI_FALSE);
        if (sample->name == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->name != NULL) {
            RTICdrType_copyStringEx(
                &sample->name,
                "",
                ((tms_MAXLEN_name)),
                RTI_FALSE);
            if (sample->name == NULL) {
                return RTI_FALSE;
            }
        }
    }

    if (allocParams->allocate_memory) {
        sample->units = DDS_String_alloc(((tms_MAXLEN_units)));
        RTICdrType_copyStringEx(
            &sample->units,
            "",
            ((tms_MAXLEN_units)),
            RTI_FALSE);
        if (sample->units == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->units != NULL) {
            RTICdrType_copyStringEx(
                &sample->units,
                "",
                ((tms_MAXLEN_units)),
                RTI_FALSE);
            if (sample->units == NULL) {
                return RTI_FALSE;
            }
        }
    }

    sample->nominalMinValue = 0.0f;

    sample->nominalMaxValue = 0.0f;

    sample->hardMinValue = 0.0f;

    sample->hardMaxValue = 0.0f;

    sample->resolution = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_ParameterMetadata_finalize_w_return(
    tms_ParameterMetadata* sample)
{
    tms_ParameterMetadata_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ParameterMetadata_finalize(
    tms_ParameterMetadata* sample)
{

    tms_ParameterMetadata_finalize_ex(sample,RTI_TRUE);
}

void tms_ParameterMetadata_finalize_ex(
    tms_ParameterMetadata* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ParameterMetadata_finalize_w_params(
        sample,&deallocParams);
}

void tms_ParameterMetadata_finalize_w_params(
    tms_ParameterMetadata* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if (sample->name != NULL) {
        DDS_String_free(sample->name);
        sample->name=NULL;

    }
    if (sample->units != NULL) {
        DDS_String_free(sample->units);
        sample->units=NULL;

    }

}

void tms_ParameterMetadata_finalize_optional_members(
    tms_ParameterMetadata* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ParameterMetadata_copy(
    tms_ParameterMetadata* dst,
    const tms_ParameterMetadata* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyStringEx (
            &dst->name, src->name, 
            ((tms_MAXLEN_name)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!RTICdrType_copyStringEx (
            &dst->units, src->units, 
            ((tms_MAXLEN_units)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->nominalMinValue, &src->nominalMinValue)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->nominalMaxValue, &src->nominalMaxValue)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->hardMinValue, &src->hardMinValue)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->hardMaxValue, &src->hardMaxValue)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->resolution, &src->resolution)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ParameterMetadata' sequence class.
*/
#define T tms_ParameterMetadata
#define TSeq tms_ParameterMetadataSeq

#define T_initialize_w_params tms_ParameterMetadata_initialize_w_params

#define T_finalize_w_params   tms_ParameterMetadata_finalize_w_params
#define T_copy       tms_ParameterMetadata_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ParameterValueTYPENAME = "tms::ParameterValue";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ParameterValue_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_ParameterValue_g_tc_name_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_name)));

    static DDS_TypeCode_Member tms_ParameterValue_g_tc_members[2]=
    {

        {
            (char *)"name",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"value",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ParameterValue_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ParameterValue", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_ParameterValue_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ParameterValue*/

    if (is_initialized) {
        return &tms_ParameterValue_g_tc;
    }

    tms_ParameterValue_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ParameterValue_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&tms_ParameterValue_g_tc_name_string;
    tms_ParameterValue_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */
    tms_ParameterValue_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ParameterValue_g_tc_members[0]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ParameterValue_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterValue_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ParameterValue_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterValue_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ParameterValue_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ParameterValue_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ParameterValue_g_tc._data._sampleAccessInfo =
    tms_ParameterValue_get_sample_access_info();
    tms_ParameterValue_g_tc._data._typePlugin =
    tms_ParameterValue_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ParameterValue_g_tc;
}

#define TSeq tms_ParameterValueSeq
#define T tms_ParameterValue
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ParameterValue_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ParameterValue_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ParameterValueSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ParameterValueSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ParameterValue_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ParameterValue_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ParameterValue *sample;

    static RTIXCdrMemberAccessInfo tms_ParameterValue_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ParameterValue_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ParameterValue_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ParameterValue);
    if (sample == NULL) {
        return NULL;
    }

    tms_ParameterValue_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->name - (char *)sample);

    tms_ParameterValue_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->value - (char *)sample);

    tms_ParameterValue_g_sampleAccessInfo.memberAccessInfos = 
    tms_ParameterValue_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ParameterValue);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ParameterValue_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ParameterValue_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ParameterValue_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ParameterValue_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ParameterValue_get_member_value_pointer;

    tms_ParameterValue_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ParameterValue_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ParameterValue_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ParameterValue_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ParameterValue_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ParameterValue_finalize_w_return,
        NULL
    };

    return &tms_ParameterValue_g_typePlugin;
}
#endif

RTIBool tms_ParameterValue_initialize(
    tms_ParameterValue* sample) {
    return tms_ParameterValue_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ParameterValue_initialize_ex(
    tms_ParameterValue* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ParameterValue_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ParameterValue_initialize_w_params(
    tms_ParameterValue* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        sample->name = DDS_String_alloc(((tms_MAXLEN_name)));
        RTICdrType_copyStringEx(
            &sample->name,
            "",
            ((tms_MAXLEN_name)),
            RTI_FALSE);
        if (sample->name == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->name != NULL) {
            RTICdrType_copyStringEx(
                &sample->name,
                "",
                ((tms_MAXLEN_name)),
                RTI_FALSE);
            if (sample->name == NULL) {
                return RTI_FALSE;
            }
        }
    }

    sample->value = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_ParameterValue_finalize_w_return(
    tms_ParameterValue* sample)
{
    tms_ParameterValue_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ParameterValue_finalize(
    tms_ParameterValue* sample)
{

    tms_ParameterValue_finalize_ex(sample,RTI_TRUE);
}

void tms_ParameterValue_finalize_ex(
    tms_ParameterValue* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ParameterValue_finalize_w_params(
        sample,&deallocParams);
}

void tms_ParameterValue_finalize_w_params(
    tms_ParameterValue* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if (sample->name != NULL) {
        DDS_String_free(sample->name);
        sample->name=NULL;

    }

}

void tms_ParameterValue_finalize_optional_members(
    tms_ParameterValue* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ParameterValue_copy(
    tms_ParameterValue* dst,
    const tms_ParameterValue* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyStringEx (
            &dst->name, src->name, 
            ((tms_MAXLEN_name)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->value, &src->value)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ParameterValue' sequence class.
*/
#define T tms_ParameterValue
#define TSeq tms_ParameterValueSeq

#define T_initialize_w_params tms_ParameterValue_initialize_w_params

#define T_finalize_w_params   tms_ParameterValue_finalize_w_params
#define T_copy       tms_ParameterValue_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ConfigId_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_ConfigId_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::ConfigId", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_ConfigId */

    if (is_initialized) {
        return &tms_ConfigId_g_tc;
    }

    tms_ConfigId_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ConfigId_g_tc._data._typeCode =  (RTICdrTypeCode *)&DDS_g_tc_ushort_w_new;

    /* Initialize the values for member annotations. */
    tms_ConfigId_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_ConfigId_g_tc._data._annotations._defaultValue._u.ushort_value = 0;
    tms_ConfigId_g_tc._data._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_ConfigId_g_tc._data._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_ConfigId_g_tc._data._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_ConfigId_g_tc._data._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_ConfigId_g_tc._data._sampleAccessInfo =
    tms_ConfigId_get_sample_access_info();
    tms_ConfigId_g_tc._data._typePlugin =
    tms_ConfigId_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ConfigId_g_tc;
}

#define TSeq tms_ConfigIdSeq
#define T tms_ConfigId
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ConfigId_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ConfigId_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ConfigIdSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ConfigIdSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ConfigId_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ConfigId_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_ConfigId_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ConfigId_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ConfigId_g_sampleAccessInfo;
    }

    tms_ConfigId_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_ConfigId_g_sampleAccessInfo.memberAccessInfos = 
    tms_ConfigId_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ConfigId);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ConfigId_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ConfigId_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ConfigId_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ConfigId_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ConfigId_get_member_value_pointer;

    tms_ConfigId_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ConfigId_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ConfigId_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ConfigId_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ConfigId_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ConfigId_finalize_w_return,
        NULL
    };

    return &tms_ConfigId_g_typePlugin;
}
#endif

RTIBool tms_ConfigId_initialize(
    tms_ConfigId* sample) {
    return tms_ConfigId_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ConfigId_initialize_ex(
    tms_ConfigId* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ConfigId_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ConfigId_initialize_w_params(
    tms_ConfigId* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    (*sample) = 0;

    return RTI_TRUE;
}

RTIBool tms_ConfigId_finalize_w_return(
    tms_ConfigId* sample)
{
    tms_ConfigId_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ConfigId_finalize(
    tms_ConfigId* sample)
{

    tms_ConfigId_finalize_ex(sample,RTI_TRUE);
}

void tms_ConfigId_finalize_ex(
    tms_ConfigId* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ConfigId_finalize_w_params(
        sample,&deallocParams);
}

void tms_ConfigId_finalize_w_params(
    tms_ConfigId* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_ConfigId_finalize_optional_members(
    tms_ConfigId* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ConfigId_copy(
    tms_ConfigId* dst,
    const tms_ConfigId* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedShort (
            dst, src)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ConfigId' sequence class.
*/
#define T tms_ConfigId
#define TSeq tms_ConfigIdSeq

#define T_initialize_w_params tms_ConfigId_initialize_w_params

#define T_finalize_w_params   tms_ConfigId_finalize_w_params
#define T_copy       tms_ConfigId_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceParameterRequestTYPENAME = "tms::DeviceParameterRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceParameterRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DeviceParameterRequest_g_tc_parameters_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_parameters)),NULL);

    static DDS_TypeCode_Member tms_DeviceParameterRequest_g_tc_members[4]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"parameters",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceParameterRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceParameterRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_DeviceParameterRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceParameterRequest*/

    if (is_initialized) {
        return &tms_DeviceParameterRequest_g_tc;
    }

    tms_DeviceParameterRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DeviceParameterRequest_g_tc_parameters_sequence._data._typeCode = (RTICdrTypeCode *)tms_ParameterValue_get_typecode();
    tms_DeviceParameterRequest_g_tc_parameters_sequence._data._sampleAccessInfo = tms_ParameterValue_get_sample_seq_access_info();
    tms_DeviceParameterRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_DeviceParameterRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DeviceParameterRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_DeviceParameterRequest_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_DeviceParameterRequest_g_tc_parameters_sequence;

    /* Initialize the values for member annotations. */

    tms_DeviceParameterRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_DeviceParameterRequest_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_DeviceParameterRequest_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_DeviceParameterRequest_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_DeviceParameterRequest_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_DeviceParameterRequest_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_DeviceParameterRequest_g_tc._data._sampleAccessInfo =
    tms_DeviceParameterRequest_get_sample_access_info();
    tms_DeviceParameterRequest_g_tc._data._typePlugin =
    tms_DeviceParameterRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceParameterRequest_g_tc;
}

#define TSeq tms_DeviceParameterRequestSeq
#define T tms_DeviceParameterRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceParameterRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceParameterRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceParameterRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceParameterRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceParameterRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceParameterRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DeviceParameterRequest *sample;

    static RTIXCdrMemberAccessInfo tms_DeviceParameterRequest_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceParameterRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceParameterRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DeviceParameterRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_DeviceParameterRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_DeviceParameterRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DeviceParameterRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_DeviceParameterRequest_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->parameters - (char *)sample);

    tms_DeviceParameterRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceParameterRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceParameterRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceParameterRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceParameterRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceParameterRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceParameterRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceParameterRequest_get_member_value_pointer;

    tms_DeviceParameterRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceParameterRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceParameterRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceParameterRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceParameterRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceParameterRequest_finalize_w_return,
        NULL
    };

    return &tms_DeviceParameterRequest_g_typePlugin;
}
#endif

RTIBool tms_DeviceParameterRequest_initialize(
    tms_DeviceParameterRequest* sample) {
    return tms_DeviceParameterRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DeviceParameterRequest_initialize_ex(
    tms_DeviceParameterRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceParameterRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceParameterRequest_initialize_w_params(
    tms_DeviceParameterRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    if (allocParams->allocate_memory) {
        if(!tms_ParameterValueSeq_initialize(&sample->parameters )){
            return RTI_FALSE;
        };
        if(!tms_ParameterValueSeq_set_element_allocation_params(&sample->parameters ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_ParameterValueSeq_set_absolute_maximum(&sample->parameters , ((tms_MAXLEN_parameters)))){
            return RTI_FALSE;
        }
        if (!tms_ParameterValueSeq_set_maximum(&sample->parameters, ((tms_MAXLEN_parameters)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_ParameterValueSeq_set_length(&sample->parameters, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DeviceParameterRequest_finalize_w_return(
    tms_DeviceParameterRequest* sample)
{
    tms_DeviceParameterRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DeviceParameterRequest_finalize(
    tms_DeviceParameterRequest* sample)
{

    tms_DeviceParameterRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_DeviceParameterRequest_finalize_ex(
    tms_DeviceParameterRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceParameterRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceParameterRequest_finalize_w_params(
    tms_DeviceParameterRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_ParameterValueSeq_set_element_deallocation_params(
        &sample->parameters,deallocParams)){
        return; 
    }
    if(!tms_ParameterValueSeq_finalize(&sample->parameters)){
        return;
    }

}

void tms_DeviceParameterRequest_finalize_optional_members(
    tms_DeviceParameterRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceParameterRequest_copy(
    tms_DeviceParameterRequest* dst,
    const tms_DeviceParameterRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!tms_ParameterValueSeq_copy(&dst->parameters ,
        &src->parameters )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceParameterRequest' sequence class.
*/
#define T tms_DeviceParameterRequest
#define TSeq tms_DeviceParameterRequestSeq

#define T_initialize_w_params tms_DeviceParameterRequest_initialize_w_params

#define T_finalize_w_params   tms_DeviceParameterRequest_finalize_w_params
#define T_copy       tms_DeviceParameterRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceParameterStatusTYPENAME = "tms::DeviceParameterStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceParameterStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DeviceParameterStatus_g_tc_parameters_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_parameters)),NULL);

    static DDS_TypeCode_Member tms_DeviceParameterStatus_g_tc_members[3]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"parameters",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceParameterStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceParameterStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_DeviceParameterStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceParameterStatus*/

    if (is_initialized) {
        return &tms_DeviceParameterStatus_g_tc;
    }

    tms_DeviceParameterStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DeviceParameterStatus_g_tc_parameters_sequence._data._typeCode = (RTICdrTypeCode *)tms_ParameterValue_get_typecode();
    tms_DeviceParameterStatus_g_tc_parameters_sequence._data._sampleAccessInfo = tms_ParameterValue_get_sample_seq_access_info();
    tms_DeviceParameterStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DeviceParameterStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_DeviceParameterStatus_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)& tms_DeviceParameterStatus_g_tc_parameters_sequence;

    /* Initialize the values for member annotations. */

    tms_DeviceParameterStatus_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_DeviceParameterStatus_g_tc_members[1]._annotations._defaultValue._u.ushort_value = 0;
    tms_DeviceParameterStatus_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_DeviceParameterStatus_g_tc_members[1]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_DeviceParameterStatus_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_DeviceParameterStatus_g_tc_members[1]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_DeviceParameterStatus_g_tc._data._sampleAccessInfo =
    tms_DeviceParameterStatus_get_sample_access_info();
    tms_DeviceParameterStatus_g_tc._data._typePlugin =
    tms_DeviceParameterStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceParameterStatus_g_tc;
}

#define TSeq tms_DeviceParameterStatusSeq
#define T tms_DeviceParameterStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceParameterStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceParameterStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceParameterStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceParameterStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceParameterStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceParameterStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DeviceParameterStatus *sample;

    static RTIXCdrMemberAccessInfo tms_DeviceParameterStatus_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceParameterStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceParameterStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DeviceParameterStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_DeviceParameterStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DeviceParameterStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_DeviceParameterStatus_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->parameters - (char *)sample);

    tms_DeviceParameterStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceParameterStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceParameterStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceParameterStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceParameterStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceParameterStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceParameterStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceParameterStatus_get_member_value_pointer;

    tms_DeviceParameterStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceParameterStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceParameterStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceParameterStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceParameterStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceParameterStatus_finalize_w_return,
        NULL
    };

    return &tms_DeviceParameterStatus_g_typePlugin;
}
#endif

RTIBool tms_DeviceParameterStatus_initialize(
    tms_DeviceParameterStatus* sample) {
    return tms_DeviceParameterStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DeviceParameterStatus_initialize_ex(
    tms_DeviceParameterStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceParameterStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceParameterStatus_initialize_w_params(
    tms_DeviceParameterStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    if (allocParams->allocate_memory) {
        if(!tms_ParameterValueSeq_initialize(&sample->parameters )){
            return RTI_FALSE;
        };
        if(!tms_ParameterValueSeq_set_element_allocation_params(&sample->parameters ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_ParameterValueSeq_set_absolute_maximum(&sample->parameters , ((tms_MAXLEN_parameters)))){
            return RTI_FALSE;
        }
        if (!tms_ParameterValueSeq_set_maximum(&sample->parameters, ((tms_MAXLEN_parameters)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_ParameterValueSeq_set_length(&sample->parameters, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DeviceParameterStatus_finalize_w_return(
    tms_DeviceParameterStatus* sample)
{
    tms_DeviceParameterStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DeviceParameterStatus_finalize(
    tms_DeviceParameterStatus* sample)
{

    tms_DeviceParameterStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_DeviceParameterStatus_finalize_ex(
    tms_DeviceParameterStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceParameterStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceParameterStatus_finalize_w_params(
    tms_DeviceParameterStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_ParameterValueSeq_set_element_deallocation_params(
        &sample->parameters,deallocParams)){
        return; 
    }
    if(!tms_ParameterValueSeq_finalize(&sample->parameters)){
        return;
    }

}

void tms_DeviceParameterStatus_finalize_optional_members(
    tms_DeviceParameterStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceParameterStatus_copy(
    tms_DeviceParameterStatus* dst,
    const tms_DeviceParameterStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!tms_ParameterValueSeq_copy(&dst->parameters ,
        &src->parameters )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceParameterStatus' sequence class.
*/
#define T tms_DeviceParameterStatus
#define TSeq tms_DeviceParameterStatusSeq

#define T_initialize_w_params tms_DeviceParameterStatus_initialize_w_params

#define T_finalize_w_params   tms_DeviceParameterStatus_finalize_w_params
#define T_copy       tms_DeviceParameterStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceRoleTYPENAME = "tms::DeviceRole";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceRole_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_DeviceRole_g_tc_members[8]=
    {

        {
            (char *)"ROLE_MICROGRID_CONTROLLER",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_MICROGRID_CONTROLLER, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ROLE_TIME_CONTROLLER",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_TIME_CONTROLLER, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ROLE_SOURCE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_SOURCE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ROLE_LOAD",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_LOAD, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ROLE_STORAGE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_STORAGE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ROLE_DISTRIBUTION",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_DISTRIBUTION, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ROLE_MICROGRID_SYSTEM_MANAGER",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_MICROGRID_SYSTEM_MANAGER, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ROLE_CONVERSION",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ROLE_CONVERSION, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceRole_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceRole", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            8, /* Number of members */
            tms_DeviceRole_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceRole*/

    if (is_initialized) {
        return &tms_DeviceRole_g_tc;
    }

    tms_DeviceRole_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_DeviceRole_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_DeviceRole_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_DeviceRole_g_tc._data._sampleAccessInfo =
    tms_DeviceRole_get_sample_access_info();
    tms_DeviceRole_g_tc._data._typePlugin =
    tms_DeviceRole_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceRole_g_tc;
}

#define TSeq tms_DeviceRoleSeq
#define T tms_DeviceRole
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceRole_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceRole_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceRoleSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceRoleSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceRole_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceRole_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_DeviceRole_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceRole_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceRole_g_sampleAccessInfo;
    }

    tms_DeviceRole_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_DeviceRole_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceRole_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceRole);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceRole_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceRole_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceRole_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceRole_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceRole_get_member_value_pointer;

    tms_DeviceRole_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceRole_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceRole_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceRole_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceRole_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceRole_finalize_w_return,
        NULL
    };

    return &tms_DeviceRole_g_typePlugin;
}
#endif

RTIBool tms_DeviceRole_initialize(
    tms_DeviceRole* sample) {
    *sample = ROLE_MICROGRID_CONTROLLER;
    return RTI_TRUE;
}

RTIBool tms_DeviceRole_initialize_ex(
    tms_DeviceRole* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceRole_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceRole_initialize_w_params(
    tms_DeviceRole* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = ROLE_MICROGRID_CONTROLLER;
    return RTI_TRUE;
}

RTIBool tms_DeviceRole_finalize_w_return(
    tms_DeviceRole* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_DeviceRole_finalize(
    tms_DeviceRole* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_DeviceRole_finalize_ex(
    tms_DeviceRole* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceRole_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceRole_finalize_w_params(
    tms_DeviceRole* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_DeviceRole_finalize_optional_members(
    tms_DeviceRole* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceRole_copy(
    tms_DeviceRole* dst,
    const tms_DeviceRole* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceRole' sequence class.
*/
#define T tms_DeviceRole
#define TSeq tms_DeviceRoleSeq

#define T_initialize_w_params tms_DeviceRole_initialize_w_params

#define T_finalize_w_params   tms_DeviceRole_finalize_w_params
#define T_copy       tms_DeviceRole_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_NatoStockNumber_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_NatoStockNumber_g_tc_array =DDS_INITIALIZE_ARRAY_TYPECODE(1,(tms_LEN_NatoStockNumber), NULL,NULL);

    static DDS_TypeCode tms_NatoStockNumber_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::NatoStockNumber", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_NatoStockNumber */

    if (is_initialized) {
        return &tms_NatoStockNumber_g_tc;
    }

    tms_NatoStockNumber_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_NatoStockNumber_g_tc_array._data._typeCode =(RTICdrTypeCode *)&DDS_g_tc_char_w_new;
    tms_NatoStockNumber_g_tc._data._typeCode =  (RTICdrTypeCode *)& tms_NatoStockNumber_g_tc_array;

    /* Initialize the values for member annotations. */

    tms_NatoStockNumber_g_tc._data._sampleAccessInfo =
    tms_NatoStockNumber_get_sample_access_info();
    tms_NatoStockNumber_g_tc._data._typePlugin =
    tms_NatoStockNumber_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_NatoStockNumber_g_tc;
}

#define ALIAS_OF_ARRAY

#define TSeq tms_NatoStockNumberSeq
#define T tms_NatoStockNumber
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

#undef ALIAS_OF_ARRAY

RTIXCdrSampleAccessInfo *tms_NatoStockNumber_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_NatoStockNumber_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_NatoStockNumberSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_NatoStockNumberSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_NatoStockNumber_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_NatoStockNumber_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_NatoStockNumber_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_NatoStockNumber_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_NatoStockNumber_g_sampleAccessInfo;
    }

    tms_NatoStockNumber_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_NatoStockNumber_g_sampleAccessInfo.memberAccessInfos = 
    tms_NatoStockNumber_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_NatoStockNumber);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_NatoStockNumber_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_NatoStockNumber_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_NatoStockNumber_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_NatoStockNumber_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_NatoStockNumber_get_member_value_pointer;

    tms_NatoStockNumber_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_NatoStockNumber_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_NatoStockNumber_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_NatoStockNumber_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_NatoStockNumber_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_NatoStockNumber_finalize_w_return,
        NULL
    };

    return &tms_NatoStockNumber_g_typePlugin;
}
#endif

RTIBool tms_NatoStockNumber_initialize(
    tms_NatoStockNumber* sample) {
    return tms_NatoStockNumber_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_NatoStockNumber_initialize_ex(
    tms_NatoStockNumber* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_NatoStockNumber_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_NatoStockNumber_initialize_w_params(
    tms_NatoStockNumber* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!RTICdrType_initArray(
        (*sample), ((tms_LEN_NatoStockNumber)), RTI_CDR_CHAR_SIZE)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_NatoStockNumber_finalize_w_return(
    tms_NatoStockNumber* sample)
{
    tms_NatoStockNumber_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_NatoStockNumber_finalize(
    tms_NatoStockNumber* sample)
{

    tms_NatoStockNumber_finalize_ex(sample,RTI_TRUE);
}

void tms_NatoStockNumber_finalize_ex(
    tms_NatoStockNumber* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_NatoStockNumber_finalize_w_params(
        sample,&deallocParams);
}

void tms_NatoStockNumber_finalize_w_params(
    tms_NatoStockNumber* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_NatoStockNumber_finalize_optional_members(
    tms_NatoStockNumber* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_NatoStockNumber_copy(
    tms_NatoStockNumber* dst,
    const tms_NatoStockNumber* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyArray(
            (*dst) ,(*src),((tms_LEN_NatoStockNumber)), RTI_CDR_CHAR_SIZE)) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_NatoStockNumber' sequence class.
*/
#define T tms_NatoStockNumber
#define TSeq tms_NatoStockNumberSeq

#define T_initialize_w_params tms_NatoStockNumber_initialize_w_params

#define T_finalize_w_params   tms_NatoStockNumber_finalize_w_params
#define T_copy       tms_NatoStockNumber_copy

#define T_no_get  
#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_no_get  

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GlobalTradeItemNumber_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_GlobalTradeItemNumber_g_tc_array =DDS_INITIALIZE_ARRAY_TYPECODE(1,(tms_LEN_GlobalTradeItemNumber), NULL,NULL);

    static DDS_TypeCode tms_GlobalTradeItemNumber_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::GlobalTradeItemNumber", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_GlobalTradeItemNumber */

    if (is_initialized) {
        return &tms_GlobalTradeItemNumber_g_tc;
    }

    tms_GlobalTradeItemNumber_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_GlobalTradeItemNumber_g_tc_array._data._typeCode =(RTICdrTypeCode *)&DDS_g_tc_char_w_new;
    tms_GlobalTradeItemNumber_g_tc._data._typeCode =  (RTICdrTypeCode *)& tms_GlobalTradeItemNumber_g_tc_array;

    /* Initialize the values for member annotations. */

    tms_GlobalTradeItemNumber_g_tc._data._sampleAccessInfo =
    tms_GlobalTradeItemNumber_get_sample_access_info();
    tms_GlobalTradeItemNumber_g_tc._data._typePlugin =
    tms_GlobalTradeItemNumber_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GlobalTradeItemNumber_g_tc;
}

#define ALIAS_OF_ARRAY

#define TSeq tms_GlobalTradeItemNumberSeq
#define T tms_GlobalTradeItemNumber
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

#undef ALIAS_OF_ARRAY

RTIXCdrSampleAccessInfo *tms_GlobalTradeItemNumber_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GlobalTradeItemNumber_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GlobalTradeItemNumberSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GlobalTradeItemNumberSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GlobalTradeItemNumber_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GlobalTradeItemNumber_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_GlobalTradeItemNumber_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GlobalTradeItemNumber_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GlobalTradeItemNumber_g_sampleAccessInfo;
    }

    tms_GlobalTradeItemNumber_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_GlobalTradeItemNumber_g_sampleAccessInfo.memberAccessInfos = 
    tms_GlobalTradeItemNumber_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GlobalTradeItemNumber);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GlobalTradeItemNumber_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GlobalTradeItemNumber_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GlobalTradeItemNumber_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GlobalTradeItemNumber_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GlobalTradeItemNumber_get_member_value_pointer;

    tms_GlobalTradeItemNumber_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GlobalTradeItemNumber_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GlobalTradeItemNumber_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GlobalTradeItemNumber_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GlobalTradeItemNumber_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GlobalTradeItemNumber_finalize_w_return,
        NULL
    };

    return &tms_GlobalTradeItemNumber_g_typePlugin;
}
#endif

RTIBool tms_GlobalTradeItemNumber_initialize(
    tms_GlobalTradeItemNumber* sample) {
    return tms_GlobalTradeItemNumber_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_GlobalTradeItemNumber_initialize_ex(
    tms_GlobalTradeItemNumber* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GlobalTradeItemNumber_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GlobalTradeItemNumber_initialize_w_params(
    tms_GlobalTradeItemNumber* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!RTICdrType_initArray(
        (*sample), ((tms_LEN_GlobalTradeItemNumber)), RTI_CDR_CHAR_SIZE)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_GlobalTradeItemNumber_finalize_w_return(
    tms_GlobalTradeItemNumber* sample)
{
    tms_GlobalTradeItemNumber_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_GlobalTradeItemNumber_finalize(
    tms_GlobalTradeItemNumber* sample)
{

    tms_GlobalTradeItemNumber_finalize_ex(sample,RTI_TRUE);
}

void tms_GlobalTradeItemNumber_finalize_ex(
    tms_GlobalTradeItemNumber* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GlobalTradeItemNumber_finalize_w_params(
        sample,&deallocParams);
}

void tms_GlobalTradeItemNumber_finalize_w_params(
    tms_GlobalTradeItemNumber* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_GlobalTradeItemNumber_finalize_optional_members(
    tms_GlobalTradeItemNumber* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GlobalTradeItemNumber_copy(
    tms_GlobalTradeItemNumber* dst,
    const tms_GlobalTradeItemNumber* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyArray(
            (*dst) ,(*src),((tms_LEN_GlobalTradeItemNumber)), RTI_CDR_CHAR_SIZE)) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GlobalTradeItemNumber' sequence class.
*/
#define T tms_GlobalTradeItemNumber
#define TSeq tms_GlobalTradeItemNumberSeq

#define T_initialize_w_params tms_GlobalTradeItemNumber_initialize_w_params

#define T_finalize_w_params   tms_GlobalTradeItemNumber_finalize_w_params
#define T_copy       tms_GlobalTradeItemNumber_copy

#define T_no_get  
#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_no_get  

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DistributionInfoTYPENAME = "tms::DistributionInfo";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DistributionInfo_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_DistributionInfo_g_tc_members[2]=
    {

        {
            (char *)"supportsLoadPolicy",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"supportsAuthorizationToEnergize",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DistributionInfo_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DistributionInfo", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_DistributionInfo_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DistributionInfo*/

    if (is_initialized) {
        return &tms_DistributionInfo_g_tc;
    }

    tms_DistributionInfo_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DistributionInfo_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_DistributionInfo_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;

    /* Initialize the values for member annotations. */
    tms_DistributionInfo_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_DistributionInfo_g_tc_members[0]._annotations._defaultValue._u.boolean_value = 0;

    tms_DistributionInfo_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_DistributionInfo_g_tc_members[1]._annotations._defaultValue._u.boolean_value = 0;

    tms_DistributionInfo_g_tc._data._sampleAccessInfo =
    tms_DistributionInfo_get_sample_access_info();
    tms_DistributionInfo_g_tc._data._typePlugin =
    tms_DistributionInfo_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DistributionInfo_g_tc;
}

#define TSeq tms_DistributionInfoSeq
#define T tms_DistributionInfo
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DistributionInfo_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DistributionInfo_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DistributionInfoSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DistributionInfoSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DistributionInfo_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DistributionInfo_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DistributionInfo *sample;

    static RTIXCdrMemberAccessInfo tms_DistributionInfo_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DistributionInfo_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DistributionInfo_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DistributionInfo);
    if (sample == NULL) {
        return NULL;
    }

    tms_DistributionInfo_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsLoadPolicy - (char *)sample);

    tms_DistributionInfo_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsAuthorizationToEnergize - (char *)sample);

    tms_DistributionInfo_g_sampleAccessInfo.memberAccessInfos = 
    tms_DistributionInfo_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DistributionInfo);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DistributionInfo_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DistributionInfo_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DistributionInfo_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DistributionInfo_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DistributionInfo_get_member_value_pointer;

    tms_DistributionInfo_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DistributionInfo_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DistributionInfo_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DistributionInfo_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DistributionInfo_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DistributionInfo_finalize_w_return,
        NULL
    };

    return &tms_DistributionInfo_g_typePlugin;
}
#endif

RTIBool tms_DistributionInfo_initialize(
    tms_DistributionInfo* sample) {
    return tms_DistributionInfo_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DistributionInfo_initialize_ex(
    tms_DistributionInfo* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DistributionInfo_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DistributionInfo_initialize_w_params(
    tms_DistributionInfo* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->supportsLoadPolicy = 0;

    sample->supportsAuthorizationToEnergize = 0;

    return RTI_TRUE;
}

RTIBool tms_DistributionInfo_finalize_w_return(
    tms_DistributionInfo* sample)
{
    tms_DistributionInfo_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DistributionInfo_finalize(
    tms_DistributionInfo* sample)
{

    tms_DistributionInfo_finalize_ex(sample,RTI_TRUE);
}

void tms_DistributionInfo_finalize_ex(
    tms_DistributionInfo* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DistributionInfo_finalize_w_params(
        sample,&deallocParams);
}

void tms_DistributionInfo_finalize_w_params(
    tms_DistributionInfo* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_DistributionInfo_finalize_optional_members(
    tms_DistributionInfo* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DistributionInfo_copy(
    tms_DistributionInfo* dst,
    const tms_DistributionInfo* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyBoolean (
            &dst->supportsLoadPolicy, &src->supportsLoadPolicy)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->supportsAuthorizationToEnergize, &src->supportsAuthorizationToEnergize)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DistributionInfo' sequence class.
*/
#define T tms_DistributionInfo
#define TSeq tms_DistributionInfoSeq

#define T_initialize_w_params tms_DistributionInfo_initialize_w_params

#define T_finalize_w_params   tms_DistributionInfo_finalize_w_params
#define T_copy       tms_DistributionInfo_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadInfoTYPENAME = "tms::LoadInfo";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadInfo_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_LoadInfo_g_tc_parameters_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_parameters)),NULL);

    static DDS_TypeCode_Member tms_LoadInfo_g_tc_members[5]=
    {

        {
            (char *)"parameters",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"supportsLoadChange",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"loadChangeThreshold",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"loadEstimateDeadband",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"supportsLoadPolicy",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadInfo_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadInfo", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_LoadInfo_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadInfo*/

    if (is_initialized) {
        return &tms_LoadInfo_g_tc;
    }

    tms_LoadInfo_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadInfo_g_tc_parameters_sequence._data._typeCode = (RTICdrTypeCode *)tms_ParameterMetadata_get_typecode();
    tms_LoadInfo_g_tc_parameters_sequence._data._sampleAccessInfo = tms_ParameterMetadata_get_sample_seq_access_info();
    tms_LoadInfo_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)& tms_LoadInfo_g_tc_parameters_sequence;
    tms_LoadInfo_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_LoadInfo_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadInfo_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadInfo_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;

    /* Initialize the values for member annotations. */

    tms_LoadInfo_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_LoadInfo_g_tc_members[1]._annotations._defaultValue._u.boolean_value = 0;

    tms_LoadInfo_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadInfo_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadInfo_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadInfo_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadInfo_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadInfo_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadInfo_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadInfo_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadInfo_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadInfo_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadInfo_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadInfo_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadInfo_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_LoadInfo_g_tc_members[4]._annotations._defaultValue._u.boolean_value = 0;

    tms_LoadInfo_g_tc._data._sampleAccessInfo =
    tms_LoadInfo_get_sample_access_info();
    tms_LoadInfo_g_tc._data._typePlugin =
    tms_LoadInfo_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadInfo_g_tc;
}

#define TSeq tms_LoadInfoSeq
#define T tms_LoadInfo
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadInfo_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadInfo_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadInfoSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadInfoSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadInfo_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadInfo_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadInfo *sample;

    static RTIXCdrMemberAccessInfo tms_LoadInfo_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadInfo_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadInfo_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadInfo);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadInfo_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->parameters - (char *)sample);

    tms_LoadInfo_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsLoadChange - (char *)sample);

    tms_LoadInfo_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->loadChangeThreshold - (char *)sample);

    tms_LoadInfo_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->loadEstimateDeadband - (char *)sample);

    tms_LoadInfo_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsLoadPolicy - (char *)sample);

    tms_LoadInfo_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadInfo_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadInfo);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadInfo_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadInfo_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadInfo_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadInfo_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadInfo_get_member_value_pointer;

    tms_LoadInfo_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadInfo_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadInfo_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadInfo_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadInfo_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadInfo_finalize_w_return,
        NULL
    };

    return &tms_LoadInfo_g_typePlugin;
}
#endif

RTIBool tms_LoadInfo_initialize(
    tms_LoadInfo* sample) {
    return tms_LoadInfo_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadInfo_initialize_ex(
    tms_LoadInfo* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadInfo_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadInfo_initialize_w_params(
    tms_LoadInfo* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        if(!tms_ParameterMetadataSeq_initialize(&sample->parameters )){
            return RTI_FALSE;
        };
        if(!tms_ParameterMetadataSeq_set_element_allocation_params(&sample->parameters ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_ParameterMetadataSeq_set_absolute_maximum(&sample->parameters , ((tms_MAXLEN_parameters)))){
            return RTI_FALSE;
        }
        if (!tms_ParameterMetadataSeq_set_maximum(&sample->parameters, ((tms_MAXLEN_parameters)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_ParameterMetadataSeq_set_length(&sample->parameters, 0)){
            return RTI_FALSE;
        }    
    }

    sample->supportsLoadChange = 0;

    sample->loadChangeThreshold = 0.0f;

    sample->loadEstimateDeadband = 0.0f;

    sample->supportsLoadPolicy = 0;

    return RTI_TRUE;
}

RTIBool tms_LoadInfo_finalize_w_return(
    tms_LoadInfo* sample)
{
    tms_LoadInfo_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadInfo_finalize(
    tms_LoadInfo* sample)
{

    tms_LoadInfo_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadInfo_finalize_ex(
    tms_LoadInfo* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadInfo_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadInfo_finalize_w_params(
    tms_LoadInfo* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!tms_ParameterMetadataSeq_set_element_deallocation_params(
        &sample->parameters,deallocParams)){
        return; 
    }
    if(!tms_ParameterMetadataSeq_finalize(&sample->parameters)){
        return;
    }

}

void tms_LoadInfo_finalize_optional_members(
    tms_LoadInfo* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadInfo_copy(
    tms_LoadInfo* dst,
    const tms_LoadInfo* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_ParameterMetadataSeq_copy(&dst->parameters ,
        &src->parameters )) {
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->supportsLoadChange, &src->supportsLoadChange)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->loadChangeThreshold, &src->loadChangeThreshold)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->loadEstimateDeadband, &src->loadEstimateDeadband)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->supportsLoadPolicy, &src->supportsLoadPolicy)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadInfo' sequence class.
*/
#define T tms_LoadInfo
#define TSeq tms_LoadInfoSeq

#define T_initialize_w_params tms_LoadInfo_initialize_w_params

#define T_finalize_w_params   tms_LoadInfo_finalize_w_params
#define T_copy       tms_LoadInfo_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_EngineStateThresholdsTYPENAME = "tms::EngineStateThresholds";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_EngineStateThresholds_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_EngineStateThresholds_g_tc_members[4]=
    {

        {
            (char *)"lowOilPressure",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"highOilPressure",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"lowCoolantTemperature",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"highCoolantTemperature",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_EngineStateThresholds_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::EngineStateThresholds", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_EngineStateThresholds_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_EngineStateThresholds*/

    if (is_initialized) {
        return &tms_EngineStateThresholds_g_tc;
    }

    tms_EngineStateThresholds_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_EngineStateThresholds_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_EngineStateThresholds_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_EngineStateThresholds_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_EngineStateThresholds_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */
    tms_EngineStateThresholds_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[0]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineStateThresholds_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[0]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineStateThresholds_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[0]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineStateThresholds_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineStateThresholds_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineStateThresholds_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineStateThresholds_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineStateThresholds_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineStateThresholds_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineStateThresholds_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineStateThresholds_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineStateThresholds_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineStateThresholds_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineStateThresholds_g_tc._data._sampleAccessInfo =
    tms_EngineStateThresholds_get_sample_access_info();
    tms_EngineStateThresholds_g_tc._data._typePlugin =
    tms_EngineStateThresholds_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_EngineStateThresholds_g_tc;
}

#define TSeq tms_EngineStateThresholdsSeq
#define T tms_EngineStateThresholds
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_EngineStateThresholds_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_EngineStateThresholds_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_EngineStateThresholdsSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_EngineStateThresholdsSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_EngineStateThresholds_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_EngineStateThresholds_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_EngineStateThresholds *sample;

    static RTIXCdrMemberAccessInfo tms_EngineStateThresholds_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_EngineStateThresholds_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_EngineStateThresholds_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_EngineStateThresholds);
    if (sample == NULL) {
        return NULL;
    }

    tms_EngineStateThresholds_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->lowOilPressure - (char *)sample);

    tms_EngineStateThresholds_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->highOilPressure - (char *)sample);

    tms_EngineStateThresholds_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->lowCoolantTemperature - (char *)sample);

    tms_EngineStateThresholds_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->highCoolantTemperature - (char *)sample);

    tms_EngineStateThresholds_g_sampleAccessInfo.memberAccessInfos = 
    tms_EngineStateThresholds_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_EngineStateThresholds);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_EngineStateThresholds_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_EngineStateThresholds_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_EngineStateThresholds_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_EngineStateThresholds_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_EngineStateThresholds_get_member_value_pointer;

    tms_EngineStateThresholds_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_EngineStateThresholds_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_EngineStateThresholds_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_EngineStateThresholds_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_EngineStateThresholds_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_EngineStateThresholds_finalize_w_return,
        NULL
    };

    return &tms_EngineStateThresholds_g_typePlugin;
}
#endif

RTIBool tms_EngineStateThresholds_initialize(
    tms_EngineStateThresholds* sample) {
    return tms_EngineStateThresholds_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_EngineStateThresholds_initialize_ex(
    tms_EngineStateThresholds* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_EngineStateThresholds_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_EngineStateThresholds_initialize_w_params(
    tms_EngineStateThresholds* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->lowOilPressure = 0.0f;

    sample->highOilPressure = 0.0f;

    sample->lowCoolantTemperature = 0.0f;

    sample->highCoolantTemperature = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_EngineStateThresholds_finalize_w_return(
    tms_EngineStateThresholds* sample)
{
    tms_EngineStateThresholds_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_EngineStateThresholds_finalize(
    tms_EngineStateThresholds* sample)
{

    tms_EngineStateThresholds_finalize_ex(sample,RTI_TRUE);
}

void tms_EngineStateThresholds_finalize_ex(
    tms_EngineStateThresholds* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_EngineStateThresholds_finalize_w_params(
        sample,&deallocParams);
}

void tms_EngineStateThresholds_finalize_w_params(
    tms_EngineStateThresholds* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_EngineStateThresholds_finalize_optional_members(
    tms_EngineStateThresholds* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_EngineStateThresholds_copy(
    tms_EngineStateThresholds* dst,
    const tms_EngineStateThresholds* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyFloat (
            &dst->lowOilPressure, &src->lowOilPressure)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->highOilPressure, &src->highOilPressure)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->lowCoolantTemperature, &src->lowCoolantTemperature)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->highCoolantTemperature, &src->highCoolantTemperature)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_EngineStateThresholds' sequence class.
*/
#define T tms_EngineStateThresholds
#define TSeq tms_EngineStateThresholdsSeq

#define T_initialize_w_params tms_EngineStateThresholds_initialize_w_params

#define T_finalize_w_params   tms_EngineStateThresholds_finalize_w_params
#define T_copy       tms_EngineStateThresholds_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_SourceInfoTYPENAME = "tms::SourceInfo";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SourceInfo_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_SourceInfo_g_tc_parameters_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_parameters)),NULL);
    static DDS_TypeCode tms_SourceInfo_g_tc_engine_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_engine)),NULL);

    static DDS_TypeCode_Member tms_SourceInfo_g_tc_members[6]=
    {

        {
            (char *)"parameters",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"supportsDroopCurve",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"supportsNonlinearCurve",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"supportsDigitalLoadShare",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"supportsAuthorizationToEnergize",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"engine",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_SourceInfo_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::SourceInfo", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_SourceInfo_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_SourceInfo*/

    if (is_initialized) {
        return &tms_SourceInfo_g_tc;
    }

    tms_SourceInfo_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_SourceInfo_g_tc_parameters_sequence._data._typeCode = (RTICdrTypeCode *)tms_ParameterMetadata_get_typecode();
    tms_SourceInfo_g_tc_parameters_sequence._data._sampleAccessInfo = tms_ParameterMetadata_get_sample_seq_access_info();
    tms_SourceInfo_g_tc_engine_sequence._data._typeCode = (RTICdrTypeCode *)tms_EngineStateThresholds_get_typecode();
    tms_SourceInfo_g_tc_engine_sequence._data._sampleAccessInfo = tms_EngineStateThresholds_get_sample_seq_access_info();
    tms_SourceInfo_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)& tms_SourceInfo_g_tc_parameters_sequence;
    tms_SourceInfo_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_SourceInfo_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_SourceInfo_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_SourceInfo_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_SourceInfo_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)& tms_SourceInfo_g_tc_engine_sequence;

    /* Initialize the values for member annotations. */

    tms_SourceInfo_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_SourceInfo_g_tc_members[1]._annotations._defaultValue._u.boolean_value = 0;

    tms_SourceInfo_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_SourceInfo_g_tc_members[2]._annotations._defaultValue._u.boolean_value = 0;

    tms_SourceInfo_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_SourceInfo_g_tc_members[3]._annotations._defaultValue._u.boolean_value = 0;

    tms_SourceInfo_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_SourceInfo_g_tc_members[4]._annotations._defaultValue._u.boolean_value = 0;

    tms_SourceInfo_g_tc._data._sampleAccessInfo =
    tms_SourceInfo_get_sample_access_info();
    tms_SourceInfo_g_tc._data._typePlugin =
    tms_SourceInfo_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SourceInfo_g_tc;
}

#define TSeq tms_SourceInfoSeq
#define T tms_SourceInfo
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SourceInfo_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SourceInfo_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SourceInfoSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SourceInfoSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SourceInfo_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SourceInfo_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_SourceInfo *sample;

    static RTIXCdrMemberAccessInfo tms_SourceInfo_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SourceInfo_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SourceInfo_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_SourceInfo);
    if (sample == NULL) {
        return NULL;
    }

    tms_SourceInfo_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->parameters - (char *)sample);

    tms_SourceInfo_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsDroopCurve - (char *)sample);

    tms_SourceInfo_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsNonlinearCurve - (char *)sample);

    tms_SourceInfo_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsDigitalLoadShare - (char *)sample);

    tms_SourceInfo_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->supportsAuthorizationToEnergize - (char *)sample);

    tms_SourceInfo_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->engine - (char *)sample);

    tms_SourceInfo_g_sampleAccessInfo.memberAccessInfos = 
    tms_SourceInfo_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SourceInfo);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SourceInfo_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SourceInfo_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SourceInfo_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SourceInfo_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SourceInfo_get_member_value_pointer;

    tms_SourceInfo_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SourceInfo_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SourceInfo_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SourceInfo_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SourceInfo_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SourceInfo_finalize_w_return,
        NULL
    };

    return &tms_SourceInfo_g_typePlugin;
}
#endif

RTIBool tms_SourceInfo_initialize(
    tms_SourceInfo* sample) {
    return tms_SourceInfo_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_SourceInfo_initialize_ex(
    tms_SourceInfo* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SourceInfo_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SourceInfo_initialize_w_params(
    tms_SourceInfo* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        if(!tms_ParameterMetadataSeq_initialize(&sample->parameters )){
            return RTI_FALSE;
        };
        if(!tms_ParameterMetadataSeq_set_element_allocation_params(&sample->parameters ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_ParameterMetadataSeq_set_absolute_maximum(&sample->parameters , ((tms_MAXLEN_parameters)))){
            return RTI_FALSE;
        }
        if (!tms_ParameterMetadataSeq_set_maximum(&sample->parameters, ((tms_MAXLEN_parameters)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_ParameterMetadataSeq_set_length(&sample->parameters, 0)){
            return RTI_FALSE;
        }    
    }

    sample->supportsDroopCurve = 0;

    sample->supportsNonlinearCurve = 0;

    sample->supportsDigitalLoadShare = 0;

    sample->supportsAuthorizationToEnergize = 0;

    if (allocParams->allocate_memory) {
        if(!tms_EngineStateThresholdsSeq_initialize(&sample->engine )){
            return RTI_FALSE;
        };
        if(!tms_EngineStateThresholdsSeq_set_element_allocation_params(&sample->engine ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_EngineStateThresholdsSeq_set_absolute_maximum(&sample->engine , ((tms_MAXLEN_engine)))){
            return RTI_FALSE;
        }
        if (!tms_EngineStateThresholdsSeq_set_maximum(&sample->engine, ((tms_MAXLEN_engine)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_EngineStateThresholdsSeq_set_length(&sample->engine, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_SourceInfo_finalize_w_return(
    tms_SourceInfo* sample)
{
    tms_SourceInfo_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_SourceInfo_finalize(
    tms_SourceInfo* sample)
{

    tms_SourceInfo_finalize_ex(sample,RTI_TRUE);
}

void tms_SourceInfo_finalize_ex(
    tms_SourceInfo* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SourceInfo_finalize_w_params(
        sample,&deallocParams);
}

void tms_SourceInfo_finalize_w_params(
    tms_SourceInfo* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!tms_ParameterMetadataSeq_set_element_deallocation_params(
        &sample->parameters,deallocParams)){
        return; 
    }
    if(!tms_ParameterMetadataSeq_finalize(&sample->parameters)){
        return;
    }

    if(!tms_EngineStateThresholdsSeq_set_element_deallocation_params(
        &sample->engine,deallocParams)){
        return; 
    }
    if(!tms_EngineStateThresholdsSeq_finalize(&sample->engine)){
        return;
    }

}

void tms_SourceInfo_finalize_optional_members(
    tms_SourceInfo* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SourceInfo_copy(
    tms_SourceInfo* dst,
    const tms_SourceInfo* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_ParameterMetadataSeq_copy(&dst->parameters ,
        &src->parameters )) {
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->supportsDroopCurve, &src->supportsDroopCurve)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->supportsNonlinearCurve, &src->supportsNonlinearCurve)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->supportsDigitalLoadShare, &src->supportsDigitalLoadShare)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->supportsAuthorizationToEnergize, &src->supportsAuthorizationToEnergize)) { 
            return RTI_FALSE;
        }
        if (!tms_EngineStateThresholdsSeq_copy(&dst->engine ,
        &src->engine )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SourceInfo' sequence class.
*/
#define T tms_SourceInfo
#define TSeq tms_SourceInfoSeq

#define T_initialize_w_params tms_SourceInfo_initialize_w_params

#define T_finalize_w_params   tms_SourceInfo_finalize_w_params
#define T_copy       tms_SourceInfo_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ProductInfoTYPENAME = "tms::ProductInfo";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ProductInfo_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_ProductInfo_g_tc_manufacturerName_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_manufacturerName)));
    static DDS_TypeCode tms_ProductInfo_g_tc_modelName_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_modelName)));
    static DDS_TypeCode tms_ProductInfo_g_tc_modelNumber_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_modelNumber)));
    static DDS_TypeCode tms_ProductInfo_g_tc_serialNumber_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_serialNumber)));
    static DDS_TypeCode tms_ProductInfo_g_tc_softwareVersion_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_softwareVersion)));
    static DDS_TypeCode tms_ProductInfo_g_tc_distribution_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_distribution)),NULL);
    static DDS_TypeCode tms_ProductInfo_g_tc_load_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_load)),NULL);
    static DDS_TypeCode tms_ProductInfo_g_tc_source_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_source)),NULL);

    static DDS_TypeCode_Member tms_ProductInfo_g_tc_members[20]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"role",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nsn",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"gtin",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"manufacturerName",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"modelName",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"modelNumber",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"serialNumber",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"sourcePower",/* Member name */
            {
                8,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"sourceVar",/* Member name */
            {
                9,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"loadPower",/* Member name */
            {
                10,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"storageEnergy",/* Member name */
            {
                11,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"distributionCurrent",/* Member name */
            {
                12,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"configTmpCount",/* Member name */
            {
                13,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"hasRealtimeClock",/* Member name */
            {
                14,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"softwareVersion",/* Member name */
            {
                15,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"platformId",/* Member name */
            {
                16,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"distribution",/* Member name */
            {
                17,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"load",/* Member name */
            {
                18,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"source",/* Member name */
            {
                19,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ProductInfo_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ProductInfo", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            20, /* Number of members */
            tms_ProductInfo_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ProductInfo*/

    if (is_initialized) {
        return &tms_ProductInfo_g_tc;
    }

    tms_ProductInfo_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ProductInfo_g_tc_distribution_sequence._data._typeCode = (RTICdrTypeCode *)tms_DistributionInfo_get_typecode();
    tms_ProductInfo_g_tc_distribution_sequence._data._sampleAccessInfo = tms_DistributionInfo_get_sample_seq_access_info();
    tms_ProductInfo_g_tc_load_sequence._data._typeCode = (RTICdrTypeCode *)tms_LoadInfo_get_typecode();
    tms_ProductInfo_g_tc_load_sequence._data._sampleAccessInfo = tms_LoadInfo_get_sample_seq_access_info();
    tms_ProductInfo_g_tc_source_sequence._data._typeCode = (RTICdrTypeCode *)tms_SourceInfo_get_typecode();
    tms_ProductInfo_g_tc_source_sequence._data._sampleAccessInfo = tms_SourceInfo_get_sample_seq_access_info();
    tms_ProductInfo_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ProductInfo_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_DeviceRole_get_typecode();
    tms_ProductInfo_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_NatoStockNumber_get_typecode();
    tms_ProductInfo_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_GlobalTradeItemNumber_get_typecode();
    tms_ProductInfo_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&tms_ProductInfo_g_tc_manufacturerName_string;
    tms_ProductInfo_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&tms_ProductInfo_g_tc_modelName_string;
    tms_ProductInfo_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&tms_ProductInfo_g_tc_modelNumber_string;
    tms_ProductInfo_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)&tms_ProductInfo_g_tc_serialNumber_string;
    tms_ProductInfo_g_tc_members[8]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ProductInfo_g_tc_members[9]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ProductInfo_g_tc_members[10]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ProductInfo_g_tc_members[11]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ProductInfo_g_tc_members[12]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_ProductInfo_g_tc_members[13]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ushort_w_new;
    tms_ProductInfo_g_tc_members[14]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_ProductInfo_g_tc_members[15]._representation._typeCode = (RTICdrTypeCode *)&tms_ProductInfo_g_tc_softwareVersion_string;
    tms_ProductInfo_g_tc_members[16]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ProductInfo_g_tc_members[17]._representation._typeCode = (RTICdrTypeCode *)& tms_ProductInfo_g_tc_distribution_sequence;
    tms_ProductInfo_g_tc_members[18]._representation._typeCode = (RTICdrTypeCode *)& tms_ProductInfo_g_tc_load_sequence;
    tms_ProductInfo_g_tc_members[19]._representation._typeCode = (RTICdrTypeCode *)& tms_ProductInfo_g_tc_source_sequence;

    /* Initialize the values for member annotations. */

    tms_ProductInfo_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_ProductInfo_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_ProductInfo_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ProductInfo_g_tc_members[4]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ProductInfo_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ProductInfo_g_tc_members[5]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ProductInfo_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ProductInfo_g_tc_members[6]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ProductInfo_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ProductInfo_g_tc_members[7]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ProductInfo_g_tc_members[8]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[8]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ProductInfo_g_tc_members[8]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[8]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ProductInfo_g_tc_members[8]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[8]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ProductInfo_g_tc_members[9]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[9]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ProductInfo_g_tc_members[9]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[9]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ProductInfo_g_tc_members[9]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[9]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ProductInfo_g_tc_members[10]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[10]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ProductInfo_g_tc_members[10]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[10]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ProductInfo_g_tc_members[10]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[10]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ProductInfo_g_tc_members[11]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[11]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ProductInfo_g_tc_members[11]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[11]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ProductInfo_g_tc_members[11]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[11]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ProductInfo_g_tc_members[12]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[12]._annotations._defaultValue._u.float_value = 0.0f;
    tms_ProductInfo_g_tc_members[12]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[12]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_ProductInfo_g_tc_members[12]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_ProductInfo_g_tc_members[12]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_ProductInfo_g_tc_members[13]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_ProductInfo_g_tc_members[13]._annotations._defaultValue._u.ushort_value = 0;
    tms_ProductInfo_g_tc_members[13]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_ProductInfo_g_tc_members[13]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_ProductInfo_g_tc_members[13]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_ProductInfo_g_tc_members[13]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_ProductInfo_g_tc_members[14]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_ProductInfo_g_tc_members[14]._annotations._defaultValue._u.boolean_value = 0;

    tms_ProductInfo_g_tc_members[15]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ProductInfo_g_tc_members[15]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ProductInfo_g_tc._data._sampleAccessInfo =
    tms_ProductInfo_get_sample_access_info();
    tms_ProductInfo_g_tc._data._typePlugin =
    tms_ProductInfo_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ProductInfo_g_tc;
}

#define TSeq tms_ProductInfoSeq
#define T tms_ProductInfo
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ProductInfo_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ProductInfo_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ProductInfoSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ProductInfoSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ProductInfo_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ProductInfo_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ProductInfo *sample;

    static RTIXCdrMemberAccessInfo tms_ProductInfo_g_memberAccessInfos[20] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ProductInfo_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ProductInfo_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ProductInfo);
    if (sample == NULL) {
        return NULL;
    }

    tms_ProductInfo_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->role - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nsn - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->gtin - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->manufacturerName - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->modelName - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->modelNumber - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->serialNumber - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[8].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->sourcePower - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[9].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->sourceVar - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[10].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->loadPower - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[11].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->storageEnergy - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[12].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->distributionCurrent - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[13].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->configTmpCount - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[14].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->hasRealtimeClock - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[15].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->softwareVersion - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[16].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->platformId - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[17].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->distribution - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[18].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->load - (char *)sample);

    tms_ProductInfo_g_memberAccessInfos[19].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->source - (char *)sample);

    tms_ProductInfo_g_sampleAccessInfo.memberAccessInfos = 
    tms_ProductInfo_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ProductInfo);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ProductInfo_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ProductInfo_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ProductInfo_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ProductInfo_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ProductInfo_get_member_value_pointer;

    tms_ProductInfo_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ProductInfo_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ProductInfo_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ProductInfo_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ProductInfo_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ProductInfo_finalize_w_return,
        NULL
    };

    return &tms_ProductInfo_g_typePlugin;
}
#endif

RTIBool tms_ProductInfo_initialize(
    tms_ProductInfo* sample) {
    return tms_ProductInfo_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ProductInfo_initialize_ex(
    tms_ProductInfo* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ProductInfo_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ProductInfo_initialize_w_params(
    tms_ProductInfo* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->role = ROLE_MICROGRID_CONTROLLER;
    if (!tms_NatoStockNumber_initialize_w_params(&sample->nsn,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_GlobalTradeItemNumber_initialize_w_params(&sample->gtin,
    allocParams)) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        sample->manufacturerName = DDS_String_alloc(((tms_MAXLEN_manufacturerName)));
        RTICdrType_copyStringEx(
            &sample->manufacturerName,
            "",
            ((tms_MAXLEN_manufacturerName)),
            RTI_FALSE);
        if (sample->manufacturerName == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->manufacturerName != NULL) {
            RTICdrType_copyStringEx(
                &sample->manufacturerName,
                "",
                ((tms_MAXLEN_manufacturerName)),
                RTI_FALSE);
            if (sample->manufacturerName == NULL) {
                return RTI_FALSE;
            }
        }
    }

    if (allocParams->allocate_memory) {
        sample->modelName = DDS_String_alloc(((tms_MAXLEN_modelName)));
        RTICdrType_copyStringEx(
            &sample->modelName,
            "",
            ((tms_MAXLEN_modelName)),
            RTI_FALSE);
        if (sample->modelName == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->modelName != NULL) {
            RTICdrType_copyStringEx(
                &sample->modelName,
                "",
                ((tms_MAXLEN_modelName)),
                RTI_FALSE);
            if (sample->modelName == NULL) {
                return RTI_FALSE;
            }
        }
    }

    if (allocParams->allocate_memory) {
        sample->modelNumber = DDS_String_alloc(((tms_MAXLEN_modelNumber)));
        RTICdrType_copyStringEx(
            &sample->modelNumber,
            "",
            ((tms_MAXLEN_modelNumber)),
            RTI_FALSE);
        if (sample->modelNumber == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->modelNumber != NULL) {
            RTICdrType_copyStringEx(
                &sample->modelNumber,
                "",
                ((tms_MAXLEN_modelNumber)),
                RTI_FALSE);
            if (sample->modelNumber == NULL) {
                return RTI_FALSE;
            }
        }
    }

    if (allocParams->allocate_memory) {
        sample->serialNumber = DDS_String_alloc(((tms_MAXLEN_serialNumber)));
        RTICdrType_copyStringEx(
            &sample->serialNumber,
            "",
            ((tms_MAXLEN_serialNumber)),
            RTI_FALSE);
        if (sample->serialNumber == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->serialNumber != NULL) {
            RTICdrType_copyStringEx(
                &sample->serialNumber,
                "",
                ((tms_MAXLEN_serialNumber)),
                RTI_FALSE);
            if (sample->serialNumber == NULL) {
                return RTI_FALSE;
            }
        }
    }

    sample->sourcePower = 0.0f;

    sample->sourceVar = 0.0f;

    sample->loadPower = 0.0f;

    sample->storageEnergy = 0.0f;

    sample->distributionCurrent = 0.0f;

    sample->configTmpCount = 0;

    sample->hasRealtimeClock = 0;

    if (allocParams->allocate_memory) {
        sample->softwareVersion = DDS_String_alloc(((tms_MAXLEN_softwareVersion)));
        RTICdrType_copyStringEx(
            &sample->softwareVersion,
            "",
            ((tms_MAXLEN_softwareVersion)),
            RTI_FALSE);
        if (sample->softwareVersion == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->softwareVersion != NULL) {
            RTICdrType_copyStringEx(
                &sample->softwareVersion,
                "",
                ((tms_MAXLEN_softwareVersion)),
                RTI_FALSE);
            if (sample->softwareVersion == NULL) {
                return RTI_FALSE;
            }
        }
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->platformId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_DistributionInfoSeq_initialize(&sample->distribution )){
            return RTI_FALSE;
        };
        if(!tms_DistributionInfoSeq_set_element_allocation_params(&sample->distribution ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_DistributionInfoSeq_set_absolute_maximum(&sample->distribution , ((tms_MAXLEN_distribution)))){
            return RTI_FALSE;
        }
        if (!tms_DistributionInfoSeq_set_maximum(&sample->distribution, ((tms_MAXLEN_distribution)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_DistributionInfoSeq_set_length(&sample->distribution, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_LoadInfoSeq_initialize(&sample->load )){
            return RTI_FALSE;
        };
        if(!tms_LoadInfoSeq_set_element_allocation_params(&sample->load ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_LoadInfoSeq_set_absolute_maximum(&sample->load , ((tms_MAXLEN_load)))){
            return RTI_FALSE;
        }
        if (!tms_LoadInfoSeq_set_maximum(&sample->load, ((tms_MAXLEN_load)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_LoadInfoSeq_set_length(&sample->load, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_SourceInfoSeq_initialize(&sample->source )){
            return RTI_FALSE;
        };
        if(!tms_SourceInfoSeq_set_element_allocation_params(&sample->source ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_SourceInfoSeq_set_absolute_maximum(&sample->source , ((tms_MAXLEN_source)))){
            return RTI_FALSE;
        }
        if (!tms_SourceInfoSeq_set_maximum(&sample->source, ((tms_MAXLEN_source)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_SourceInfoSeq_set_length(&sample->source, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_ProductInfo_finalize_w_return(
    tms_ProductInfo* sample)
{
    tms_ProductInfo_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ProductInfo_finalize(
    tms_ProductInfo* sample)
{

    tms_ProductInfo_finalize_ex(sample,RTI_TRUE);
}

void tms_ProductInfo_finalize_ex(
    tms_ProductInfo* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ProductInfo_finalize_w_params(
        sample,&deallocParams);
}

void tms_ProductInfo_finalize_w_params(
    tms_ProductInfo* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_DeviceRole_finalize_w_params(&sample->role,deallocParams);

    tms_NatoStockNumber_finalize_w_params(&sample->nsn,deallocParams);

    tms_GlobalTradeItemNumber_finalize_w_params(&sample->gtin,deallocParams);

    if (sample->manufacturerName != NULL) {
        DDS_String_free(sample->manufacturerName);
        sample->manufacturerName=NULL;

    }
    if (sample->modelName != NULL) {
        DDS_String_free(sample->modelName);
        sample->modelName=NULL;

    }
    if (sample->modelNumber != NULL) {
        DDS_String_free(sample->modelNumber);
        sample->modelNumber=NULL;

    }
    if (sample->serialNumber != NULL) {
        DDS_String_free(sample->serialNumber);
        sample->serialNumber=NULL;

    }

    if (sample->softwareVersion != NULL) {
        DDS_String_free(sample->softwareVersion);
        sample->softwareVersion=NULL;

    }
    tms_Fingerprint_finalize_w_params(&sample->platformId,deallocParams);

    if(!tms_DistributionInfoSeq_set_element_deallocation_params(
        &sample->distribution,deallocParams)){
        return; 
    }
    if(!tms_DistributionInfoSeq_finalize(&sample->distribution)){
        return;
    }

    if(!tms_LoadInfoSeq_set_element_deallocation_params(
        &sample->load,deallocParams)){
        return; 
    }
    if(!tms_LoadInfoSeq_finalize(&sample->load)){
        return;
    }

    if(!tms_SourceInfoSeq_set_element_deallocation_params(
        &sample->source,deallocParams)){
        return; 
    }
    if(!tms_SourceInfoSeq_finalize(&sample->source)){
        return;
    }

}

void tms_ProductInfo_finalize_optional_members(
    tms_ProductInfo* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ProductInfo_copy(
    tms_ProductInfo* dst,
    const tms_ProductInfo* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_DeviceRole_copy(
            &dst->role,(const tms_DeviceRole*)&src->role)) {
            return RTI_FALSE;
        } 
        if (!tms_NatoStockNumber_copy(
            &dst->nsn,(const tms_NatoStockNumber*)&src->nsn)) {
            return RTI_FALSE;
        } 
        if (!tms_GlobalTradeItemNumber_copy(
            &dst->gtin,(const tms_GlobalTradeItemNumber*)&src->gtin)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyStringEx (
            &dst->manufacturerName, src->manufacturerName, 
            ((tms_MAXLEN_manufacturerName)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!RTICdrType_copyStringEx (
            &dst->modelName, src->modelName, 
            ((tms_MAXLEN_modelName)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!RTICdrType_copyStringEx (
            &dst->modelNumber, src->modelNumber, 
            ((tms_MAXLEN_modelNumber)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!RTICdrType_copyStringEx (
            &dst->serialNumber, src->serialNumber, 
            ((tms_MAXLEN_serialNumber)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->sourcePower, &src->sourcePower)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->sourceVar, &src->sourceVar)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->loadPower, &src->loadPower)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->storageEnergy, &src->storageEnergy)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->distributionCurrent, &src->distributionCurrent)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedShort (
            &dst->configTmpCount, &src->configTmpCount)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->hasRealtimeClock, &src->hasRealtimeClock)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyStringEx (
            &dst->softwareVersion, src->softwareVersion, 
            ((tms_MAXLEN_softwareVersion)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!tms_Fingerprint_copy(
            &dst->platformId,(const tms_Fingerprint*)&src->platformId)) {
            return RTI_FALSE;
        } 
        if (!tms_DistributionInfoSeq_copy(&dst->distribution ,
        &src->distribution )) {
            return RTI_FALSE;
        }
        if (!tms_LoadInfoSeq_copy(&dst->load ,
        &src->load )) {
            return RTI_FALSE;
        }
        if (!tms_SourceInfoSeq_copy(&dst->source ,
        &src->source )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ProductInfo' sequence class.
*/
#define T tms_ProductInfo
#define TSeq tms_ProductInfoSeq

#define T_initialize_w_params tms_ProductInfo_initialize_w_params

#define T_finalize_w_params   tms_ProductInfo_finalize_w_params
#define T_copy       tms_ProductInfo_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_HeartbeatTYPENAME = "tms::Heartbeat";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_Heartbeat_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_Heartbeat_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"sequenceNumber",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_Heartbeat_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::Heartbeat", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_Heartbeat_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_Heartbeat*/

    if (is_initialized) {
        return &tms_Heartbeat_g_tc;
    }

    tms_Heartbeat_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_Heartbeat_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_Heartbeat_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;

    /* Initialize the values for member annotations. */

    tms_Heartbeat_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_Heartbeat_g_tc_members[1]._annotations._defaultValue._u.ulong_value = 0u;
    tms_Heartbeat_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_Heartbeat_g_tc_members[1]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_Heartbeat_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_Heartbeat_g_tc_members[1]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_Heartbeat_g_tc._data._sampleAccessInfo =
    tms_Heartbeat_get_sample_access_info();
    tms_Heartbeat_g_tc._data._typePlugin =
    tms_Heartbeat_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_Heartbeat_g_tc;
}

#define TSeq tms_HeartbeatSeq
#define T tms_Heartbeat
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_Heartbeat_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_Heartbeat_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_HeartbeatSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_HeartbeatSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_Heartbeat_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_Heartbeat_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_Heartbeat *sample;

    static RTIXCdrMemberAccessInfo tms_Heartbeat_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_Heartbeat_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_Heartbeat_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_Heartbeat);
    if (sample == NULL) {
        return NULL;
    }

    tms_Heartbeat_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_Heartbeat_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->sequenceNumber - (char *)sample);

    tms_Heartbeat_g_sampleAccessInfo.memberAccessInfos = 
    tms_Heartbeat_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_Heartbeat);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_Heartbeat_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_Heartbeat_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_Heartbeat_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_Heartbeat_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_Heartbeat_get_member_value_pointer;

    tms_Heartbeat_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_Heartbeat_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_Heartbeat_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_Heartbeat_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_Heartbeat_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_Heartbeat_finalize_w_return,
        NULL
    };

    return &tms_Heartbeat_g_typePlugin;
}
#endif

RTIBool tms_Heartbeat_initialize(
    tms_Heartbeat* sample) {
    return tms_Heartbeat_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_Heartbeat_initialize_ex(
    tms_Heartbeat* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_Heartbeat_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_Heartbeat_initialize_w_params(
    tms_Heartbeat* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->sequenceNumber = 0u;

    return RTI_TRUE;
}

RTIBool tms_Heartbeat_finalize_w_return(
    tms_Heartbeat* sample)
{
    tms_Heartbeat_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_Heartbeat_finalize(
    tms_Heartbeat* sample)
{

    tms_Heartbeat_finalize_ex(sample,RTI_TRUE);
}

void tms_Heartbeat_finalize_ex(
    tms_Heartbeat* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_Heartbeat_finalize_w_params(
        sample,&deallocParams);
}

void tms_Heartbeat_finalize_w_params(
    tms_Heartbeat* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_Heartbeat_finalize_optional_members(
    tms_Heartbeat* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_Heartbeat_copy(
    tms_Heartbeat* dst,
    const tms_Heartbeat* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedLong (
            &dst->sequenceNumber, &src->sequenceNumber)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_Heartbeat' sequence class.
*/
#define T tms_Heartbeat
#define TSeq tms_HeartbeatSeq

#define T_initialize_w_params tms_Heartbeat_initialize_w_params

#define T_finalize_w_params   tms_Heartbeat_finalize_w_params
#define T_copy       tms_Heartbeat_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SuspectParameterNumber_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_SuspectParameterNumber_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::SuspectParameterNumber", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_SuspectParameterNumber */

    if (is_initialized) {
        return &tms_SuspectParameterNumber_g_tc;
    }

    tms_SuspectParameterNumber_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_SuspectParameterNumber_g_tc._data._typeCode =  (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;

    /* Initialize the values for member annotations. */
    tms_SuspectParameterNumber_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_SuspectParameterNumber_g_tc._data._annotations._defaultValue._u.ulong_value = 0u;
    tms_SuspectParameterNumber_g_tc._data._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_SuspectParameterNumber_g_tc._data._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_SuspectParameterNumber_g_tc._data._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_SuspectParameterNumber_g_tc._data._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_SuspectParameterNumber_g_tc._data._sampleAccessInfo =
    tms_SuspectParameterNumber_get_sample_access_info();
    tms_SuspectParameterNumber_g_tc._data._typePlugin =
    tms_SuspectParameterNumber_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SuspectParameterNumber_g_tc;
}

#define TSeq tms_SuspectParameterNumberSeq
#define T tms_SuspectParameterNumber
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SuspectParameterNumber_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SuspectParameterNumber_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SuspectParameterNumberSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SuspectParameterNumberSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SuspectParameterNumber_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SuspectParameterNumber_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_SuspectParameterNumber_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SuspectParameterNumber_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SuspectParameterNumber_g_sampleAccessInfo;
    }

    tms_SuspectParameterNumber_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_SuspectParameterNumber_g_sampleAccessInfo.memberAccessInfos = 
    tms_SuspectParameterNumber_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SuspectParameterNumber);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SuspectParameterNumber_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SuspectParameterNumber_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SuspectParameterNumber_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SuspectParameterNumber_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SuspectParameterNumber_get_member_value_pointer;

    tms_SuspectParameterNumber_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SuspectParameterNumber_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SuspectParameterNumber_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SuspectParameterNumber_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SuspectParameterNumber_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SuspectParameterNumber_finalize_w_return,
        NULL
    };

    return &tms_SuspectParameterNumber_g_typePlugin;
}
#endif

RTIBool tms_SuspectParameterNumber_initialize(
    tms_SuspectParameterNumber* sample) {
    return tms_SuspectParameterNumber_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_SuspectParameterNumber_initialize_ex(
    tms_SuspectParameterNumber* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SuspectParameterNumber_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SuspectParameterNumber_initialize_w_params(
    tms_SuspectParameterNumber* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    (*sample) = 0u;

    return RTI_TRUE;
}

RTIBool tms_SuspectParameterNumber_finalize_w_return(
    tms_SuspectParameterNumber* sample)
{
    tms_SuspectParameterNumber_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_SuspectParameterNumber_finalize(
    tms_SuspectParameterNumber* sample)
{

    tms_SuspectParameterNumber_finalize_ex(sample,RTI_TRUE);
}

void tms_SuspectParameterNumber_finalize_ex(
    tms_SuspectParameterNumber* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SuspectParameterNumber_finalize_w_params(
        sample,&deallocParams);
}

void tms_SuspectParameterNumber_finalize_w_params(
    tms_SuspectParameterNumber* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_SuspectParameterNumber_finalize_optional_members(
    tms_SuspectParameterNumber* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SuspectParameterNumber_copy(
    tms_SuspectParameterNumber* dst,
    const tms_SuspectParameterNumber* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            dst, src)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SuspectParameterNumber' sequence class.
*/
#define T tms_SuspectParameterNumber
#define TSeq tms_SuspectParameterNumberSeq

#define T_initialize_w_params tms_SuspectParameterNumber_initialize_w_params

#define T_finalize_w_params   tms_SuspectParameterNumber_finalize_w_params
#define T_copy       tms_SuspectParameterNumber_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_FailureModeIndicator_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_FailureModeIndicator_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::FailureModeIndicator", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_FailureModeIndicator */

    if (is_initialized) {
        return &tms_FailureModeIndicator_g_tc;
    }

    tms_FailureModeIndicator_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_FailureModeIndicator_g_tc._data._typeCode =  (RTICdrTypeCode *)&DDS_g_tc_octet_w_new;

    /* Initialize the values for member annotations. */
    tms_FailureModeIndicator_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_OCTET;
    tms_FailureModeIndicator_g_tc._data._annotations._defaultValue._u.octet_value = 0;
    tms_FailureModeIndicator_g_tc._data._annotations._minValue._d = RTI_XCDR_TK_OCTET;
    tms_FailureModeIndicator_g_tc._data._annotations._minValue._u.octet_value = RTIXCdrOctet_MIN;
    tms_FailureModeIndicator_g_tc._data._annotations._maxValue._d = RTI_XCDR_TK_OCTET;
    tms_FailureModeIndicator_g_tc._data._annotations._maxValue._u.octet_value = RTIXCdrOctet_MAX;

    tms_FailureModeIndicator_g_tc._data._sampleAccessInfo =
    tms_FailureModeIndicator_get_sample_access_info();
    tms_FailureModeIndicator_g_tc._data._typePlugin =
    tms_FailureModeIndicator_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_FailureModeIndicator_g_tc;
}

#define TSeq tms_FailureModeIndicatorSeq
#define T tms_FailureModeIndicator
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_FailureModeIndicator_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_FailureModeIndicator_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_FailureModeIndicatorSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_FailureModeIndicatorSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_FailureModeIndicator_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_FailureModeIndicator_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_FailureModeIndicator_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_FailureModeIndicator_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_FailureModeIndicator_g_sampleAccessInfo;
    }

    tms_FailureModeIndicator_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_FailureModeIndicator_g_sampleAccessInfo.memberAccessInfos = 
    tms_FailureModeIndicator_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_FailureModeIndicator);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_FailureModeIndicator_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_FailureModeIndicator_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_FailureModeIndicator_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_FailureModeIndicator_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_FailureModeIndicator_get_member_value_pointer;

    tms_FailureModeIndicator_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_FailureModeIndicator_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_FailureModeIndicator_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_FailureModeIndicator_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_FailureModeIndicator_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_FailureModeIndicator_finalize_w_return,
        NULL
    };

    return &tms_FailureModeIndicator_g_typePlugin;
}
#endif

RTIBool tms_FailureModeIndicator_initialize(
    tms_FailureModeIndicator* sample) {
    return tms_FailureModeIndicator_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_FailureModeIndicator_initialize_ex(
    tms_FailureModeIndicator* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_FailureModeIndicator_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_FailureModeIndicator_initialize_w_params(
    tms_FailureModeIndicator* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    (*sample) = 0;

    return RTI_TRUE;
}

RTIBool tms_FailureModeIndicator_finalize_w_return(
    tms_FailureModeIndicator* sample)
{
    tms_FailureModeIndicator_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_FailureModeIndicator_finalize(
    tms_FailureModeIndicator* sample)
{

    tms_FailureModeIndicator_finalize_ex(sample,RTI_TRUE);
}

void tms_FailureModeIndicator_finalize_ex(
    tms_FailureModeIndicator* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_FailureModeIndicator_finalize_w_params(
        sample,&deallocParams);
}

void tms_FailureModeIndicator_finalize_w_params(
    tms_FailureModeIndicator* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_FailureModeIndicator_finalize_optional_members(
    tms_FailureModeIndicator* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_FailureModeIndicator_copy(
    tms_FailureModeIndicator* dst,
    const tms_FailureModeIndicator* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyOctet (
            dst, src)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_FailureModeIndicator' sequence class.
*/
#define T tms_FailureModeIndicator
#define TSeq tms_FailureModeIndicatorSeq

#define T_initialize_w_params tms_FailureModeIndicator_initialize_w_params

#define T_finalize_w_params   tms_FailureModeIndicator_finalize_w_params
#define T_copy       tms_FailureModeIndicator_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DtcSeverityTYPENAME = "tms::DtcSeverity";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DtcSeverity_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_DtcSeverity_g_tc_members[11]=
    {

        {
            (char *)"SEV_0_NOT_SPECIFIED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_0_NOT_SPECIFIED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_1_CLEAR",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_1_CLEAR, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_2_INFORMATIVE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_2_INFORMATIVE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_3_PREVENTATIVE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_3_PREVENTATIVE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_4_DEGRADED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_4_DEGRADED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_5_WARNING",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_5_WARNING, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_6_MINOR",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_6_MINOR, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_7_MAJOR",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_7_MAJOR, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_8_CRITICAL",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_8_CRITICAL, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_9_FATAL",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_9_FATAL, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SEV_10_HUMAN_SAFETY",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SEV_10_HUMAN_SAFETY, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DtcSeverity_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DtcSeverity", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            11, /* Number of members */
            tms_DtcSeverity_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DtcSeverity*/

    if (is_initialized) {
        return &tms_DtcSeverity_g_tc;
    }

    tms_DtcSeverity_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_DtcSeverity_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_DtcSeverity_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_DtcSeverity_g_tc._data._sampleAccessInfo =
    tms_DtcSeverity_get_sample_access_info();
    tms_DtcSeverity_g_tc._data._typePlugin =
    tms_DtcSeverity_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DtcSeverity_g_tc;
}

#define TSeq tms_DtcSeveritySeq
#define T tms_DtcSeverity
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DtcSeverity_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DtcSeverity_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DtcSeveritySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DtcSeveritySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DtcSeverity_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DtcSeverity_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_DtcSeverity_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DtcSeverity_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DtcSeverity_g_sampleAccessInfo;
    }

    tms_DtcSeverity_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_DtcSeverity_g_sampleAccessInfo.memberAccessInfos = 
    tms_DtcSeverity_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DtcSeverity);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DtcSeverity_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DtcSeverity_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DtcSeverity_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DtcSeverity_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DtcSeverity_get_member_value_pointer;

    tms_DtcSeverity_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DtcSeverity_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DtcSeverity_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DtcSeverity_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DtcSeverity_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DtcSeverity_finalize_w_return,
        NULL
    };

    return &tms_DtcSeverity_g_typePlugin;
}
#endif

RTIBool tms_DtcSeverity_initialize(
    tms_DtcSeverity* sample) {
    *sample = SEV_0_NOT_SPECIFIED;
    return RTI_TRUE;
}

RTIBool tms_DtcSeverity_initialize_ex(
    tms_DtcSeverity* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DtcSeverity_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DtcSeverity_initialize_w_params(
    tms_DtcSeverity* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = SEV_0_NOT_SPECIFIED;
    return RTI_TRUE;
}

RTIBool tms_DtcSeverity_finalize_w_return(
    tms_DtcSeverity* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_DtcSeverity_finalize(
    tms_DtcSeverity* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_DtcSeverity_finalize_ex(
    tms_DtcSeverity* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DtcSeverity_finalize_w_params(
        sample,&deallocParams);
}

void tms_DtcSeverity_finalize_w_params(
    tms_DtcSeverity* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_DtcSeverity_finalize_optional_members(
    tms_DtcSeverity* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DtcSeverity_copy(
    tms_DtcSeverity* dst,
    const tms_DtcSeverity* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DtcSeverity' sequence class.
*/
#define T tms_DtcSeverity
#define TSeq tms_DtcSeveritySeq

#define T_initialize_w_params tms_DtcSeverity_initialize_w_params

#define T_finalize_w_params   tms_DtcSeverity_finalize_w_params
#define T_copy       tms_DtcSeverity_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DiagnosticTroubleCodeTYPENAME = "tms::DiagnosticTroubleCode";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DiagnosticTroubleCode_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DiagnosticTroubleCode_g_tc_hint_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_hint)));

    static DDS_TypeCode_Member tms_DiagnosticTroubleCode_g_tc_members[6]=
    {

        {
            (char *)"suspectParameter",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"failureMode",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"occurrenceCount",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"timeRaised",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"severity",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"hint",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DiagnosticTroubleCode_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DiagnosticTroubleCode", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_DiagnosticTroubleCode_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DiagnosticTroubleCode*/

    if (is_initialized) {
        return &tms_DiagnosticTroubleCode_g_tc;
    }

    tms_DiagnosticTroubleCode_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DiagnosticTroubleCode_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SuspectParameterNumber_get_typecode();
    tms_DiagnosticTroubleCode_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_FailureModeIndicator_get_typecode();
    tms_DiagnosticTroubleCode_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;
    tms_DiagnosticTroubleCode_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_DiagnosticTroubleCode_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_DtcSeverity_get_typecode();
    tms_DiagnosticTroubleCode_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&tms_DiagnosticTroubleCode_g_tc_hint_string;

    /* Initialize the values for member annotations. */
    tms_DiagnosticTroubleCode_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_DiagnosticTroubleCode_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_DiagnosticTroubleCode_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_DiagnosticTroubleCode_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_DiagnosticTroubleCode_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_DiagnosticTroubleCode_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_DiagnosticTroubleCode_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_OCTET;
    tms_DiagnosticTroubleCode_g_tc_members[1]._annotations._defaultValue._u.octet_value = 0;
    tms_DiagnosticTroubleCode_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_OCTET;
    tms_DiagnosticTroubleCode_g_tc_members[1]._annotations._minValue._u.octet_value = RTIXCdrOctet_MIN;
    tms_DiagnosticTroubleCode_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_OCTET;
    tms_DiagnosticTroubleCode_g_tc_members[1]._annotations._maxValue._u.octet_value = RTIXCdrOctet_MAX;

    tms_DiagnosticTroubleCode_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_DiagnosticTroubleCode_g_tc_members[2]._annotations._defaultValue._u.ulong_value = 0u;
    tms_DiagnosticTroubleCode_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_DiagnosticTroubleCode_g_tc_members[2]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_DiagnosticTroubleCode_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_DiagnosticTroubleCode_g_tc_members[2]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_DiagnosticTroubleCode_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_DiagnosticTroubleCode_g_tc_members[4]._annotations._defaultValue._u.enumerated_value = 0;

    tms_DiagnosticTroubleCode_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_DiagnosticTroubleCode_g_tc_members[5]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_DiagnosticTroubleCode_g_tc._data._sampleAccessInfo =
    tms_DiagnosticTroubleCode_get_sample_access_info();
    tms_DiagnosticTroubleCode_g_tc._data._typePlugin =
    tms_DiagnosticTroubleCode_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DiagnosticTroubleCode_g_tc;
}

#define TSeq tms_DiagnosticTroubleCodeSeq
#define T tms_DiagnosticTroubleCode
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DiagnosticTroubleCode_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DiagnosticTroubleCode_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DiagnosticTroubleCodeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DiagnosticTroubleCodeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DiagnosticTroubleCode_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DiagnosticTroubleCode_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DiagnosticTroubleCode *sample;

    static RTIXCdrMemberAccessInfo tms_DiagnosticTroubleCode_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DiagnosticTroubleCode_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DiagnosticTroubleCode_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DiagnosticTroubleCode);
    if (sample == NULL) {
        return NULL;
    }

    tms_DiagnosticTroubleCode_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->suspectParameter - (char *)sample);

    tms_DiagnosticTroubleCode_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->failureMode - (char *)sample);

    tms_DiagnosticTroubleCode_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->occurrenceCount - (char *)sample);

    tms_DiagnosticTroubleCode_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->timeRaised - (char *)sample);

    tms_DiagnosticTroubleCode_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->severity - (char *)sample);

    tms_DiagnosticTroubleCode_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->hint - (char *)sample);

    tms_DiagnosticTroubleCode_g_sampleAccessInfo.memberAccessInfos = 
    tms_DiagnosticTroubleCode_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DiagnosticTroubleCode);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DiagnosticTroubleCode_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DiagnosticTroubleCode_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DiagnosticTroubleCode_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DiagnosticTroubleCode_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DiagnosticTroubleCode_get_member_value_pointer;

    tms_DiagnosticTroubleCode_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DiagnosticTroubleCode_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DiagnosticTroubleCode_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DiagnosticTroubleCode_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DiagnosticTroubleCode_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DiagnosticTroubleCode_finalize_w_return,
        NULL
    };

    return &tms_DiagnosticTroubleCode_g_typePlugin;
}
#endif

RTIBool tms_DiagnosticTroubleCode_initialize(
    tms_DiagnosticTroubleCode* sample) {
    return tms_DiagnosticTroubleCode_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DiagnosticTroubleCode_initialize_ex(
    tms_DiagnosticTroubleCode* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DiagnosticTroubleCode_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DiagnosticTroubleCode_initialize_w_params(
    tms_DiagnosticTroubleCode* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->suspectParameter = 0u;

    sample->failureMode = 0;

    sample->occurrenceCount = 0u;

    if (!tms_ClockMonotonic_initialize_w_params(&sample->timeRaised,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->severity = SEV_0_NOT_SPECIFIED;

    if (allocParams->allocate_memory) {
        sample->hint = DDS_String_alloc(((tms_MAXLEN_hint)));
        RTICdrType_copyStringEx(
            &sample->hint,
            "",
            ((tms_MAXLEN_hint)),
            RTI_FALSE);
        if (sample->hint == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->hint != NULL) {
            RTICdrType_copyStringEx(
                &sample->hint,
                "",
                ((tms_MAXLEN_hint)),
                RTI_FALSE);
            if (sample->hint == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_DiagnosticTroubleCode_finalize_w_return(
    tms_DiagnosticTroubleCode* sample)
{
    tms_DiagnosticTroubleCode_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DiagnosticTroubleCode_finalize(
    tms_DiagnosticTroubleCode* sample)
{

    tms_DiagnosticTroubleCode_finalize_ex(sample,RTI_TRUE);
}

void tms_DiagnosticTroubleCode_finalize_ex(
    tms_DiagnosticTroubleCode* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DiagnosticTroubleCode_finalize_w_params(
        sample,&deallocParams);
}

void tms_DiagnosticTroubleCode_finalize_w_params(
    tms_DiagnosticTroubleCode* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_ClockMonotonic_finalize_w_params(&sample->timeRaised,deallocParams);

    tms_DtcSeverity_finalize_w_params(&sample->severity,deallocParams);

    if (sample->hint != NULL) {
        DDS_String_free(sample->hint);
        sample->hint=NULL;

    }
}

void tms_DiagnosticTroubleCode_finalize_optional_members(
    tms_DiagnosticTroubleCode* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DiagnosticTroubleCode_copy(
    tms_DiagnosticTroubleCode* dst,
    const tms_DiagnosticTroubleCode* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->suspectParameter, &src->suspectParameter)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyOctet (
            &dst->failureMode, &src->failureMode)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->occurrenceCount, &src->occurrenceCount)) { 
            return RTI_FALSE;
        }
        if (!tms_ClockMonotonic_copy(
            &dst->timeRaised,(const tms_ClockMonotonic*)&src->timeRaised)) {
            return RTI_FALSE;
        } 
        if (!tms_DtcSeverity_copy(
            &dst->severity,(const tms_DtcSeverity*)&src->severity)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyStringEx (
            &dst->hint, src->hint, 
            ((tms_MAXLEN_hint)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DiagnosticTroubleCode' sequence class.
*/
#define T tms_DiagnosticTroubleCode
#define TSeq tms_DiagnosticTroubleCodeSeq

#define T_initialize_w_params tms_DiagnosticTroubleCode_initialize_w_params

#define T_finalize_w_params   tms_DiagnosticTroubleCode_finalize_w_params
#define T_copy       tms_DiagnosticTroubleCode_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ActiveDiagnosticMessagesTYPENAME = "tms::ActiveDiagnosticMessages";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ActiveDiagnosticMessages_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_ActiveDiagnosticMessages_g_tc_codes_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_codes)),NULL);

    static DDS_TypeCode_Member tms_ActiveDiagnosticMessages_g_tc_members[3]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"codes",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"overflow",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ActiveDiagnosticMessages_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ActiveDiagnosticMessages", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_ActiveDiagnosticMessages_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ActiveDiagnosticMessages*/

    if (is_initialized) {
        return &tms_ActiveDiagnosticMessages_g_tc;
    }

    tms_ActiveDiagnosticMessages_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ActiveDiagnosticMessages_g_tc_codes_sequence._data._typeCode = (RTICdrTypeCode *)tms_DiagnosticTroubleCode_get_typecode();
    tms_ActiveDiagnosticMessages_g_tc_codes_sequence._data._sampleAccessInfo = tms_DiagnosticTroubleCode_get_sample_seq_access_info();
    tms_ActiveDiagnosticMessages_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ActiveDiagnosticMessages_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_ActiveDiagnosticMessages_g_tc_codes_sequence;
    tms_ActiveDiagnosticMessages_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;

    /* Initialize the values for member annotations. */

    tms_ActiveDiagnosticMessages_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_ActiveDiagnosticMessages_g_tc_members[2]._annotations._defaultValue._u.ulong_value = 0u;
    tms_ActiveDiagnosticMessages_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_ActiveDiagnosticMessages_g_tc_members[2]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_ActiveDiagnosticMessages_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_ActiveDiagnosticMessages_g_tc_members[2]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_ActiveDiagnosticMessages_g_tc._data._sampleAccessInfo =
    tms_ActiveDiagnosticMessages_get_sample_access_info();
    tms_ActiveDiagnosticMessages_g_tc._data._typePlugin =
    tms_ActiveDiagnosticMessages_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ActiveDiagnosticMessages_g_tc;
}

#define TSeq tms_ActiveDiagnosticMessagesSeq
#define T tms_ActiveDiagnosticMessages
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ActiveDiagnosticMessages_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ActiveDiagnosticMessages_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ActiveDiagnosticMessagesSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ActiveDiagnosticMessagesSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ActiveDiagnosticMessages_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ActiveDiagnosticMessages_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ActiveDiagnosticMessages *sample;

    static RTIXCdrMemberAccessInfo tms_ActiveDiagnosticMessages_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ActiveDiagnosticMessages_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ActiveDiagnosticMessages_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ActiveDiagnosticMessages);
    if (sample == NULL) {
        return NULL;
    }

    tms_ActiveDiagnosticMessages_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_ActiveDiagnosticMessages_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->codes - (char *)sample);

    tms_ActiveDiagnosticMessages_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->overflow - (char *)sample);

    tms_ActiveDiagnosticMessages_g_sampleAccessInfo.memberAccessInfos = 
    tms_ActiveDiagnosticMessages_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ActiveDiagnosticMessages);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ActiveDiagnosticMessages_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ActiveDiagnosticMessages_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ActiveDiagnosticMessages_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ActiveDiagnosticMessages_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ActiveDiagnosticMessages_get_member_value_pointer;

    tms_ActiveDiagnosticMessages_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ActiveDiagnosticMessages_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ActiveDiagnosticMessages_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ActiveDiagnosticMessages_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ActiveDiagnosticMessages_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ActiveDiagnosticMessages_finalize_w_return,
        NULL
    };

    return &tms_ActiveDiagnosticMessages_g_typePlugin;
}
#endif

RTIBool tms_ActiveDiagnosticMessages_initialize(
    tms_ActiveDiagnosticMessages* sample) {
    return tms_ActiveDiagnosticMessages_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ActiveDiagnosticMessages_initialize_ex(
    tms_ActiveDiagnosticMessages* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ActiveDiagnosticMessages_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ActiveDiagnosticMessages_initialize_w_params(
    tms_ActiveDiagnosticMessages* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_DiagnosticTroubleCodeSeq_initialize(&sample->codes )){
            return RTI_FALSE;
        };
        if(!tms_DiagnosticTroubleCodeSeq_set_element_allocation_params(&sample->codes ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_DiagnosticTroubleCodeSeq_set_absolute_maximum(&sample->codes , ((tms_MAXLEN_codes)))){
            return RTI_FALSE;
        }
        if (!tms_DiagnosticTroubleCodeSeq_set_maximum(&sample->codes, ((tms_MAXLEN_codes)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_DiagnosticTroubleCodeSeq_set_length(&sample->codes, 0)){
            return RTI_FALSE;
        }    
    }

    sample->overflow = 0u;

    return RTI_TRUE;
}

RTIBool tms_ActiveDiagnosticMessages_finalize_w_return(
    tms_ActiveDiagnosticMessages* sample)
{
    tms_ActiveDiagnosticMessages_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ActiveDiagnosticMessages_finalize(
    tms_ActiveDiagnosticMessages* sample)
{

    tms_ActiveDiagnosticMessages_finalize_ex(sample,RTI_TRUE);
}

void tms_ActiveDiagnosticMessages_finalize_ex(
    tms_ActiveDiagnosticMessages* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ActiveDiagnosticMessages_finalize_w_params(
        sample,&deallocParams);
}

void tms_ActiveDiagnosticMessages_finalize_w_params(
    tms_ActiveDiagnosticMessages* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_DiagnosticTroubleCodeSeq_set_element_deallocation_params(
        &sample->codes,deallocParams)){
        return; 
    }
    if(!tms_DiagnosticTroubleCodeSeq_finalize(&sample->codes)){
        return;
    }

}

void tms_ActiveDiagnosticMessages_finalize_optional_members(
    tms_ActiveDiagnosticMessages* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ActiveDiagnosticMessages_copy(
    tms_ActiveDiagnosticMessages* dst,
    const tms_ActiveDiagnosticMessages* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_DiagnosticTroubleCodeSeq_copy(&dst->codes ,
        &src->codes )) {
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->overflow, &src->overflow)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ActiveDiagnosticMessages' sequence class.
*/
#define T tms_ActiveDiagnosticMessages
#define TSeq tms_ActiveDiagnosticMessagesSeq

#define T_initialize_w_params tms_ActiveDiagnosticMessages_initialize_w_params

#define T_finalize_w_params   tms_ActiveDiagnosticMessages_finalize_w_params
#define T_copy       tms_ActiveDiagnosticMessages_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_StandardConfigMasterTYPENAME = "tms::StandardConfigMaster";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_StandardConfigMaster_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_StandardConfigMaster_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"masterId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_StandardConfigMaster_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::StandardConfigMaster", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_StandardConfigMaster_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_StandardConfigMaster*/

    if (is_initialized) {
        return &tms_StandardConfigMaster_g_tc;
    }

    tms_StandardConfigMaster_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_StandardConfigMaster_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_StandardConfigMaster_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();

    /* Initialize the values for member annotations. */

    tms_StandardConfigMaster_g_tc._data._sampleAccessInfo =
    tms_StandardConfigMaster_get_sample_access_info();
    tms_StandardConfigMaster_g_tc._data._typePlugin =
    tms_StandardConfigMaster_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_StandardConfigMaster_g_tc;
}

#define TSeq tms_StandardConfigMasterSeq
#define T tms_StandardConfigMaster
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_StandardConfigMaster_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_StandardConfigMaster_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_StandardConfigMasterSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_StandardConfigMasterSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_StandardConfigMaster_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_StandardConfigMaster_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_StandardConfigMaster *sample;

    static RTIXCdrMemberAccessInfo tms_StandardConfigMaster_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_StandardConfigMaster_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_StandardConfigMaster_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_StandardConfigMaster);
    if (sample == NULL) {
        return NULL;
    }

    tms_StandardConfigMaster_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_StandardConfigMaster_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->masterId - (char *)sample);

    tms_StandardConfigMaster_g_sampleAccessInfo.memberAccessInfos = 
    tms_StandardConfigMaster_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_StandardConfigMaster);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_StandardConfigMaster_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_StandardConfigMaster_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_StandardConfigMaster_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_StandardConfigMaster_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_StandardConfigMaster_get_member_value_pointer;

    tms_StandardConfigMaster_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_StandardConfigMaster_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_StandardConfigMaster_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_StandardConfigMaster_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_StandardConfigMaster_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_StandardConfigMaster_finalize_w_return,
        NULL
    };

    return &tms_StandardConfigMaster_g_typePlugin;
}
#endif

RTIBool tms_StandardConfigMaster_initialize(
    tms_StandardConfigMaster* sample) {
    return tms_StandardConfigMaster_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_StandardConfigMaster_initialize_ex(
    tms_StandardConfigMaster* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_StandardConfigMaster_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_StandardConfigMaster_initialize_w_params(
    tms_StandardConfigMaster* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->masterId,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_StandardConfigMaster_finalize_w_return(
    tms_StandardConfigMaster* sample)
{
    tms_StandardConfigMaster_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_StandardConfigMaster_finalize(
    tms_StandardConfigMaster* sample)
{

    tms_StandardConfigMaster_finalize_ex(sample,RTI_TRUE);
}

void tms_StandardConfigMaster_finalize_ex(
    tms_StandardConfigMaster* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_StandardConfigMaster_finalize_w_params(
        sample,&deallocParams);
}

void tms_StandardConfigMaster_finalize_w_params(
    tms_StandardConfigMaster* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->masterId,deallocParams);

}

void tms_StandardConfigMaster_finalize_optional_members(
    tms_StandardConfigMaster* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_StandardConfigMaster_copy(
    tms_StandardConfigMaster* dst,
    const tms_StandardConfigMaster* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->masterId,(const tms_Fingerprint*)&src->masterId)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_StandardConfigMaster' sequence class.
*/
#define T tms_StandardConfigMaster
#define TSeq tms_StandardConfigMasterSeq

#define T_initialize_w_params tms_StandardConfigMaster_initialize_w_params

#define T_finalize_w_params   tms_StandardConfigMaster_finalize_w_params
#define T_copy       tms_StandardConfigMaster_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_CopyConfigRequestTYPENAME = "tms::CopyConfigRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_CopyConfigRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_CopyConfigRequest_g_tc_members[4]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"source",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"target",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_CopyConfigRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::CopyConfigRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_CopyConfigRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_CopyConfigRequest*/

    if (is_initialized) {
        return &tms_CopyConfigRequest_g_tc;
    }

    tms_CopyConfigRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_CopyConfigRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_CopyConfigRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_CopyConfigRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_CopyConfigRequest_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();

    /* Initialize the values for member annotations. */

    tms_CopyConfigRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_CopyConfigRequest_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_CopyConfigRequest_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_CopyConfigRequest_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_CopyConfigRequest_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_CopyConfigRequest_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_CopyConfigRequest_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_CopyConfigRequest_g_tc_members[3]._annotations._defaultValue._u.ushort_value = 0;
    tms_CopyConfigRequest_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_CopyConfigRequest_g_tc_members[3]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_CopyConfigRequest_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_CopyConfigRequest_g_tc_members[3]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_CopyConfigRequest_g_tc._data._sampleAccessInfo =
    tms_CopyConfigRequest_get_sample_access_info();
    tms_CopyConfigRequest_g_tc._data._typePlugin =
    tms_CopyConfigRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_CopyConfigRequest_g_tc;
}

#define TSeq tms_CopyConfigRequestSeq
#define T tms_CopyConfigRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_CopyConfigRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_CopyConfigRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_CopyConfigRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_CopyConfigRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_CopyConfigRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_CopyConfigRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_CopyConfigRequest *sample;

    static RTIXCdrMemberAccessInfo tms_CopyConfigRequest_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_CopyConfigRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_CopyConfigRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_CopyConfigRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_CopyConfigRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_CopyConfigRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_CopyConfigRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->source - (char *)sample);

    tms_CopyConfigRequest_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->target - (char *)sample);

    tms_CopyConfigRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_CopyConfigRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_CopyConfigRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_CopyConfigRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_CopyConfigRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_CopyConfigRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_CopyConfigRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_CopyConfigRequest_get_member_value_pointer;

    tms_CopyConfigRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_CopyConfigRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_CopyConfigRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_CopyConfigRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_CopyConfigRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_CopyConfigRequest_finalize_w_return,
        NULL
    };

    return &tms_CopyConfigRequest_g_typePlugin;
}
#endif

RTIBool tms_CopyConfigRequest_initialize(
    tms_CopyConfigRequest* sample) {
    return tms_CopyConfigRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_CopyConfigRequest_initialize_ex(
    tms_CopyConfigRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_CopyConfigRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_CopyConfigRequest_initialize_w_params(
    tms_CopyConfigRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->source = 0;

    sample->target = 0;

    return RTI_TRUE;
}

RTIBool tms_CopyConfigRequest_finalize_w_return(
    tms_CopyConfigRequest* sample)
{
    tms_CopyConfigRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_CopyConfigRequest_finalize(
    tms_CopyConfigRequest* sample)
{

    tms_CopyConfigRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_CopyConfigRequest_finalize_ex(
    tms_CopyConfigRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_CopyConfigRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_CopyConfigRequest_finalize_w_params(
    tms_CopyConfigRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_CopyConfigRequest_finalize_optional_members(
    tms_CopyConfigRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_CopyConfigRequest_copy(
    tms_CopyConfigRequest* dst,
    const tms_CopyConfigRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->source, &src->source)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedShort (
            &dst->target, &src->target)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_CopyConfigRequest' sequence class.
*/
#define T tms_CopyConfigRequest
#define TSeq tms_CopyConfigRequestSeq

#define T_initialize_w_params tms_CopyConfigRequest_initialize_w_params

#define T_finalize_w_params   tms_CopyConfigRequest_finalize_w_params
#define T_copy       tms_CopyConfigRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ReserveConfigRequestTYPENAME = "tms::ReserveConfigRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ReserveConfigRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ReserveConfigRequest_g_tc_members[4]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"forceRelease",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"source",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ReserveConfigRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ReserveConfigRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_ReserveConfigRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ReserveConfigRequest*/

    if (is_initialized) {
        return &tms_ReserveConfigRequest_g_tc;
    }

    tms_ReserveConfigRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ReserveConfigRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_ReserveConfigRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ReserveConfigRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_ReserveConfigRequest_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();

    /* Initialize the values for member annotations. */

    tms_ReserveConfigRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_ReserveConfigRequest_g_tc_members[2]._annotations._defaultValue._u.boolean_value = 0;

    tms_ReserveConfigRequest_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_ReserveConfigRequest_g_tc_members[3]._annotations._defaultValue._u.ushort_value = 0;
    tms_ReserveConfigRequest_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_ReserveConfigRequest_g_tc_members[3]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_ReserveConfigRequest_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_ReserveConfigRequest_g_tc_members[3]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_ReserveConfigRequest_g_tc._data._sampleAccessInfo =
    tms_ReserveConfigRequest_get_sample_access_info();
    tms_ReserveConfigRequest_g_tc._data._typePlugin =
    tms_ReserveConfigRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ReserveConfigRequest_g_tc;
}

#define TSeq tms_ReserveConfigRequestSeq
#define T tms_ReserveConfigRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ReserveConfigRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ReserveConfigRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ReserveConfigRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ReserveConfigRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ReserveConfigRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ReserveConfigRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ReserveConfigRequest *sample;

    static RTIXCdrMemberAccessInfo tms_ReserveConfigRequest_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ReserveConfigRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ReserveConfigRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ReserveConfigRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_ReserveConfigRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_ReserveConfigRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_ReserveConfigRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->forceRelease - (char *)sample);

    tms_ReserveConfigRequest_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->source - (char *)sample);

    tms_ReserveConfigRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_ReserveConfigRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ReserveConfigRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ReserveConfigRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ReserveConfigRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ReserveConfigRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ReserveConfigRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ReserveConfigRequest_get_member_value_pointer;

    tms_ReserveConfigRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ReserveConfigRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ReserveConfigRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ReserveConfigRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ReserveConfigRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ReserveConfigRequest_finalize_w_return,
        NULL
    };

    return &tms_ReserveConfigRequest_g_typePlugin;
}
#endif

RTIBool tms_ReserveConfigRequest_initialize(
    tms_ReserveConfigRequest* sample) {
    return tms_ReserveConfigRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ReserveConfigRequest_initialize_ex(
    tms_ReserveConfigRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ReserveConfigRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ReserveConfigRequest_initialize_w_params(
    tms_ReserveConfigRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->forceRelease = 0;

    sample->source = 0;

    return RTI_TRUE;
}

RTIBool tms_ReserveConfigRequest_finalize_w_return(
    tms_ReserveConfigRequest* sample)
{
    tms_ReserveConfigRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ReserveConfigRequest_finalize(
    tms_ReserveConfigRequest* sample)
{

    tms_ReserveConfigRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_ReserveConfigRequest_finalize_ex(
    tms_ReserveConfigRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ReserveConfigRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_ReserveConfigRequest_finalize_w_params(
    tms_ReserveConfigRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_ReserveConfigRequest_finalize_optional_members(
    tms_ReserveConfigRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ReserveConfigRequest_copy(
    tms_ReserveConfigRequest* dst,
    const tms_ReserveConfigRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyBoolean (
            &dst->forceRelease, &src->forceRelease)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedShort (
            &dst->source, &src->source)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ReserveConfigRequest' sequence class.
*/
#define T tms_ReserveConfigRequest
#define TSeq tms_ReserveConfigRequestSeq

#define T_initialize_w_params tms_ReserveConfigRequest_initialize_w_params

#define T_finalize_w_params   tms_ReserveConfigRequest_finalize_w_params
#define T_copy       tms_ReserveConfigRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ReserveConfigReplyTYPENAME = "tms::ReserveConfigReply";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ReserveConfigReply_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ReserveConfigReply_g_tc_members[4]=
    {

        {
            (char *)"relatedRequestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"status",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"tmp",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"releaseId",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ReserveConfigReply_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ReserveConfigReply", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_ReserveConfigReply_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ReserveConfigReply*/

    if (is_initialized) {
        return &tms_ReserveConfigReply_g_tc;
    }

    tms_ReserveConfigReply_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ReserveConfigReply_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_ReserveConfigReply_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ReplyStatus_get_typecode();
    tms_ReserveConfigReply_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_ReserveConfigReply_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();

    /* Initialize the values for member annotations. */

    tms_ReserveConfigReply_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_ReserveConfigReply_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_ReserveConfigReply_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_ReserveConfigReply_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_ReserveConfigReply_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_ReserveConfigReply_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_ReserveConfigReply_g_tc._data._sampleAccessInfo =
    tms_ReserveConfigReply_get_sample_access_info();
    tms_ReserveConfigReply_g_tc._data._typePlugin =
    tms_ReserveConfigReply_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ReserveConfigReply_g_tc;
}

#define TSeq tms_ReserveConfigReplySeq
#define T tms_ReserveConfigReply
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ReserveConfigReply_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ReserveConfigReply_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ReserveConfigReplySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ReserveConfigReplySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ReserveConfigReply_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ReserveConfigReply_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ReserveConfigReply *sample;

    static RTIXCdrMemberAccessInfo tms_ReserveConfigReply_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ReserveConfigReply_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ReserveConfigReply_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ReserveConfigReply);
    if (sample == NULL) {
        return NULL;
    }

    tms_ReserveConfigReply_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->relatedRequestId - (char *)sample);

    tms_ReserveConfigReply_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->status - (char *)sample);

    tms_ReserveConfigReply_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->tmp - (char *)sample);

    tms_ReserveConfigReply_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->releaseId - (char *)sample);

    tms_ReserveConfigReply_g_sampleAccessInfo.memberAccessInfos = 
    tms_ReserveConfigReply_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ReserveConfigReply);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ReserveConfigReply_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ReserveConfigReply_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ReserveConfigReply_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ReserveConfigReply_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ReserveConfigReply_get_member_value_pointer;

    tms_ReserveConfigReply_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ReserveConfigReply_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ReserveConfigReply_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ReserveConfigReply_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ReserveConfigReply_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ReserveConfigReply_finalize_w_return,
        NULL
    };

    return &tms_ReserveConfigReply_g_typePlugin;
}
#endif

RTIBool tms_ReserveConfigReply_initialize(
    tms_ReserveConfigReply* sample) {
    return tms_ReserveConfigReply_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ReserveConfigReply_initialize_ex(
    tms_ReserveConfigReply* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ReserveConfigReply_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ReserveConfigReply_initialize_w_params(
    tms_ReserveConfigReply* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->relatedRequestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ReplyStatus_initialize_w_params(&sample->status,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->tmp = 0;

    if (!tms_Fingerprint_initialize_w_params(&sample->releaseId,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_ReserveConfigReply_finalize_w_return(
    tms_ReserveConfigReply* sample)
{
    tms_ReserveConfigReply_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ReserveConfigReply_finalize(
    tms_ReserveConfigReply* sample)
{

    tms_ReserveConfigReply_finalize_ex(sample,RTI_TRUE);
}

void tms_ReserveConfigReply_finalize_ex(
    tms_ReserveConfigReply* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ReserveConfigReply_finalize_w_params(
        sample,&deallocParams);
}

void tms_ReserveConfigReply_finalize_w_params(
    tms_ReserveConfigReply* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->relatedRequestId,deallocParams);

    tms_ReplyStatus_finalize_w_params(&sample->status,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->releaseId,deallocParams);

}

void tms_ReserveConfigReply_finalize_optional_members(
    tms_ReserveConfigReply* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ReserveConfigReply_copy(
    tms_ReserveConfigReply* dst,
    const tms_ReserveConfigReply* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->relatedRequestId,(const tms_SampleId*)&src->relatedRequestId)) {
            return RTI_FALSE;
        } 
        if (!tms_ReplyStatus_copy(
            &dst->status,(const tms_ReplyStatus*)&src->status)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->tmp, &src->tmp)) { 
            return RTI_FALSE;
        }
        if (!tms_Fingerprint_copy(
            &dst->releaseId,(const tms_Fingerprint*)&src->releaseId)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ReserveConfigReply' sequence class.
*/
#define T tms_ReserveConfigReply
#define TSeq tms_ReserveConfigReplySeq

#define T_initialize_w_params tms_ReserveConfigReply_initialize_w_params

#define T_finalize_w_params   tms_ReserveConfigReply_finalize_w_params
#define T_copy       tms_ReserveConfigReply_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ReleaseConfigRequestTYPENAME = "tms::ReleaseConfigRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ReleaseConfigRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ReleaseConfigRequest_g_tc_members[3]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"tmp",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ReleaseConfigRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ReleaseConfigRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_ReleaseConfigRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ReleaseConfigRequest*/

    if (is_initialized) {
        return &tms_ReleaseConfigRequest_g_tc;
    }

    tms_ReleaseConfigRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ReleaseConfigRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_ReleaseConfigRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ReleaseConfigRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();

    /* Initialize the values for member annotations. */

    tms_ReleaseConfigRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_ReleaseConfigRequest_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_ReleaseConfigRequest_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_ReleaseConfigRequest_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_ReleaseConfigRequest_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_ReleaseConfigRequest_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_ReleaseConfigRequest_g_tc._data._sampleAccessInfo =
    tms_ReleaseConfigRequest_get_sample_access_info();
    tms_ReleaseConfigRequest_g_tc._data._typePlugin =
    tms_ReleaseConfigRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ReleaseConfigRequest_g_tc;
}

#define TSeq tms_ReleaseConfigRequestSeq
#define T tms_ReleaseConfigRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ReleaseConfigRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ReleaseConfigRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ReleaseConfigRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ReleaseConfigRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ReleaseConfigRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ReleaseConfigRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ReleaseConfigRequest *sample;

    static RTIXCdrMemberAccessInfo tms_ReleaseConfigRequest_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ReleaseConfigRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ReleaseConfigRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ReleaseConfigRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_ReleaseConfigRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_ReleaseConfigRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_ReleaseConfigRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->tmp - (char *)sample);

    tms_ReleaseConfigRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_ReleaseConfigRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ReleaseConfigRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ReleaseConfigRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ReleaseConfigRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ReleaseConfigRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ReleaseConfigRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ReleaseConfigRequest_get_member_value_pointer;

    tms_ReleaseConfigRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ReleaseConfigRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ReleaseConfigRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ReleaseConfigRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ReleaseConfigRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ReleaseConfigRequest_finalize_w_return,
        NULL
    };

    return &tms_ReleaseConfigRequest_g_typePlugin;
}
#endif

RTIBool tms_ReleaseConfigRequest_initialize(
    tms_ReleaseConfigRequest* sample) {
    return tms_ReleaseConfigRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ReleaseConfigRequest_initialize_ex(
    tms_ReleaseConfigRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ReleaseConfigRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ReleaseConfigRequest_initialize_w_params(
    tms_ReleaseConfigRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->tmp = 0;

    return RTI_TRUE;
}

RTIBool tms_ReleaseConfigRequest_finalize_w_return(
    tms_ReleaseConfigRequest* sample)
{
    tms_ReleaseConfigRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ReleaseConfigRequest_finalize(
    tms_ReleaseConfigRequest* sample)
{

    tms_ReleaseConfigRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_ReleaseConfigRequest_finalize_ex(
    tms_ReleaseConfigRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ReleaseConfigRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_ReleaseConfigRequest_finalize_w_params(
    tms_ReleaseConfigRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_ReleaseConfigRequest_finalize_optional_members(
    tms_ReleaseConfigRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ReleaseConfigRequest_copy(
    tms_ReleaseConfigRequest* dst,
    const tms_ReleaseConfigRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->tmp, &src->tmp)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ReleaseConfigRequest' sequence class.
*/
#define T tms_ReleaseConfigRequest
#define TSeq tms_ReleaseConfigRequestSeq

#define T_initialize_w_params tms_ReleaseConfigRequest_initialize_w_params

#define T_finalize_w_params   tms_ReleaseConfigRequest_finalize_w_params
#define T_copy       tms_ReleaseConfigRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ConfigReservationTYPENAME = "tms::ConfigReservation";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ConfigReservation_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ConfigReservation_g_tc_members[2]=
    {

        {
            (char *)"config",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ConfigReservation_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ConfigReservation", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_ConfigReservation_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ConfigReservation*/

    if (is_initialized) {
        return &tms_ConfigReservation_g_tc;
    }

    tms_ConfigReservation_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ConfigReservation_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_ConfigReservation_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();

    /* Initialize the values for member annotations. */
    tms_ConfigReservation_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_ConfigReservation_g_tc_members[0]._annotations._defaultValue._u.ushort_value = 0;
    tms_ConfigReservation_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_ConfigReservation_g_tc_members[0]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_ConfigReservation_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_ConfigReservation_g_tc_members[0]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_ConfigReservation_g_tc._data._sampleAccessInfo =
    tms_ConfigReservation_get_sample_access_info();
    tms_ConfigReservation_g_tc._data._typePlugin =
    tms_ConfigReservation_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ConfigReservation_g_tc;
}

#define TSeq tms_ConfigReservationSeq
#define T tms_ConfigReservation
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ConfigReservation_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ConfigReservation_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ConfigReservationSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ConfigReservationSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ConfigReservation_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ConfigReservation_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ConfigReservation *sample;

    static RTIXCdrMemberAccessInfo tms_ConfigReservation_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ConfigReservation_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ConfigReservation_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ConfigReservation);
    if (sample == NULL) {
        return NULL;
    }

    tms_ConfigReservation_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_ConfigReservation_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_ConfigReservation_g_sampleAccessInfo.memberAccessInfos = 
    tms_ConfigReservation_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ConfigReservation);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ConfigReservation_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ConfigReservation_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ConfigReservation_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ConfigReservation_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ConfigReservation_get_member_value_pointer;

    tms_ConfigReservation_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ConfigReservation_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ConfigReservation_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ConfigReservation_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ConfigReservation_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ConfigReservation_finalize_w_return,
        NULL
    };

    return &tms_ConfigReservation_g_typePlugin;
}
#endif

RTIBool tms_ConfigReservation_initialize(
    tms_ConfigReservation* sample) {
    return tms_ConfigReservation_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ConfigReservation_initialize_ex(
    tms_ConfigReservation* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ConfigReservation_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ConfigReservation_initialize_w_params(
    tms_ConfigReservation* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->config = 0;

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_ConfigReservation_finalize_w_return(
    tms_ConfigReservation* sample)
{
    tms_ConfigReservation_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ConfigReservation_finalize(
    tms_ConfigReservation* sample)
{

    tms_ConfigReservation_finalize_ex(sample,RTI_TRUE);
}

void tms_ConfigReservation_finalize_ex(
    tms_ConfigReservation* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ConfigReservation_finalize_w_params(
        sample,&deallocParams);
}

void tms_ConfigReservation_finalize_w_params(
    tms_ConfigReservation* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_ConfigReservation_finalize_optional_members(
    tms_ConfigReservation* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ConfigReservation_copy(
    tms_ConfigReservation* dst,
    const tms_ConfigReservation* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ConfigReservation' sequence class.
*/
#define T tms_ConfigReservation
#define TSeq tms_ConfigReservationSeq

#define T_initialize_w_params tms_ConfigReservation_initialize_w_params

#define T_finalize_w_params   tms_ConfigReservation_finalize_w_params
#define T_copy       tms_ConfigReservation_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ConfigReservationListTYPENAME = "tms::ConfigReservationList";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ConfigReservationList_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_ConfigReservationList_g_tc_configs_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_configs)),NULL);

    static DDS_TypeCode_Member tms_ConfigReservationList_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"configs",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ConfigReservationList_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ConfigReservationList", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_ConfigReservationList_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ConfigReservationList*/

    if (is_initialized) {
        return &tms_ConfigReservationList_g_tc;
    }

    tms_ConfigReservationList_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ConfigReservationList_g_tc_configs_sequence._data._typeCode = (RTICdrTypeCode *)tms_ConfigReservation_get_typecode();
    tms_ConfigReservationList_g_tc_configs_sequence._data._sampleAccessInfo = tms_ConfigReservation_get_sample_seq_access_info();
    tms_ConfigReservationList_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ConfigReservationList_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_ConfigReservationList_g_tc_configs_sequence;

    /* Initialize the values for member annotations. */

    tms_ConfigReservationList_g_tc._data._sampleAccessInfo =
    tms_ConfigReservationList_get_sample_access_info();
    tms_ConfigReservationList_g_tc._data._typePlugin =
    tms_ConfigReservationList_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ConfigReservationList_g_tc;
}

#define TSeq tms_ConfigReservationListSeq
#define T tms_ConfigReservationList
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ConfigReservationList_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ConfigReservationList_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ConfigReservationListSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ConfigReservationListSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ConfigReservationList_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ConfigReservationList_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ConfigReservationList *sample;

    static RTIXCdrMemberAccessInfo tms_ConfigReservationList_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ConfigReservationList_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ConfigReservationList_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ConfigReservationList);
    if (sample == NULL) {
        return NULL;
    }

    tms_ConfigReservationList_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_ConfigReservationList_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->configs - (char *)sample);

    tms_ConfigReservationList_g_sampleAccessInfo.memberAccessInfos = 
    tms_ConfigReservationList_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ConfigReservationList);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ConfigReservationList_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ConfigReservationList_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ConfigReservationList_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ConfigReservationList_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ConfigReservationList_get_member_value_pointer;

    tms_ConfigReservationList_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ConfigReservationList_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ConfigReservationList_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ConfigReservationList_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ConfigReservationList_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ConfigReservationList_finalize_w_return,
        NULL
    };

    return &tms_ConfigReservationList_g_typePlugin;
}
#endif

RTIBool tms_ConfigReservationList_initialize(
    tms_ConfigReservationList* sample) {
    return tms_ConfigReservationList_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ConfigReservationList_initialize_ex(
    tms_ConfigReservationList* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ConfigReservationList_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ConfigReservationList_initialize_w_params(
    tms_ConfigReservationList* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_ConfigReservationSeq_initialize(&sample->configs )){
            return RTI_FALSE;
        };
        if(!tms_ConfigReservationSeq_set_element_allocation_params(&sample->configs ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_ConfigReservationSeq_set_absolute_maximum(&sample->configs , ((tms_MAXLEN_configs)))){
            return RTI_FALSE;
        }
        if (!tms_ConfigReservationSeq_set_maximum(&sample->configs, ((tms_MAXLEN_configs)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_ConfigReservationSeq_set_length(&sample->configs, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_ConfigReservationList_finalize_w_return(
    tms_ConfigReservationList* sample)
{
    tms_ConfigReservationList_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ConfigReservationList_finalize(
    tms_ConfigReservationList* sample)
{

    tms_ConfigReservationList_finalize_ex(sample,RTI_TRUE);
}

void tms_ConfigReservationList_finalize_ex(
    tms_ConfigReservationList* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ConfigReservationList_finalize_w_params(
        sample,&deallocParams);
}

void tms_ConfigReservationList_finalize_w_params(
    tms_ConfigReservationList* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_ConfigReservationSeq_set_element_deallocation_params(
        &sample->configs,deallocParams)){
        return; 
    }
    if(!tms_ConfigReservationSeq_finalize(&sample->configs)){
        return;
    }

}

void tms_ConfigReservationList_finalize_optional_members(
    tms_ConfigReservationList* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ConfigReservationList_copy(
    tms_ConfigReservationList* dst,
    const tms_ConfigReservationList* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_ConfigReservationSeq_copy(&dst->configs ,
        &src->configs )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ConfigReservationList' sequence class.
*/
#define T tms_ConfigReservationList
#define TSeq tms_ConfigReservationListSeq

#define T_initialize_w_params tms_ConfigReservationList_initialize_w_params

#define T_finalize_w_params   tms_ConfigReservationList_finalize_w_params
#define T_copy       tms_ConfigReservationList_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_GetConfigContentsRequestTYPENAME = "tms::GetConfigContentsRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GetConfigContentsRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_GetConfigContentsRequest_g_tc_members[3]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_GetConfigContentsRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::GetConfigContentsRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_GetConfigContentsRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_GetConfigContentsRequest*/

    if (is_initialized) {
        return &tms_GetConfigContentsRequest_g_tc;
    }

    tms_GetConfigContentsRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_GetConfigContentsRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_GetConfigContentsRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_GetConfigContentsRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();

    /* Initialize the values for member annotations. */

    tms_GetConfigContentsRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_GetConfigContentsRequest_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_GetConfigContentsRequest_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_GetConfigContentsRequest_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_GetConfigContentsRequest_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_GetConfigContentsRequest_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_GetConfigContentsRequest_g_tc._data._sampleAccessInfo =
    tms_GetConfigContentsRequest_get_sample_access_info();
    tms_GetConfigContentsRequest_g_tc._data._typePlugin =
    tms_GetConfigContentsRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GetConfigContentsRequest_g_tc;
}

#define TSeq tms_GetConfigContentsRequestSeq
#define T tms_GetConfigContentsRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GetConfigContentsRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GetConfigContentsRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GetConfigContentsRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GetConfigContentsRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GetConfigContentsRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GetConfigContentsRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_GetConfigContentsRequest *sample;

    static RTIXCdrMemberAccessInfo tms_GetConfigContentsRequest_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GetConfigContentsRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GetConfigContentsRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_GetConfigContentsRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_GetConfigContentsRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_GetConfigContentsRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_GetConfigContentsRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_GetConfigContentsRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_GetConfigContentsRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GetConfigContentsRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GetConfigContentsRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GetConfigContentsRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GetConfigContentsRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GetConfigContentsRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GetConfigContentsRequest_get_member_value_pointer;

    tms_GetConfigContentsRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GetConfigContentsRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GetConfigContentsRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GetConfigContentsRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GetConfigContentsRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GetConfigContentsRequest_finalize_w_return,
        NULL
    };

    return &tms_GetConfigContentsRequest_g_typePlugin;
}
#endif

RTIBool tms_GetConfigContentsRequest_initialize(
    tms_GetConfigContentsRequest* sample) {
    return tms_GetConfigContentsRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_GetConfigContentsRequest_initialize_ex(
    tms_GetConfigContentsRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GetConfigContentsRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GetConfigContentsRequest_initialize_w_params(
    tms_GetConfigContentsRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    return RTI_TRUE;
}

RTIBool tms_GetConfigContentsRequest_finalize_w_return(
    tms_GetConfigContentsRequest* sample)
{
    tms_GetConfigContentsRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_GetConfigContentsRequest_finalize(
    tms_GetConfigContentsRequest* sample)
{

    tms_GetConfigContentsRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_GetConfigContentsRequest_finalize_ex(
    tms_GetConfigContentsRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GetConfigContentsRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_GetConfigContentsRequest_finalize_w_params(
    tms_GetConfigContentsRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_GetConfigContentsRequest_finalize_optional_members(
    tms_GetConfigContentsRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GetConfigContentsRequest_copy(
    tms_GetConfigContentsRequest* dst,
    const tms_GetConfigContentsRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GetConfigContentsRequest' sequence class.
*/
#define T tms_GetConfigContentsRequest
#define TSeq tms_GetConfigContentsRequestSeq

#define T_initialize_w_params tms_GetConfigContentsRequest_initialize_w_params

#define T_finalize_w_params   tms_GetConfigContentsRequest_finalize_w_params
#define T_copy       tms_GetConfigContentsRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortNumber_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_PowerPortNumber_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::PowerPortNumber", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_PowerPortNumber */

    if (is_initialized) {
        return &tms_PowerPortNumber_g_tc;
    }

    tms_PowerPortNumber_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortNumber_g_tc._data._typeCode =  (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;

    /* Initialize the values for member annotations. */
    tms_PowerPortNumber_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortNumber_g_tc._data._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortNumber_g_tc._data._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortNumber_g_tc._data._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortNumber_g_tc._data._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortNumber_g_tc._data._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortNumber_g_tc._data._sampleAccessInfo =
    tms_PowerPortNumber_get_sample_access_info();
    tms_PowerPortNumber_g_tc._data._typePlugin =
    tms_PowerPortNumber_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortNumber_g_tc;
}

#define TSeq tms_PowerPortNumberSeq
#define T tms_PowerPortNumber
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortNumber_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortNumber_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortNumberSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortNumberSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortNumber_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortNumber_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerPortNumber_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortNumber_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortNumber_g_sampleAccessInfo;
    }

    tms_PowerPortNumber_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerPortNumber_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortNumber_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortNumber);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortNumber_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortNumber_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortNumber_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortNumber_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortNumber_get_member_value_pointer;

    tms_PowerPortNumber_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortNumber_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortNumber_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortNumber_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortNumber_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortNumber_finalize_w_return,
        NULL
    };

    return &tms_PowerPortNumber_g_typePlugin;
}
#endif

RTIBool tms_PowerPortNumber_initialize(
    tms_PowerPortNumber* sample) {
    return tms_PowerPortNumber_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortNumber_initialize_ex(
    tms_PowerPortNumber* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortNumber_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortNumber_initialize_w_params(
    tms_PowerPortNumber* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    (*sample) = 0u;

    return RTI_TRUE;
}

RTIBool tms_PowerPortNumber_finalize_w_return(
    tms_PowerPortNumber* sample)
{
    tms_PowerPortNumber_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortNumber_finalize(
    tms_PowerPortNumber* sample)
{

    tms_PowerPortNumber_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortNumber_finalize_ex(
    tms_PowerPortNumber* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortNumber_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortNumber_finalize_w_params(
    tms_PowerPortNumber* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerPortNumber_finalize_optional_members(
    tms_PowerPortNumber* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortNumber_copy(
    tms_PowerPortNumber* dst,
    const tms_PowerPortNumber* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            dst, src)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortNumber' sequence class.
*/
#define T tms_PowerPortNumber
#define TSeq tms_PowerPortNumberSeq

#define T_initialize_w_params tms_PowerPortNumber_initialize_w_params

#define T_finalize_w_params   tms_PowerPortNumber_finalize_w_params
#define T_copy       tms_PowerPortNumber_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_AuthorizationToEnergizeRequestTYPENAME = "tms::AuthorizationToEnergizeRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_AuthorizationToEnergizeRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_AuthorizationToEnergizeRequest_g_tc_ports_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_ports)),NULL);

    static DDS_TypeCode_Member tms_AuthorizationToEnergizeRequest_g_tc_members[4]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"commandId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ports",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_AuthorizationToEnergizeRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::AuthorizationToEnergizeRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_AuthorizationToEnergizeRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_AuthorizationToEnergizeRequest*/

    if (is_initialized) {
        return &tms_AuthorizationToEnergizeRequest_g_tc;
    }

    tms_AuthorizationToEnergizeRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_AuthorizationToEnergizeRequest_g_tc_ports_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_AuthorizationToEnergizeRequest_g_tc_ports_sequence._data._sampleAccessInfo = tms_PowerPortNumber_get_sample_seq_access_info();
    tms_AuthorizationToEnergizeRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_AuthorizationToEnergizeRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_AuthorizationToEnergizeRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_AuthorizationToEnergizeRequest_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_AuthorizationToEnergizeRequest_g_tc_ports_sequence;

    /* Initialize the values for member annotations. */

    tms_AuthorizationToEnergizeRequest_g_tc._data._sampleAccessInfo =
    tms_AuthorizationToEnergizeRequest_get_sample_access_info();
    tms_AuthorizationToEnergizeRequest_g_tc._data._typePlugin =
    tms_AuthorizationToEnergizeRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_AuthorizationToEnergizeRequest_g_tc;
}

#define TSeq tms_AuthorizationToEnergizeRequestSeq
#define T tms_AuthorizationToEnergizeRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_AuthorizationToEnergizeRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_AuthorizationToEnergizeRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_AuthorizationToEnergizeRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_AuthorizationToEnergizeRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_AuthorizationToEnergizeRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_AuthorizationToEnergizeRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_AuthorizationToEnergizeRequest *sample;

    static RTIXCdrMemberAccessInfo tms_AuthorizationToEnergizeRequest_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_AuthorizationToEnergizeRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_AuthorizationToEnergizeRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_AuthorizationToEnergizeRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->commandId - (char *)sample);

    tms_AuthorizationToEnergizeRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_AuthorizationToEnergizeRequest_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->ports - (char *)sample);

    tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_AuthorizationToEnergizeRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_AuthorizationToEnergizeRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_AuthorizationToEnergizeRequest_get_member_value_pointer;

    tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_AuthorizationToEnergizeRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_AuthorizationToEnergizeRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_AuthorizationToEnergizeRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_AuthorizationToEnergizeRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_AuthorizationToEnergizeRequest_finalize_w_return,
        NULL
    };

    return &tms_AuthorizationToEnergizeRequest_g_typePlugin;
}
#endif

RTIBool tms_AuthorizationToEnergizeRequest_initialize(
    tms_AuthorizationToEnergizeRequest* sample) {
    return tms_AuthorizationToEnergizeRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_AuthorizationToEnergizeRequest_initialize_ex(
    tms_AuthorizationToEnergizeRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_AuthorizationToEnergizeRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_AuthorizationToEnergizeRequest_initialize_w_params(
    tms_AuthorizationToEnergizeRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_SampleId_initialize_w_params(&sample->commandId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!DDS_UnsignedLongSeq_initialize(&sample->ports  )){
            return RTI_FALSE;
        }
        if(!DDS_UnsignedLongSeq_set_absolute_maximum(&sample->ports , ((tms_MAXLEN_ports)))){
            return RTI_FALSE;
        }
        if (!DDS_UnsignedLongSeq_set_maximum(&sample->ports , ((tms_MAXLEN_ports)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!DDS_UnsignedLongSeq_set_length(&sample->ports, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_AuthorizationToEnergizeRequest_finalize_w_return(
    tms_AuthorizationToEnergizeRequest* sample)
{
    tms_AuthorizationToEnergizeRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_AuthorizationToEnergizeRequest_finalize(
    tms_AuthorizationToEnergizeRequest* sample)
{

    tms_AuthorizationToEnergizeRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_AuthorizationToEnergizeRequest_finalize_ex(
    tms_AuthorizationToEnergizeRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_AuthorizationToEnergizeRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_AuthorizationToEnergizeRequest_finalize_w_params(
    tms_AuthorizationToEnergizeRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_SampleId_finalize_w_params(&sample->commandId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!DDS_UnsignedLongSeq_finalize(&sample->ports)){
        return;
    }

}

void tms_AuthorizationToEnergizeRequest_finalize_optional_members(
    tms_AuthorizationToEnergizeRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_AuthorizationToEnergizeRequest_copy(
    tms_AuthorizationToEnergizeRequest* dst,
    const tms_AuthorizationToEnergizeRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_SampleId_copy(
            &dst->commandId,(const tms_SampleId*)&src->commandId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!DDS_UnsignedLongSeq_copy(&dst->ports ,
        &src->ports )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_AuthorizationToEnergizeRequest' sequence class.
*/
#define T tms_AuthorizationToEnergizeRequest
#define TSeq tms_AuthorizationToEnergizeRequestSeq

#define T_initialize_w_params tms_AuthorizationToEnergizeRequest_initialize_w_params

#define T_finalize_w_params   tms_AuthorizationToEnergizeRequest_finalize_w_params
#define T_copy       tms_AuthorizationToEnergizeRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_AuthorizationToEnergizeResponseTYPENAME = "tms::AuthorizationToEnergizeResponse";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_AuthorizationToEnergizeResponse_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_AuthorizationToEnergizeResponse_g_tc_ports_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_ports)),NULL);

    static DDS_TypeCode_Member tms_AuthorizationToEnergizeResponse_g_tc_members[8]=
    {

        {
            (char *)"relatedRequestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"commandId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ports",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"accept",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deny",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"userId",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authorizationTime",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_AuthorizationToEnergizeResponse_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::AuthorizationToEnergizeResponse", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            8, /* Number of members */
            tms_AuthorizationToEnergizeResponse_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_AuthorizationToEnergizeResponse*/

    if (is_initialized) {
        return &tms_AuthorizationToEnergizeResponse_g_tc;
    }

    tms_AuthorizationToEnergizeResponse_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_AuthorizationToEnergizeResponse_g_tc_ports_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_AuthorizationToEnergizeResponse_g_tc_ports_sequence._data._sampleAccessInfo = tms_PowerPortNumber_get_sample_seq_access_info();
    tms_AuthorizationToEnergizeResponse_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_AuthorizationToEnergizeResponse_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_AuthorizationToEnergizeResponse_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_AuthorizationToEnergizeResponse_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_AuthorizationToEnergizeResponse_g_tc_ports_sequence;
    tms_AuthorizationToEnergizeResponse_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeResponse_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeResponse_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_AuthorizationToEnergizeResponse_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)tms_ClockRealtime_get_typecode();

    /* Initialize the values for member annotations. */

    tms_AuthorizationToEnergizeResponse_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeResponse_g_tc_members[4]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeResponse_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeResponse_g_tc_members[5]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeResponse_g_tc._data._sampleAccessInfo =
    tms_AuthorizationToEnergizeResponse_get_sample_access_info();
    tms_AuthorizationToEnergizeResponse_g_tc._data._typePlugin =
    tms_AuthorizationToEnergizeResponse_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_AuthorizationToEnergizeResponse_g_tc;
}

#define TSeq tms_AuthorizationToEnergizeResponseSeq
#define T tms_AuthorizationToEnergizeResponse
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_AuthorizationToEnergizeResponse_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_AuthorizationToEnergizeResponse_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_AuthorizationToEnergizeResponseSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_AuthorizationToEnergizeResponseSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_AuthorizationToEnergizeResponse_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_AuthorizationToEnergizeResponse_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_AuthorizationToEnergizeResponse *sample;

    static RTIXCdrMemberAccessInfo tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[8] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_AuthorizationToEnergizeResponse);
    if (sample == NULL) {
        return NULL;
    }

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->relatedRequestId - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->commandId - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->ports - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->accept - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deny - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->userId - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authorizationTime - (char *)sample);

    tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo.memberAccessInfos = 
    tms_AuthorizationToEnergizeResponse_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_AuthorizationToEnergizeResponse);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_AuthorizationToEnergizeResponse_get_member_value_pointer;

    tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_AuthorizationToEnergizeResponse_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_AuthorizationToEnergizeResponse_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_AuthorizationToEnergizeResponse_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_AuthorizationToEnergizeResponse_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_AuthorizationToEnergizeResponse_finalize_w_return,
        NULL
    };

    return &tms_AuthorizationToEnergizeResponse_g_typePlugin;
}
#endif

RTIBool tms_AuthorizationToEnergizeResponse_initialize(
    tms_AuthorizationToEnergizeResponse* sample) {
    return tms_AuthorizationToEnergizeResponse_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_AuthorizationToEnergizeResponse_initialize_ex(
    tms_AuthorizationToEnergizeResponse* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_AuthorizationToEnergizeResponse_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_AuthorizationToEnergizeResponse_initialize_w_params(
    tms_AuthorizationToEnergizeResponse* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->relatedRequestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_SampleId_initialize_w_params(&sample->commandId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!DDS_UnsignedLongSeq_initialize(&sample->ports  )){
            return RTI_FALSE;
        }
        if(!DDS_UnsignedLongSeq_set_absolute_maximum(&sample->ports , ((tms_MAXLEN_ports)))){
            return RTI_FALSE;
        }
        if (!DDS_UnsignedLongSeq_set_maximum(&sample->ports , ((tms_MAXLEN_ports)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!DDS_UnsignedLongSeq_set_length(&sample->ports, 0)){
            return RTI_FALSE;
        }    
    }

    sample->accept = 0;

    sample->deny = 0;

    if (!tms_Fingerprint_initialize_w_params(&sample->userId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockRealtime_initialize_w_params(&sample->authorizationTime,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_AuthorizationToEnergizeResponse_finalize_w_return(
    tms_AuthorizationToEnergizeResponse* sample)
{
    tms_AuthorizationToEnergizeResponse_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_AuthorizationToEnergizeResponse_finalize(
    tms_AuthorizationToEnergizeResponse* sample)
{

    tms_AuthorizationToEnergizeResponse_finalize_ex(sample,RTI_TRUE);
}

void tms_AuthorizationToEnergizeResponse_finalize_ex(
    tms_AuthorizationToEnergizeResponse* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_AuthorizationToEnergizeResponse_finalize_w_params(
        sample,&deallocParams);
}

void tms_AuthorizationToEnergizeResponse_finalize_w_params(
    tms_AuthorizationToEnergizeResponse* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->relatedRequestId,deallocParams);

    tms_SampleId_finalize_w_params(&sample->commandId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!DDS_UnsignedLongSeq_finalize(&sample->ports)){
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->userId,deallocParams);

    tms_ClockRealtime_finalize_w_params(&sample->authorizationTime,deallocParams);

}

void tms_AuthorizationToEnergizeResponse_finalize_optional_members(
    tms_AuthorizationToEnergizeResponse* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_AuthorizationToEnergizeResponse_copy(
    tms_AuthorizationToEnergizeResponse* dst,
    const tms_AuthorizationToEnergizeResponse* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->relatedRequestId,(const tms_SampleId*)&src->relatedRequestId)) {
            return RTI_FALSE;
        } 
        if (!tms_SampleId_copy(
            &dst->commandId,(const tms_SampleId*)&src->commandId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!DDS_UnsignedLongSeq_copy(&dst->ports ,
        &src->ports )) {
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->accept, &src->accept)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->deny, &src->deny)) { 
            return RTI_FALSE;
        }
        if (!tms_Fingerprint_copy(
            &dst->userId,(const tms_Fingerprint*)&src->userId)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockRealtime_copy(
            &dst->authorizationTime,(const tms_ClockRealtime*)&src->authorizationTime)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_AuthorizationToEnergizeResponse' sequence class.
*/
#define T tms_AuthorizationToEnergizeResponse
#define TSeq tms_AuthorizationToEnergizeResponseSeq

#define T_initialize_w_params tms_AuthorizationToEnergizeResponse_initialize_w_params

#define T_finalize_w_params   tms_AuthorizationToEnergizeResponse_finalize_w_params
#define T_copy       tms_AuthorizationToEnergizeResponse_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_AuthorizationToEnergizeOutcomeTYPENAME = "tms::AuthorizationToEnergizeOutcome";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_AuthorizationToEnergizeOutcome_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_AuthorizationToEnergizeOutcome_g_tc_members[11]=
    {

        {
            (char *)"relatedRequestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"commandId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"accepted",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authReceived",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authCommand",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authLocation",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authUser",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authTime",/* Member name */
            {
                8,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authMonotonic",/* Member name */
            {
                9,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"authRealtime",/* Member name */
            {
                10,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_AuthorizationToEnergizeOutcome_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::AuthorizationToEnergizeOutcome", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            11, /* Number of members */
            tms_AuthorizationToEnergizeOutcome_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_AuthorizationToEnergizeOutcome*/

    if (is_initialized) {
        return &tms_AuthorizationToEnergizeOutcome_g_tc;
    }

    tms_AuthorizationToEnergizeOutcome_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_AuthorizationToEnergizeOutcome_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_AuthorizationToEnergizeOutcome_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_AuthorizationToEnergizeOutcome_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_AuthorizationToEnergizeOutcome_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[8]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[9]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_AuthorizationToEnergizeOutcome_g_tc_members[10]._representation._typeCode = (RTICdrTypeCode *)tms_ClockRealtime_get_typecode();

    /* Initialize the values for member annotations. */

    tms_AuthorizationToEnergizeOutcome_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[3]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeOutcome_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[4]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeOutcome_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[5]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeOutcome_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[6]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeOutcome_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[7]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeOutcome_g_tc_members[8]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_AuthorizationToEnergizeOutcome_g_tc_members[8]._annotations._defaultValue._u.boolean_value = 0;

    tms_AuthorizationToEnergizeOutcome_g_tc._data._sampleAccessInfo =
    tms_AuthorizationToEnergizeOutcome_get_sample_access_info();
    tms_AuthorizationToEnergizeOutcome_g_tc._data._typePlugin =
    tms_AuthorizationToEnergizeOutcome_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_AuthorizationToEnergizeOutcome_g_tc;
}

#define TSeq tms_AuthorizationToEnergizeOutcomeSeq
#define T tms_AuthorizationToEnergizeOutcome
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_AuthorizationToEnergizeOutcome_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_AuthorizationToEnergizeOutcome_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_AuthorizationToEnergizeOutcomeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_AuthorizationToEnergizeOutcomeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_AuthorizationToEnergizeOutcome_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_AuthorizationToEnergizeOutcome_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_AuthorizationToEnergizeOutcome *sample;

    static RTIXCdrMemberAccessInfo tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[11] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_AuthorizationToEnergizeOutcome);
    if (sample == NULL) {
        return NULL;
    }

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->relatedRequestId - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->commandId - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->accepted - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authReceived - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authCommand - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authLocation - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authUser - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[8].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authTime - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[9].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authMonotonic - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos[10].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->authRealtime - (char *)sample);

    tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo.memberAccessInfos = 
    tms_AuthorizationToEnergizeOutcome_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_AuthorizationToEnergizeOutcome);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_AuthorizationToEnergizeOutcome_get_member_value_pointer;

    tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_AuthorizationToEnergizeOutcome_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_AuthorizationToEnergizeOutcome_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_AuthorizationToEnergizeOutcome_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_AuthorizationToEnergizeOutcome_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_AuthorizationToEnergizeOutcome_finalize_w_return,
        NULL
    };

    return &tms_AuthorizationToEnergizeOutcome_g_typePlugin;
}
#endif

RTIBool tms_AuthorizationToEnergizeOutcome_initialize(
    tms_AuthorizationToEnergizeOutcome* sample) {
    return tms_AuthorizationToEnergizeOutcome_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_AuthorizationToEnergizeOutcome_initialize_ex(
    tms_AuthorizationToEnergizeOutcome* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_AuthorizationToEnergizeOutcome_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_AuthorizationToEnergizeOutcome_initialize_w_params(
    tms_AuthorizationToEnergizeOutcome* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->relatedRequestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_SampleId_initialize_w_params(&sample->commandId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->accepted = 0;

    sample->authReceived = 0;

    sample->authCommand = 0;

    sample->authLocation = 0;

    sample->authUser = 0;

    sample->authTime = 0;

    if (!tms_ClockMonotonic_initialize_w_params(&sample->authMonotonic,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockRealtime_initialize_w_params(&sample->authRealtime,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_AuthorizationToEnergizeOutcome_finalize_w_return(
    tms_AuthorizationToEnergizeOutcome* sample)
{
    tms_AuthorizationToEnergizeOutcome_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_AuthorizationToEnergizeOutcome_finalize(
    tms_AuthorizationToEnergizeOutcome* sample)
{

    tms_AuthorizationToEnergizeOutcome_finalize_ex(sample,RTI_TRUE);
}

void tms_AuthorizationToEnergizeOutcome_finalize_ex(
    tms_AuthorizationToEnergizeOutcome* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_AuthorizationToEnergizeOutcome_finalize_w_params(
        sample,&deallocParams);
}

void tms_AuthorizationToEnergizeOutcome_finalize_w_params(
    tms_AuthorizationToEnergizeOutcome* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->relatedRequestId,deallocParams);

    tms_SampleId_finalize_w_params(&sample->commandId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->authMonotonic,deallocParams);

    tms_ClockRealtime_finalize_w_params(&sample->authRealtime,deallocParams);

}

void tms_AuthorizationToEnergizeOutcome_finalize_optional_members(
    tms_AuthorizationToEnergizeOutcome* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_AuthorizationToEnergizeOutcome_copy(
    tms_AuthorizationToEnergizeOutcome* dst,
    const tms_AuthorizationToEnergizeOutcome* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->relatedRequestId,(const tms_SampleId*)&src->relatedRequestId)) {
            return RTI_FALSE;
        } 
        if (!tms_SampleId_copy(
            &dst->commandId,(const tms_SampleId*)&src->commandId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyBoolean (
            &dst->accepted, &src->accepted)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->authReceived, &src->authReceived)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->authCommand, &src->authCommand)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->authLocation, &src->authLocation)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->authUser, &src->authUser)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->authTime, &src->authTime)) { 
            return RTI_FALSE;
        }
        if (!tms_ClockMonotonic_copy(
            &dst->authMonotonic,(const tms_ClockMonotonic*)&src->authMonotonic)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockRealtime_copy(
            &dst->authRealtime,(const tms_ClockRealtime*)&src->authRealtime)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_AuthorizationToEnergizeOutcome' sequence class.
*/
#define T tms_AuthorizationToEnergizeOutcome
#define TSeq tms_AuthorizationToEnergizeOutcomeSeq

#define T_initialize_w_params tms_AuthorizationToEnergizeOutcome_initialize_w_params

#define T_finalize_w_params   tms_AuthorizationToEnergizeOutcome_finalize_w_params
#define T_copy       tms_AuthorizationToEnergizeOutcome_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerPortIdTYPENAME = "tms::PowerPortId";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortId_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerPortId_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"portNumber",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerPortId_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerPortId", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_PowerPortId_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerPortId*/

    if (is_initialized) {
        return &tms_PowerPortId_g_tc;
    }

    tms_PowerPortId_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortId_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_PowerPortId_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();

    /* Initialize the values for member annotations. */

    tms_PowerPortId_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortId_g_tc_members[1]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortId_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortId_g_tc_members[1]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortId_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortId_g_tc_members[1]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortId_g_tc._data._sampleAccessInfo =
    tms_PowerPortId_get_sample_access_info();
    tms_PowerPortId_g_tc._data._typePlugin =
    tms_PowerPortId_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortId_g_tc;
}

#define TSeq tms_PowerPortIdSeq
#define T tms_PowerPortId
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortId_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortId_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortIdSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortIdSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortId_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortId_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerPortId *sample;

    static RTIXCdrMemberAccessInfo tms_PowerPortId_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortId_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortId_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerPortId);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerPortId_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_PowerPortId_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerPortId_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortId_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortId);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortId_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortId_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortId_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortId_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortId_get_member_value_pointer;

    tms_PowerPortId_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortId_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortId_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortId_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortId_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortId_finalize_w_return,
        NULL
    };

    return &tms_PowerPortId_g_typePlugin;
}
#endif

RTIBool tms_PowerPortId_initialize(
    tms_PowerPortId* sample) {
    return tms_PowerPortId_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortId_initialize_ex(
    tms_PowerPortId* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortId_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortId_initialize_w_params(
    tms_PowerPortId* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    return RTI_TRUE;
}

RTIBool tms_PowerPortId_finalize_w_return(
    tms_PowerPortId* sample)
{
    tms_PowerPortId_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortId_finalize(
    tms_PowerPortId* sample)
{

    tms_PowerPortId_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortId_finalize_ex(
    tms_PowerPortId* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortId_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortId_finalize_w_params(
    tms_PowerPortId* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_PowerPortId_finalize_optional_members(
    tms_PowerPortId* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortId_copy(
    tms_PowerPortId* dst,
    const tms_PowerPortId* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortId' sequence class.
*/
#define T tms_PowerPortId
#define TSeq tms_PowerPortIdSeq

#define T_initialize_w_params tms_PowerPortId_initialize_w_params

#define T_finalize_w_params   tms_PowerPortId_finalize_w_params
#define T_copy       tms_PowerPortId_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerConnectionIdTYPENAME = "tms::PowerConnectionId";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerConnectionId_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerConnectionId_g_tc_members[2]=
    {

        {
            (char *)"portA",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"portB",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerConnectionId_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerConnectionId", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_PowerConnectionId_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerConnectionId*/

    if (is_initialized) {
        return &tms_PowerConnectionId_g_tc;
    }

    tms_PowerConnectionId_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerConnectionId_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortId_get_typecode();
    tms_PowerConnectionId_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortId_get_typecode();

    /* Initialize the values for member annotations. */

    tms_PowerConnectionId_g_tc._data._sampleAccessInfo =
    tms_PowerConnectionId_get_sample_access_info();
    tms_PowerConnectionId_g_tc._data._typePlugin =
    tms_PowerConnectionId_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerConnectionId_g_tc;
}

#define TSeq tms_PowerConnectionIdSeq
#define T tms_PowerConnectionId
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerConnectionId_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerConnectionId_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerConnectionIdSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerConnectionIdSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerConnectionId_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerConnectionId_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerConnectionId *sample;

    static RTIXCdrMemberAccessInfo tms_PowerConnectionId_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerConnectionId_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectionId_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerConnectionId);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerConnectionId_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portA - (char *)sample);

    tms_PowerConnectionId_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portB - (char *)sample);

    tms_PowerConnectionId_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerConnectionId_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerConnectionId);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerConnectionId_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerConnectionId_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerConnectionId_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerConnectionId_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerConnectionId_get_member_value_pointer;

    tms_PowerConnectionId_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectionId_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerConnectionId_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerConnectionId_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerConnectionId_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerConnectionId_finalize_w_return,
        NULL
    };

    return &tms_PowerConnectionId_g_typePlugin;
}
#endif

RTIBool tms_PowerConnectionId_initialize(
    tms_PowerConnectionId* sample) {
    return tms_PowerConnectionId_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerConnectionId_initialize_ex(
    tms_PowerConnectionId* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerConnectionId_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerConnectionId_initialize_w_params(
    tms_PowerConnectionId* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_PowerPortId_initialize_w_params(&sample->portA,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_PowerPortId_initialize_w_params(&sample->portB,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_PowerConnectionId_finalize_w_return(
    tms_PowerConnectionId* sample)
{
    tms_PowerConnectionId_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerConnectionId_finalize(
    tms_PowerConnectionId* sample)
{

    tms_PowerConnectionId_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerConnectionId_finalize_ex(
    tms_PowerConnectionId* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerConnectionId_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerConnectionId_finalize_w_params(
    tms_PowerConnectionId* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_PowerPortId_finalize_w_params(&sample->portA,deallocParams);

    tms_PowerPortId_finalize_w_params(&sample->portB,deallocParams);

}

void tms_PowerConnectionId_finalize_optional_members(
    tms_PowerConnectionId* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerConnectionId_copy(
    tms_PowerConnectionId* dst,
    const tms_PowerConnectionId* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_PowerPortId_copy(
            &dst->portA,(const tms_PowerPortId*)&src->portA)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerPortId_copy(
            &dst->portB,(const tms_PowerPortId*)&src->portB)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerConnectionId' sequence class.
*/
#define T tms_PowerConnectionId
#define TSeq tms_PowerConnectionIdSeq

#define T_initialize_w_params tms_PowerConnectionId_initialize_w_params

#define T_finalize_w_params   tms_PowerConnectionId_finalize_w_params
#define T_copy       tms_PowerConnectionId_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_CableSenseTypeTYPENAME = "tms::CableSenseType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_CableSenseType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_CableSenseType_g_tc_members[4]=
    {

        {
            (char *)"CST_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CST_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CST_CONNECTOR",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CST_CONNECTOR, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CST_MEASUREMENT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CST_MEASUREMENT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CST_CONNECTOR_MEASUREMENT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CST_CONNECTOR_MEASUREMENT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_CableSenseType_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::CableSenseType", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_CableSenseType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_CableSenseType*/

    if (is_initialized) {
        return &tms_CableSenseType_g_tc;
    }

    tms_CableSenseType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_CableSenseType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_CableSenseType_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_CableSenseType_g_tc._data._sampleAccessInfo =
    tms_CableSenseType_get_sample_access_info();
    tms_CableSenseType_g_tc._data._typePlugin =
    tms_CableSenseType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_CableSenseType_g_tc;
}

#define TSeq tms_CableSenseTypeSeq
#define T tms_CableSenseType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_CableSenseType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_CableSenseType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_CableSenseTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_CableSenseTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_CableSenseType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_CableSenseType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_CableSenseType_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_CableSenseType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_CableSenseType_g_sampleAccessInfo;
    }

    tms_CableSenseType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_CableSenseType_g_sampleAccessInfo.memberAccessInfos = 
    tms_CableSenseType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_CableSenseType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_CableSenseType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_CableSenseType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_CableSenseType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_CableSenseType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_CableSenseType_get_member_value_pointer;

    tms_CableSenseType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_CableSenseType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_CableSenseType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_CableSenseType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_CableSenseType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_CableSenseType_finalize_w_return,
        NULL
    };

    return &tms_CableSenseType_g_typePlugin;
}
#endif

RTIBool tms_CableSenseType_initialize(
    tms_CableSenseType* sample) {
    *sample = CST_NONE;
    return RTI_TRUE;
}

RTIBool tms_CableSenseType_initialize_ex(
    tms_CableSenseType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_CableSenseType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_CableSenseType_initialize_w_params(
    tms_CableSenseType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = CST_NONE;
    return RTI_TRUE;
}

RTIBool tms_CableSenseType_finalize_w_return(
    tms_CableSenseType* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_CableSenseType_finalize(
    tms_CableSenseType* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_CableSenseType_finalize_ex(
    tms_CableSenseType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_CableSenseType_finalize_w_params(
        sample,&deallocParams);
}

void tms_CableSenseType_finalize_w_params(
    tms_CableSenseType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_CableSenseType_finalize_optional_members(
    tms_CableSenseType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_CableSenseType_copy(
    tms_CableSenseType* dst,
    const tms_CableSenseType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_CableSenseType' sequence class.
*/
#define T tms_CableSenseType
#define TSeq tms_CableSenseTypeSeq

#define T_initialize_w_params tms_CableSenseType_initialize_w_params

#define T_finalize_w_params   tms_CableSenseType_finalize_w_params
#define T_copy       tms_CableSenseType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_CableSenseStatusTYPENAME = "tms::CableSenseStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_CableSenseStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_CableSenseStatus_g_tc_members[3]=
    {

        {
            (char *)"CS_UNKNOWN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CS_UNKNOWN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CS_DISCONNECTED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CS_DISCONNECTED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CS_CONNECTED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CS_CONNECTED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_CableSenseStatus_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::CableSenseStatus", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_CableSenseStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_CableSenseStatus*/

    if (is_initialized) {
        return &tms_CableSenseStatus_g_tc;
    }

    tms_CableSenseStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_CableSenseStatus_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_CableSenseStatus_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_CableSenseStatus_g_tc._data._sampleAccessInfo =
    tms_CableSenseStatus_get_sample_access_info();
    tms_CableSenseStatus_g_tc._data._typePlugin =
    tms_CableSenseStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_CableSenseStatus_g_tc;
}

#define TSeq tms_CableSenseStatusSeq
#define T tms_CableSenseStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_CableSenseStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_CableSenseStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_CableSenseStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_CableSenseStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_CableSenseStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_CableSenseStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_CableSenseStatus_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_CableSenseStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_CableSenseStatus_g_sampleAccessInfo;
    }

    tms_CableSenseStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_CableSenseStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_CableSenseStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_CableSenseStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_CableSenseStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_CableSenseStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_CableSenseStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_CableSenseStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_CableSenseStatus_get_member_value_pointer;

    tms_CableSenseStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_CableSenseStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_CableSenseStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_CableSenseStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_CableSenseStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_CableSenseStatus_finalize_w_return,
        NULL
    };

    return &tms_CableSenseStatus_g_typePlugin;
}
#endif

RTIBool tms_CableSenseStatus_initialize(
    tms_CableSenseStatus* sample) {
    *sample = CS_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_CableSenseStatus_initialize_ex(
    tms_CableSenseStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_CableSenseStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_CableSenseStatus_initialize_w_params(
    tms_CableSenseStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = CS_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_CableSenseStatus_finalize_w_return(
    tms_CableSenseStatus* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_CableSenseStatus_finalize(
    tms_CableSenseStatus* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_CableSenseStatus_finalize_ex(
    tms_CableSenseStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_CableSenseStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_CableSenseStatus_finalize_w_params(
    tms_CableSenseStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_CableSenseStatus_finalize_optional_members(
    tms_CableSenseStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_CableSenseStatus_copy(
    tms_CableSenseStatus* dst,
    const tms_CableSenseStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_CableSenseStatus' sequence class.
*/
#define T tms_CableSenseStatus
#define TSeq tms_CableSenseStatusSeq

#define T_initialize_w_params tms_CableSenseStatus_initialize_w_params

#define T_finalize_w_params   tms_CableSenseStatus_finalize_w_params
#define T_copy       tms_CableSenseStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerConnectorTypeTYPENAME = "tms::PowerConnectorType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerConnectorType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerConnectorType_g_tc_members[12]=
    {

        {
            (char *)"CONNECTOR_TERMINAL_BLOCK",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_TERMINAL_BLOCK, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_MILSTD",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_MILSTD, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_NEMA5",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_NEMA5, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_CAMLOCK",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_CAMLOCK, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_POWERLOCK",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_POWERLOCK, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_IEC60309",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_IEC60309, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_J1772",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_J1772, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_POWERLOK",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_POWERLOK, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_MILSTD1651",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_MILSTD1651, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_MILDTL22992",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_MILDTL22992, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_MILDTL53126",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_MILDTL53126, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CONNECTOR_OTHER",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CONNECTOR_OTHER, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerConnectorType_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerConnectorType", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            12, /* Number of members */
            tms_PowerConnectorType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerConnectorType*/

    if (is_initialized) {
        return &tms_PowerConnectorType_g_tc;
    }

    tms_PowerConnectorType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerConnectorType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerConnectorType_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerConnectorType_g_tc._data._sampleAccessInfo =
    tms_PowerConnectorType_get_sample_access_info();
    tms_PowerConnectorType_g_tc._data._typePlugin =
    tms_PowerConnectorType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerConnectorType_g_tc;
}

#define TSeq tms_PowerConnectorTypeSeq
#define T tms_PowerConnectorType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerConnectorType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerConnectorType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerConnectorTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerConnectorTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerConnectorType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerConnectorType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerConnectorType_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerConnectorType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectorType_g_sampleAccessInfo;
    }

    tms_PowerConnectorType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerConnectorType_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerConnectorType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerConnectorType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerConnectorType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerConnectorType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerConnectorType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerConnectorType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerConnectorType_get_member_value_pointer;

    tms_PowerConnectorType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectorType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerConnectorType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerConnectorType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerConnectorType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerConnectorType_finalize_w_return,
        NULL
    };

    return &tms_PowerConnectorType_g_typePlugin;
}
#endif

RTIBool tms_PowerConnectorType_initialize(
    tms_PowerConnectorType* sample) {
    *sample = CONNECTOR_TERMINAL_BLOCK;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectorType_initialize_ex(
    tms_PowerConnectorType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerConnectorType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerConnectorType_initialize_w_params(
    tms_PowerConnectorType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = CONNECTOR_TERMINAL_BLOCK;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectorType_finalize_w_return(
    tms_PowerConnectorType* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerConnectorType_finalize(
    tms_PowerConnectorType* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerConnectorType_finalize_ex(
    tms_PowerConnectorType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerConnectorType_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerConnectorType_finalize_w_params(
    tms_PowerConnectorType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerConnectorType_finalize_optional_members(
    tms_PowerConnectorType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerConnectorType_copy(
    tms_PowerConnectorType* dst,
    const tms_PowerConnectorType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerConnectorType' sequence class.
*/
#define T tms_PowerConnectorType
#define TSeq tms_PowerConnectorTypeSeq

#define T_initialize_w_params tms_PowerConnectorType_initialize_w_params

#define T_finalize_w_params   tms_PowerConnectorType_finalize_w_params
#define T_copy       tms_PowerConnectorType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerConnectorPolarityTYPENAME = "tms::PowerConnectorPolarity";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerConnectorPolarity_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerConnectorPolarity_g_tc_members[3]=
    {

        {
            (char *)"POLARITY_PIN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            POLARITY_PIN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"POLARITY_SOCKET",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            POLARITY_SOCKET, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"POLARITY_UNIVERSAL",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            POLARITY_UNIVERSAL, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerConnectorPolarity_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerConnectorPolarity", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_PowerConnectorPolarity_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerConnectorPolarity*/

    if (is_initialized) {
        return &tms_PowerConnectorPolarity_g_tc;
    }

    tms_PowerConnectorPolarity_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerConnectorPolarity_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerConnectorPolarity_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerConnectorPolarity_g_tc._data._sampleAccessInfo =
    tms_PowerConnectorPolarity_get_sample_access_info();
    tms_PowerConnectorPolarity_g_tc._data._typePlugin =
    tms_PowerConnectorPolarity_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerConnectorPolarity_g_tc;
}

#define TSeq tms_PowerConnectorPolaritySeq
#define T tms_PowerConnectorPolarity
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerConnectorPolarity_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerConnectorPolarity_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerConnectorPolaritySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerConnectorPolaritySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerConnectorPolarity_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerConnectorPolarity_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerConnectorPolarity_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerConnectorPolarity_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectorPolarity_g_sampleAccessInfo;
    }

    tms_PowerConnectorPolarity_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerConnectorPolarity_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerConnectorPolarity_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerConnectorPolarity);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerConnectorPolarity_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerConnectorPolarity_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerConnectorPolarity_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerConnectorPolarity_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerConnectorPolarity_get_member_value_pointer;

    tms_PowerConnectorPolarity_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectorPolarity_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerConnectorPolarity_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerConnectorPolarity_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerConnectorPolarity_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerConnectorPolarity_finalize_w_return,
        NULL
    };

    return &tms_PowerConnectorPolarity_g_typePlugin;
}
#endif

RTIBool tms_PowerConnectorPolarity_initialize(
    tms_PowerConnectorPolarity* sample) {
    *sample = POLARITY_PIN;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectorPolarity_initialize_ex(
    tms_PowerConnectorPolarity* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerConnectorPolarity_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerConnectorPolarity_initialize_w_params(
    tms_PowerConnectorPolarity* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = POLARITY_PIN;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectorPolarity_finalize_w_return(
    tms_PowerConnectorPolarity* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerConnectorPolarity_finalize(
    tms_PowerConnectorPolarity* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerConnectorPolarity_finalize_ex(
    tms_PowerConnectorPolarity* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerConnectorPolarity_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerConnectorPolarity_finalize_w_params(
    tms_PowerConnectorPolarity* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerConnectorPolarity_finalize_optional_members(
    tms_PowerConnectorPolarity* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerConnectorPolarity_copy(
    tms_PowerConnectorPolarity* dst,
    const tms_PowerConnectorPolarity* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerConnectorPolarity' sequence class.
*/
#define T tms_PowerConnectorPolarity
#define TSeq tms_PowerConnectorPolaritySeq

#define T_initialize_w_params tms_PowerConnectorPolarity_initialize_w_params

#define T_finalize_w_params   tms_PowerConnectorPolarity_finalize_w_params
#define T_copy       tms_PowerConnectorPolarity_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerConnectorPhasesTYPENAME = "tms::PowerConnectorPhases";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerConnectorPhases_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerConnectorPhases_g_tc_members[5]=
    {

        {
            (char *)"PHASE_SINGLE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PHASE_SINGLE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PHASE_SPLIT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PHASE_SPLIT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PHASE_3WYE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PHASE_3WYE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PHASE_3DELTA",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PHASE_3DELTA, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PHASE_DC",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PHASE_DC, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerConnectorPhases_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerConnectorPhases", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_PowerConnectorPhases_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerConnectorPhases*/

    if (is_initialized) {
        return &tms_PowerConnectorPhases_g_tc;
    }

    tms_PowerConnectorPhases_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerConnectorPhases_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerConnectorPhases_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerConnectorPhases_g_tc._data._sampleAccessInfo =
    tms_PowerConnectorPhases_get_sample_access_info();
    tms_PowerConnectorPhases_g_tc._data._typePlugin =
    tms_PowerConnectorPhases_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerConnectorPhases_g_tc;
}

#define TSeq tms_PowerConnectorPhasesSeq
#define T tms_PowerConnectorPhases
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerConnectorPhases_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerConnectorPhases_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerConnectorPhasesSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerConnectorPhasesSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerConnectorPhases_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerConnectorPhases_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerConnectorPhases_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerConnectorPhases_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectorPhases_g_sampleAccessInfo;
    }

    tms_PowerConnectorPhases_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerConnectorPhases_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerConnectorPhases_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerConnectorPhases);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerConnectorPhases_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerConnectorPhases_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerConnectorPhases_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerConnectorPhases_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerConnectorPhases_get_member_value_pointer;

    tms_PowerConnectorPhases_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectorPhases_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerConnectorPhases_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerConnectorPhases_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerConnectorPhases_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerConnectorPhases_finalize_w_return,
        NULL
    };

    return &tms_PowerConnectorPhases_g_typePlugin;
}
#endif

RTIBool tms_PowerConnectorPhases_initialize(
    tms_PowerConnectorPhases* sample) {
    *sample = PHASE_SINGLE;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectorPhases_initialize_ex(
    tms_PowerConnectorPhases* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerConnectorPhases_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerConnectorPhases_initialize_w_params(
    tms_PowerConnectorPhases* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = PHASE_SINGLE;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectorPhases_finalize_w_return(
    tms_PowerConnectorPhases* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerConnectorPhases_finalize(
    tms_PowerConnectorPhases* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerConnectorPhases_finalize_ex(
    tms_PowerConnectorPhases* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerConnectorPhases_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerConnectorPhases_finalize_w_params(
    tms_PowerConnectorPhases* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerConnectorPhases_finalize_optional_members(
    tms_PowerConnectorPhases* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerConnectorPhases_copy(
    tms_PowerConnectorPhases* dst,
    const tms_PowerConnectorPhases* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerConnectorPhases' sequence class.
*/
#define T tms_PowerConnectorPhases
#define TSeq tms_PowerConnectorPhasesSeq

#define T_initialize_w_params tms_PowerConnectorPhases_initialize_w_params

#define T_finalize_w_params   tms_PowerConnectorPhases_finalize_w_params
#define T_copy       tms_PowerConnectorPhases_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerSwitchControlTYPENAME = "tms::PowerSwitchControl";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerSwitchControl_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerSwitchControl_g_tc_members[4]=
    {

        {
            (char *)"PSC_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSC_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSC_MANUAL",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSC_MANUAL, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSC_AUTO",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSC_AUTO, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSC_REMOTE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSC_REMOTE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerSwitchControl_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerSwitchControl", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_PowerSwitchControl_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerSwitchControl*/

    if (is_initialized) {
        return &tms_PowerSwitchControl_g_tc;
    }

    tms_PowerSwitchControl_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerSwitchControl_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerSwitchControl_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerSwitchControl_g_tc._data._sampleAccessInfo =
    tms_PowerSwitchControl_get_sample_access_info();
    tms_PowerSwitchControl_g_tc._data._typePlugin =
    tms_PowerSwitchControl_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerSwitchControl_g_tc;
}

#define TSeq tms_PowerSwitchControlSeq
#define T tms_PowerSwitchControl
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerSwitchControl_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerSwitchControl_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerSwitchControlSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerSwitchControlSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerSwitchControl_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerSwitchControl_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerSwitchControl_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerSwitchControl_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchControl_g_sampleAccessInfo;
    }

    tms_PowerSwitchControl_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerSwitchControl_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerSwitchControl_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerSwitchControl);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerSwitchControl_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerSwitchControl_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerSwitchControl_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerSwitchControl_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerSwitchControl_get_member_value_pointer;

    tms_PowerSwitchControl_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchControl_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerSwitchControl_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerSwitchControl_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerSwitchControl_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerSwitchControl_finalize_w_return,
        NULL
    };

    return &tms_PowerSwitchControl_g_typePlugin;
}
#endif

RTIBool tms_PowerSwitchControl_initialize(
    tms_PowerSwitchControl* sample) {
    *sample = PSC_NONE;
    return RTI_TRUE;
}

RTIBool tms_PowerSwitchControl_initialize_ex(
    tms_PowerSwitchControl* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerSwitchControl_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerSwitchControl_initialize_w_params(
    tms_PowerSwitchControl* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = PSC_NONE;
    return RTI_TRUE;
}

RTIBool tms_PowerSwitchControl_finalize_w_return(
    tms_PowerSwitchControl* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerSwitchControl_finalize(
    tms_PowerSwitchControl* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerSwitchControl_finalize_ex(
    tms_PowerSwitchControl* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerSwitchControl_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerSwitchControl_finalize_w_params(
    tms_PowerSwitchControl* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerSwitchControl_finalize_optional_members(
    tms_PowerSwitchControl* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerSwitchControl_copy(
    tms_PowerSwitchControl* dst,
    const tms_PowerSwitchControl* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerSwitchControl' sequence class.
*/
#define T tms_PowerSwitchControl
#define TSeq tms_PowerSwitchControlSeq

#define T_initialize_w_params tms_PowerSwitchControl_initialize_w_params

#define T_finalize_w_params   tms_PowerSwitchControl_finalize_w_params
#define T_copy       tms_PowerSwitchControl_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerSwitchProtectionTYPENAME = "tms::PowerSwitchProtection";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerSwitchProtection_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerSwitchProtection_g_tc_members[4]=
    {

        {
            (char *)"PSP_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSP_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSP_BREAKER",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSP_BREAKER, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSP_GFI",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSP_GFI, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSP_BREAKER_GFI",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSP_BREAKER_GFI, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerSwitchProtection_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerSwitchProtection", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_PowerSwitchProtection_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerSwitchProtection*/

    if (is_initialized) {
        return &tms_PowerSwitchProtection_g_tc;
    }

    tms_PowerSwitchProtection_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerSwitchProtection_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerSwitchProtection_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerSwitchProtection_g_tc._data._sampleAccessInfo =
    tms_PowerSwitchProtection_get_sample_access_info();
    tms_PowerSwitchProtection_g_tc._data._typePlugin =
    tms_PowerSwitchProtection_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerSwitchProtection_g_tc;
}

#define TSeq tms_PowerSwitchProtectionSeq
#define T tms_PowerSwitchProtection
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerSwitchProtection_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerSwitchProtection_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerSwitchProtectionSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerSwitchProtectionSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerSwitchProtection_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerSwitchProtection_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerSwitchProtection_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerSwitchProtection_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchProtection_g_sampleAccessInfo;
    }

    tms_PowerSwitchProtection_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerSwitchProtection_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerSwitchProtection_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerSwitchProtection);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerSwitchProtection_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerSwitchProtection_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerSwitchProtection_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerSwitchProtection_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerSwitchProtection_get_member_value_pointer;

    tms_PowerSwitchProtection_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchProtection_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerSwitchProtection_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerSwitchProtection_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerSwitchProtection_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerSwitchProtection_finalize_w_return,
        NULL
    };

    return &tms_PowerSwitchProtection_g_typePlugin;
}
#endif

RTIBool tms_PowerSwitchProtection_initialize(
    tms_PowerSwitchProtection* sample) {
    *sample = PSP_NONE;
    return RTI_TRUE;
}

RTIBool tms_PowerSwitchProtection_initialize_ex(
    tms_PowerSwitchProtection* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerSwitchProtection_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerSwitchProtection_initialize_w_params(
    tms_PowerSwitchProtection* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = PSP_NONE;
    return RTI_TRUE;
}

RTIBool tms_PowerSwitchProtection_finalize_w_return(
    tms_PowerSwitchProtection* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerSwitchProtection_finalize(
    tms_PowerSwitchProtection* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerSwitchProtection_finalize_ex(
    tms_PowerSwitchProtection* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerSwitchProtection_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerSwitchProtection_finalize_w_params(
    tms_PowerSwitchProtection* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerSwitchProtection_finalize_optional_members(
    tms_PowerSwitchProtection* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerSwitchProtection_copy(
    tms_PowerSwitchProtection* dst,
    const tms_PowerSwitchProtection* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerSwitchProtection' sequence class.
*/
#define T tms_PowerSwitchProtection
#define TSeq tms_PowerSwitchProtectionSeq

#define T_initialize_w_params tms_PowerSwitchProtection_initialize_w_params

#define T_finalize_w_params   tms_PowerSwitchProtection_finalize_w_params
#define T_copy       tms_PowerSwitchProtection_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerPortTypeTYPENAME = "tms::PowerPortType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerPortType_g_tc_members[10]=
    {

        {
            (char *)"portNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"standard",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"polarity",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ratedAmperage",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nominalVoltage",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"phases",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"cableSense",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"switchControl",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"protection",/* Member name */
            {
                8,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"synchronizer",/* Member name */
            {
                9,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerPortType_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerPortType", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            10, /* Number of members */
            tms_PowerPortType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerPortType*/

    if (is_initialized) {
        return &tms_PowerPortType_g_tc;
    }

    tms_PowerPortType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortType_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_PowerPortType_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PowerConnectorType_get_typecode();
    tms_PowerPortType_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_PowerConnectorPolarity_get_typecode();
    tms_PowerPortType_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerPortType_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerPortType_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_PowerConnectorPhases_get_typecode();
    tms_PowerPortType_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)tms_CableSenseType_get_typecode();
    tms_PowerPortType_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)tms_PowerSwitchControl_get_typecode();
    tms_PowerPortType_g_tc_members[8]._representation._typeCode = (RTICdrTypeCode *)tms_PowerSwitchProtection_get_typecode();
    tms_PowerPortType_g_tc_members[9]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;

    /* Initialize the values for member annotations. */
    tms_PowerPortType_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortType_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortType_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortType_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortType_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortType_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortType_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortType_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortType_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortType_g_tc_members[2]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortType_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerPortType_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerPortType_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerPortType_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerPortType_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerPortType_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerPortType_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerPortType_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerPortType_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerPortType_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerPortType_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerPortType_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerPortType_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortType_g_tc_members[5]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortType_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortType_g_tc_members[6]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortType_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortType_g_tc_members[7]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortType_g_tc_members[8]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortType_g_tc_members[8]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortType_g_tc_members[9]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_PowerPortType_g_tc_members[9]._annotations._defaultValue._u.boolean_value = 0;

    tms_PowerPortType_g_tc._data._sampleAccessInfo =
    tms_PowerPortType_get_sample_access_info();
    tms_PowerPortType_g_tc._data._typePlugin =
    tms_PowerPortType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortType_g_tc;
}

#define TSeq tms_PowerPortTypeSeq
#define T tms_PowerPortType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerPortType *sample;

    static RTIXCdrMemberAccessInfo tms_PowerPortType_g_memberAccessInfos[10] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortType_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerPortType);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerPortType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->standard - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->polarity - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->ratedAmperage - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nominalVoltage - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->phases - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->cableSense - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->switchControl - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[8].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->protection - (char *)sample);

    tms_PowerPortType_g_memberAccessInfos[9].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->synchronizer - (char *)sample);

    tms_PowerPortType_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortType_get_member_value_pointer;

    tms_PowerPortType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortType_finalize_w_return,
        NULL
    };

    return &tms_PowerPortType_g_typePlugin;
}
#endif

RTIBool tms_PowerPortType_initialize(
    tms_PowerPortType* sample) {
    return tms_PowerPortType_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortType_initialize_ex(
    tms_PowerPortType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortType_initialize_w_params(
    tms_PowerPortType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    sample->standard = CONNECTOR_TERMINAL_BLOCK;
    sample->polarity = POLARITY_PIN;

    sample->ratedAmperage = 0.0f;

    sample->nominalVoltage = 0.0f;

    sample->phases = PHASE_SINGLE;
    sample->cableSense = CST_NONE;
    sample->switchControl = PSC_NONE;
    sample->protection = PSP_NONE;

    sample->synchronizer = 0;

    return RTI_TRUE;
}

RTIBool tms_PowerPortType_finalize_w_return(
    tms_PowerPortType* sample)
{
    tms_PowerPortType_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortType_finalize(
    tms_PowerPortType* sample)
{

    tms_PowerPortType_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortType_finalize_ex(
    tms_PowerPortType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortType_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortType_finalize_w_params(
    tms_PowerPortType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_PowerConnectorType_finalize_w_params(&sample->standard,deallocParams);

    tms_PowerConnectorPolarity_finalize_w_params(&sample->polarity,deallocParams);

    tms_PowerConnectorPhases_finalize_w_params(&sample->phases,deallocParams);

    tms_CableSenseType_finalize_w_params(&sample->cableSense,deallocParams);

    tms_PowerSwitchControl_finalize_w_params(&sample->switchControl,deallocParams);

    tms_PowerSwitchProtection_finalize_w_params(&sample->protection,deallocParams);

}

void tms_PowerPortType_finalize_optional_members(
    tms_PowerPortType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortType_copy(
    tms_PowerPortType* dst,
    const tms_PowerPortType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_PowerConnectorType_copy(
            &dst->standard,(const tms_PowerConnectorType*)&src->standard)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerConnectorPolarity_copy(
            &dst->polarity,(const tms_PowerConnectorPolarity*)&src->polarity)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->ratedAmperage, &src->ratedAmperage)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->nominalVoltage, &src->nominalVoltage)) { 
            return RTI_FALSE;
        }
        if (!tms_PowerConnectorPhases_copy(
            &dst->phases,(const tms_PowerConnectorPhases*)&src->phases)) {
            return RTI_FALSE;
        } 
        if (!tms_CableSenseType_copy(
            &dst->cableSense,(const tms_CableSenseType*)&src->cableSense)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerSwitchControl_copy(
            &dst->switchControl,(const tms_PowerSwitchControl*)&src->switchControl)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerSwitchProtection_copy(
            &dst->protection,(const tms_PowerSwitchProtection*)&src->protection)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyBoolean (
            &dst->synchronizer, &src->synchronizer)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortType' sequence class.
*/
#define T tms_PowerPortType
#define TSeq tms_PowerPortTypeSeq

#define T_initialize_w_params tms_PowerPortType_initialize_w_params

#define T_finalize_w_params   tms_PowerPortType_finalize_w_params
#define T_copy       tms_PowerPortType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_CircuitContinuityTYPENAME = "tms::CircuitContinuity";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_CircuitContinuity_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_CircuitContinuity_g_tc_members[4]=
    {

        {
            (char *)"CC_UNKNOWN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CC_UNKNOWN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CC_OPEN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CC_OPEN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CC_CLOSED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CC_CLOSED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"CC_INCONSISTENT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            CC_INCONSISTENT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_CircuitContinuity_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::CircuitContinuity", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_CircuitContinuity_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_CircuitContinuity*/

    if (is_initialized) {
        return &tms_CircuitContinuity_g_tc;
    }

    tms_CircuitContinuity_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_CircuitContinuity_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_CircuitContinuity_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_CircuitContinuity_g_tc._data._sampleAccessInfo =
    tms_CircuitContinuity_get_sample_access_info();
    tms_CircuitContinuity_g_tc._data._typePlugin =
    tms_CircuitContinuity_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_CircuitContinuity_g_tc;
}

#define TSeq tms_CircuitContinuitySeq
#define T tms_CircuitContinuity
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_CircuitContinuity_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_CircuitContinuity_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_CircuitContinuitySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_CircuitContinuitySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_CircuitContinuity_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_CircuitContinuity_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_CircuitContinuity_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_CircuitContinuity_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_CircuitContinuity_g_sampleAccessInfo;
    }

    tms_CircuitContinuity_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_CircuitContinuity_g_sampleAccessInfo.memberAccessInfos = 
    tms_CircuitContinuity_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_CircuitContinuity);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_CircuitContinuity_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_CircuitContinuity_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_CircuitContinuity_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_CircuitContinuity_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_CircuitContinuity_get_member_value_pointer;

    tms_CircuitContinuity_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_CircuitContinuity_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_CircuitContinuity_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_CircuitContinuity_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_CircuitContinuity_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_CircuitContinuity_finalize_w_return,
        NULL
    };

    return &tms_CircuitContinuity_g_typePlugin;
}
#endif

RTIBool tms_CircuitContinuity_initialize(
    tms_CircuitContinuity* sample) {
    *sample = CC_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_CircuitContinuity_initialize_ex(
    tms_CircuitContinuity* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_CircuitContinuity_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_CircuitContinuity_initialize_w_params(
    tms_CircuitContinuity* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = CC_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_CircuitContinuity_finalize_w_return(
    tms_CircuitContinuity* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_CircuitContinuity_finalize(
    tms_CircuitContinuity* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_CircuitContinuity_finalize_ex(
    tms_CircuitContinuity* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_CircuitContinuity_finalize_w_params(
        sample,&deallocParams);
}

void tms_CircuitContinuity_finalize_w_params(
    tms_CircuitContinuity* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_CircuitContinuity_finalize_optional_members(
    tms_CircuitContinuity* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_CircuitContinuity_copy(
    tms_CircuitContinuity* dst,
    const tms_CircuitContinuity* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_CircuitContinuity' sequence class.
*/
#define T tms_CircuitContinuity
#define TSeq tms_CircuitContinuitySeq

#define T_initialize_w_params tms_CircuitContinuity_initialize_w_params

#define T_finalize_w_params   tms_CircuitContinuity_finalize_w_params
#define T_copy       tms_CircuitContinuity_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerSwitchReasonTYPENAME = "tms::PowerSwitchReason";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerSwitchReason_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerSwitchReason_g_tc_members[6]=
    {

        {
            (char *)"PSR_UNKNOWN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSR_UNKNOWN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSR_MANUAL",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSR_MANUAL, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSR_COMMAND",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSR_COMMAND, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSR_PROTECTION",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSR_PROTECTION, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSR_FAILURE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSR_FAILURE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PSR_LOAD_POLICY",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PSR_LOAD_POLICY, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerSwitchReason_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerSwitchReason", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_PowerSwitchReason_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerSwitchReason*/

    if (is_initialized) {
        return &tms_PowerSwitchReason_g_tc;
    }

    tms_PowerSwitchReason_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerSwitchReason_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerSwitchReason_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerSwitchReason_g_tc._data._sampleAccessInfo =
    tms_PowerSwitchReason_get_sample_access_info();
    tms_PowerSwitchReason_g_tc._data._typePlugin =
    tms_PowerSwitchReason_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerSwitchReason_g_tc;
}

#define TSeq tms_PowerSwitchReasonSeq
#define T tms_PowerSwitchReason
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerSwitchReason_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerSwitchReason_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerSwitchReasonSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerSwitchReasonSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerSwitchReason_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerSwitchReason_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerSwitchReason_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerSwitchReason_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchReason_g_sampleAccessInfo;
    }

    tms_PowerSwitchReason_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerSwitchReason_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerSwitchReason_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerSwitchReason);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerSwitchReason_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerSwitchReason_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerSwitchReason_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerSwitchReason_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerSwitchReason_get_member_value_pointer;

    tms_PowerSwitchReason_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchReason_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerSwitchReason_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerSwitchReason_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerSwitchReason_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerSwitchReason_finalize_w_return,
        NULL
    };

    return &tms_PowerSwitchReason_g_typePlugin;
}
#endif

RTIBool tms_PowerSwitchReason_initialize(
    tms_PowerSwitchReason* sample) {
    *sample = PSR_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_PowerSwitchReason_initialize_ex(
    tms_PowerSwitchReason* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerSwitchReason_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerSwitchReason_initialize_w_params(
    tms_PowerSwitchReason* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = PSR_UNKNOWN;
    return RTI_TRUE;
}

RTIBool tms_PowerSwitchReason_finalize_w_return(
    tms_PowerSwitchReason* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerSwitchReason_finalize(
    tms_PowerSwitchReason* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerSwitchReason_finalize_ex(
    tms_PowerSwitchReason* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerSwitchReason_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerSwitchReason_finalize_w_params(
    tms_PowerSwitchReason* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerSwitchReason_finalize_optional_members(
    tms_PowerSwitchReason* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerSwitchReason_copy(
    tms_PowerSwitchReason* dst,
    const tms_PowerSwitchReason* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerSwitchReason' sequence class.
*/
#define T tms_PowerSwitchReason
#define TSeq tms_PowerSwitchReasonSeq

#define T_initialize_w_params tms_PowerSwitchReason_initialize_w_params

#define T_finalize_w_params   tms_PowerSwitchReason_finalize_w_params
#define T_copy       tms_PowerSwitchReason_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerSwitchStatusTYPENAME = "tms::PowerSwitchStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerSwitchStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerSwitchStatus_g_tc_members[5]=
    {

        {
            (char *)"continuity",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"transitionFault",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"transitionLock",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"lastTransition",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"lastTransitionActor",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerSwitchStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerSwitchStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_PowerSwitchStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerSwitchStatus*/

    if (is_initialized) {
        return &tms_PowerSwitchStatus_g_tc;
    }

    tms_PowerSwitchStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerSwitchStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_CircuitContinuity_get_typecode();
    tms_PowerSwitchStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_PowerSwitchStatus_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_PowerSwitchStatus_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_PowerSwitchReason_get_typecode();
    tms_PowerSwitchStatus_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();

    /* Initialize the values for member annotations. */
    tms_PowerSwitchStatus_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerSwitchStatus_g_tc_members[0]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerSwitchStatus_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_PowerSwitchStatus_g_tc_members[1]._annotations._defaultValue._u.boolean_value = 0;

    tms_PowerSwitchStatus_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_PowerSwitchStatus_g_tc_members[2]._annotations._defaultValue._u.boolean_value = 0;

    tms_PowerSwitchStatus_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerSwitchStatus_g_tc_members[3]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerSwitchStatus_g_tc._data._sampleAccessInfo =
    tms_PowerSwitchStatus_get_sample_access_info();
    tms_PowerSwitchStatus_g_tc._data._typePlugin =
    tms_PowerSwitchStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerSwitchStatus_g_tc;
}

#define TSeq tms_PowerSwitchStatusSeq
#define T tms_PowerSwitchStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerSwitchStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerSwitchStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerSwitchStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerSwitchStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerSwitchStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerSwitchStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerSwitchStatus *sample;

    static RTIXCdrMemberAccessInfo tms_PowerSwitchStatus_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerSwitchStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerSwitchStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerSwitchStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->continuity - (char *)sample);

    tms_PowerSwitchStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->transitionFault - (char *)sample);

    tms_PowerSwitchStatus_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->transitionLock - (char *)sample);

    tms_PowerSwitchStatus_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->lastTransition - (char *)sample);

    tms_PowerSwitchStatus_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->lastTransitionActor - (char *)sample);

    tms_PowerSwitchStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerSwitchStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerSwitchStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerSwitchStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerSwitchStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerSwitchStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerSwitchStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerSwitchStatus_get_member_value_pointer;

    tms_PowerSwitchStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerSwitchStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerSwitchStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerSwitchStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerSwitchStatus_finalize_w_return,
        NULL
    };

    return &tms_PowerSwitchStatus_g_typePlugin;
}
#endif

RTIBool tms_PowerSwitchStatus_initialize(
    tms_PowerSwitchStatus* sample) {
    return tms_PowerSwitchStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerSwitchStatus_initialize_ex(
    tms_PowerSwitchStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerSwitchStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerSwitchStatus_initialize_w_params(
    tms_PowerSwitchStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->continuity = CC_UNKNOWN;

    sample->transitionFault = 0;

    sample->transitionLock = 0;

    sample->lastTransition = PSR_UNKNOWN;
    if (!tms_Fingerprint_initialize_w_params(&sample->lastTransitionActor,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_PowerSwitchStatus_finalize_w_return(
    tms_PowerSwitchStatus* sample)
{
    tms_PowerSwitchStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerSwitchStatus_finalize(
    tms_PowerSwitchStatus* sample)
{

    tms_PowerSwitchStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerSwitchStatus_finalize_ex(
    tms_PowerSwitchStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerSwitchStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerSwitchStatus_finalize_w_params(
    tms_PowerSwitchStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_CircuitContinuity_finalize_w_params(&sample->continuity,deallocParams);

    tms_PowerSwitchReason_finalize_w_params(&sample->lastTransition,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->lastTransitionActor,deallocParams);

}

void tms_PowerSwitchStatus_finalize_optional_members(
    tms_PowerSwitchStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerSwitchStatus_copy(
    tms_PowerSwitchStatus* dst,
    const tms_PowerSwitchStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_CircuitContinuity_copy(
            &dst->continuity,(const tms_CircuitContinuity*)&src->continuity)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyBoolean (
            &dst->transitionFault, &src->transitionFault)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->transitionLock, &src->transitionLock)) { 
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchReason_copy(
            &dst->lastTransition,(const tms_PowerSwitchReason*)&src->lastTransition)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->lastTransitionActor,(const tms_Fingerprint*)&src->lastTransitionActor)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerSwitchStatus' sequence class.
*/
#define T tms_PowerSwitchStatus
#define TSeq tms_PowerSwitchStatusSeq

#define T_initialize_w_params tms_PowerSwitchStatus_initialize_w_params

#define T_finalize_w_params   tms_PowerSwitchStatus_finalize_w_params
#define T_copy       tms_PowerSwitchStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DesiredCircuitContinuityTYPENAME = "tms::DesiredCircuitContinuity";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DesiredCircuitContinuity_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_DesiredCircuitContinuity_g_tc_members[5]=
    {

        {
            (char *)"DCC_OPEN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            DCC_OPEN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"DCC_CLOSED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            DCC_CLOSED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"DCC_SYNC_CLOSED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            DCC_SYNC_CLOSED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"DCC_CLOSED_INTERNAL",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            DCC_CLOSED_INTERNAL, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"DCC_NO_CHANGE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            DCC_NO_CHANGE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DesiredCircuitContinuity_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DesiredCircuitContinuity", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_DesiredCircuitContinuity_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DesiredCircuitContinuity*/

    if (is_initialized) {
        return &tms_DesiredCircuitContinuity_g_tc;
    }

    tms_DesiredCircuitContinuity_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_DesiredCircuitContinuity_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_DesiredCircuitContinuity_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_DesiredCircuitContinuity_g_tc._data._sampleAccessInfo =
    tms_DesiredCircuitContinuity_get_sample_access_info();
    tms_DesiredCircuitContinuity_g_tc._data._typePlugin =
    tms_DesiredCircuitContinuity_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DesiredCircuitContinuity_g_tc;
}

#define TSeq tms_DesiredCircuitContinuitySeq
#define T tms_DesiredCircuitContinuity
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DesiredCircuitContinuity_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DesiredCircuitContinuity_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DesiredCircuitContinuitySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DesiredCircuitContinuitySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DesiredCircuitContinuity_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DesiredCircuitContinuity_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_DesiredCircuitContinuity_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DesiredCircuitContinuity_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DesiredCircuitContinuity_g_sampleAccessInfo;
    }

    tms_DesiredCircuitContinuity_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_DesiredCircuitContinuity_g_sampleAccessInfo.memberAccessInfos = 
    tms_DesiredCircuitContinuity_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DesiredCircuitContinuity);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DesiredCircuitContinuity_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DesiredCircuitContinuity_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DesiredCircuitContinuity_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DesiredCircuitContinuity_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DesiredCircuitContinuity_get_member_value_pointer;

    tms_DesiredCircuitContinuity_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DesiredCircuitContinuity_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DesiredCircuitContinuity_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DesiredCircuitContinuity_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DesiredCircuitContinuity_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DesiredCircuitContinuity_finalize_w_return,
        NULL
    };

    return &tms_DesiredCircuitContinuity_g_typePlugin;
}
#endif

RTIBool tms_DesiredCircuitContinuity_initialize(
    tms_DesiredCircuitContinuity* sample) {
    *sample = DCC_OPEN;
    return RTI_TRUE;
}

RTIBool tms_DesiredCircuitContinuity_initialize_ex(
    tms_DesiredCircuitContinuity* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DesiredCircuitContinuity_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DesiredCircuitContinuity_initialize_w_params(
    tms_DesiredCircuitContinuity* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = DCC_OPEN;
    return RTI_TRUE;
}

RTIBool tms_DesiredCircuitContinuity_finalize_w_return(
    tms_DesiredCircuitContinuity* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_DesiredCircuitContinuity_finalize(
    tms_DesiredCircuitContinuity* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_DesiredCircuitContinuity_finalize_ex(
    tms_DesiredCircuitContinuity* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DesiredCircuitContinuity_finalize_w_params(
        sample,&deallocParams);
}

void tms_DesiredCircuitContinuity_finalize_w_params(
    tms_DesiredCircuitContinuity* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_DesiredCircuitContinuity_finalize_optional_members(
    tms_DesiredCircuitContinuity* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DesiredCircuitContinuity_copy(
    tms_DesiredCircuitContinuity* dst,
    const tms_DesiredCircuitContinuity* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DesiredCircuitContinuity' sequence class.
*/
#define T tms_DesiredCircuitContinuity
#define TSeq tms_DesiredCircuitContinuitySeq

#define T_initialize_w_params tms_DesiredCircuitContinuity_initialize_w_params

#define T_finalize_w_params   tms_DesiredCircuitContinuity_finalize_w_params
#define T_copy       tms_DesiredCircuitContinuity_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerSwitchCommandTYPENAME = "tms::PowerSwitchCommand";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerSwitchCommand_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerSwitchCommand_g_tc_members[10]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"portNumber",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"continuity",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"minV",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"maxV",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"minF",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"maxF",/* Member name */
            {
                8,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"maxPhase",/* Member name */
            {
                9,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerSwitchCommand_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerSwitchCommand", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            10, /* Number of members */
            tms_PowerSwitchCommand_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerSwitchCommand*/

    if (is_initialized) {
        return &tms_PowerSwitchCommand_g_tc;
    }

    tms_PowerSwitchCommand_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerSwitchCommand_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_PowerSwitchCommand_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_PowerSwitchCommand_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_PowerSwitchCommand_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_PowerSwitchCommand_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_DesiredCircuitContinuity_get_typecode();
    tms_PowerSwitchCommand_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerSwitchCommand_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerSwitchCommand_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerSwitchCommand_g_tc_members[8]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerSwitchCommand_g_tc_members[9]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_PowerSwitchCommand_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_PowerSwitchCommand_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_PowerSwitchCommand_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_PowerSwitchCommand_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_PowerSwitchCommand_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_PowerSwitchCommand_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_PowerSwitchCommand_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerSwitchCommand_g_tc_members[3]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerSwitchCommand_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerSwitchCommand_g_tc_members[3]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerSwitchCommand_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerSwitchCommand_g_tc_members[3]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerSwitchCommand_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerSwitchCommand_g_tc_members[4]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerSwitchCommand_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[5]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerSwitchCommand_g_tc_members[5]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[5]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerSwitchCommand_g_tc_members[5]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[5]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerSwitchCommand_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[6]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerSwitchCommand_g_tc_members[6]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[6]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerSwitchCommand_g_tc_members[6]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[6]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerSwitchCommand_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[7]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerSwitchCommand_g_tc_members[7]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[7]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerSwitchCommand_g_tc_members[7]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[7]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerSwitchCommand_g_tc_members[8]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[8]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerSwitchCommand_g_tc_members[8]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[8]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerSwitchCommand_g_tc_members[8]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[8]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerSwitchCommand_g_tc_members[9]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[9]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerSwitchCommand_g_tc_members[9]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[9]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerSwitchCommand_g_tc_members[9]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerSwitchCommand_g_tc_members[9]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerSwitchCommand_g_tc._data._sampleAccessInfo =
    tms_PowerSwitchCommand_get_sample_access_info();
    tms_PowerSwitchCommand_g_tc._data._typePlugin =
    tms_PowerSwitchCommand_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerSwitchCommand_g_tc;
}

#define TSeq tms_PowerSwitchCommandSeq
#define T tms_PowerSwitchCommand
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerSwitchCommand_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerSwitchCommand_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerSwitchCommandSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerSwitchCommandSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerSwitchCommand_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerSwitchCommand_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerSwitchCommand *sample;

    static RTIXCdrMemberAccessInfo tms_PowerSwitchCommand_g_memberAccessInfos[10] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerSwitchCommand_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchCommand_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerSwitchCommand);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerSwitchCommand_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->continuity - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->minV - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->maxV - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->minF - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[8].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->maxF - (char *)sample);

    tms_PowerSwitchCommand_g_memberAccessInfos[9].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->maxPhase - (char *)sample);

    tms_PowerSwitchCommand_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerSwitchCommand_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerSwitchCommand);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerSwitchCommand_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerSwitchCommand_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerSwitchCommand_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerSwitchCommand_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerSwitchCommand_get_member_value_pointer;

    tms_PowerSwitchCommand_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerSwitchCommand_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerSwitchCommand_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerSwitchCommand_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerSwitchCommand_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerSwitchCommand_finalize_w_return,
        NULL
    };

    return &tms_PowerSwitchCommand_g_typePlugin;
}
#endif

RTIBool tms_PowerSwitchCommand_initialize(
    tms_PowerSwitchCommand* sample) {
    return tms_PowerSwitchCommand_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerSwitchCommand_initialize_ex(
    tms_PowerSwitchCommand* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerSwitchCommand_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerSwitchCommand_initialize_w_params(
    tms_PowerSwitchCommand* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    sample->portNumber = 0u;

    sample->continuity = DCC_OPEN;

    sample->minV = 0.0f;

    sample->maxV = 0.0f;

    sample->minF = 0.0f;

    sample->maxF = 0.0f;

    sample->maxPhase = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_PowerSwitchCommand_finalize_w_return(
    tms_PowerSwitchCommand* sample)
{
    tms_PowerSwitchCommand_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerSwitchCommand_finalize(
    tms_PowerSwitchCommand* sample)
{

    tms_PowerSwitchCommand_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerSwitchCommand_finalize_ex(
    tms_PowerSwitchCommand* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerSwitchCommand_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerSwitchCommand_finalize_w_params(
    tms_PowerSwitchCommand* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_DesiredCircuitContinuity_finalize_w_params(&sample->continuity,deallocParams);

}

void tms_PowerSwitchCommand_finalize_optional_members(
    tms_PowerSwitchCommand* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerSwitchCommand_copy(
    tms_PowerSwitchCommand* dst,
    const tms_PowerSwitchCommand* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_DesiredCircuitContinuity_copy(
            &dst->continuity,(const tms_DesiredCircuitContinuity*)&src->continuity)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->minV, &src->minV)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->maxV, &src->maxV)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->minF, &src->minF)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->maxF, &src->maxF)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->maxPhase, &src->maxPhase)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerSwitchCommand' sequence class.
*/
#define T tms_PowerSwitchCommand
#define TSeq tms_PowerSwitchCommandSeq

#define T_initialize_w_params tms_PowerSwitchCommand_initialize_w_params

#define T_finalize_w_params   tms_PowerSwitchCommand_finalize_w_params
#define T_copy       tms_PowerSwitchCommand_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerPortStatusTYPENAME = "tms::PowerPortStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_PowerPortStatus_g_tc_cableId_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_cableId)),NULL);
    static DDS_TypeCode tms_PowerPortStatus_g_tc_connection_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_connection)),NULL);
    static DDS_TypeCode tms_PowerPortStatus_g_tc_switchStatus_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_switchStatus)),NULL);

    static DDS_TypeCode_Member tms_PowerPortStatus_g_tc_members[5]=
    {

        {
            (char *)"portNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"cableStatus",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"cableId",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"connection",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"switchStatus",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerPortStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerPortStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_PowerPortStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerPortStatus*/

    if (is_initialized) {
        return &tms_PowerPortStatus_g_tc;
    }

    tms_PowerPortStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortStatus_g_tc_cableId_sequence._data._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_PowerPortStatus_g_tc_cableId_sequence._data._sampleAccessInfo = tms_Fingerprint_get_sample_seq_access_info();
    tms_PowerPortStatus_g_tc_connection_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortId_get_typecode();
    tms_PowerPortStatus_g_tc_connection_sequence._data._sampleAccessInfo = tms_PowerPortId_get_sample_seq_access_info();
    tms_PowerPortStatus_g_tc_switchStatus_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerSwitchStatus_get_typecode();
    tms_PowerPortStatus_g_tc_switchStatus_sequence._data._sampleAccessInfo = tms_PowerSwitchStatus_get_sample_seq_access_info();
    tms_PowerPortStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_PowerPortStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_CableSenseStatus_get_typecode();
    tms_PowerPortStatus_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)& tms_PowerPortStatus_g_tc_cableId_sequence;
    tms_PowerPortStatus_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_PowerPortStatus_g_tc_connection_sequence;
    tms_PowerPortStatus_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)& tms_PowerPortStatus_g_tc_switchStatus_sequence;

    /* Initialize the values for member annotations. */
    tms_PowerPortStatus_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortStatus_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortStatus_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortStatus_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortStatus_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortStatus_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortStatus_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortStatus_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortStatus_g_tc._data._sampleAccessInfo =
    tms_PowerPortStatus_get_sample_access_info();
    tms_PowerPortStatus_g_tc._data._typePlugin =
    tms_PowerPortStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortStatus_g_tc;
}

#define TSeq tms_PowerPortStatusSeq
#define T tms_PowerPortStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerPortStatus *sample;

    static RTIXCdrMemberAccessInfo tms_PowerPortStatus_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerPortStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerPortStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerPortStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->cableStatus - (char *)sample);

    tms_PowerPortStatus_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->cableId - (char *)sample);

    tms_PowerPortStatus_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->connection - (char *)sample);

    tms_PowerPortStatus_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->switchStatus - (char *)sample);

    tms_PowerPortStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortStatus_get_member_value_pointer;

    tms_PowerPortStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortStatus_finalize_w_return,
        NULL
    };

    return &tms_PowerPortStatus_g_typePlugin;
}
#endif

RTIBool tms_PowerPortStatus_initialize(
    tms_PowerPortStatus* sample) {
    return tms_PowerPortStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortStatus_initialize_ex(
    tms_PowerPortStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortStatus_initialize_w_params(
    tms_PowerPortStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    sample->cableStatus = CS_UNKNOWN;
    if (allocParams->allocate_memory) {
        if(!tms_FingerprintSeq_initialize(&sample->cableId )){
            return RTI_FALSE;
        };
        if(!tms_FingerprintSeq_set_element_allocation_params(&sample->cableId ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_FingerprintSeq_set_absolute_maximum(&sample->cableId , ((tms_MAXLEN_cableId)))){
            return RTI_FALSE;
        }
        if (!tms_FingerprintSeq_set_maximum(&sample->cableId, ((tms_MAXLEN_cableId)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_FingerprintSeq_set_length(&sample->cableId, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerPortIdSeq_initialize(&sample->connection )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortIdSeq_set_element_allocation_params(&sample->connection ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortIdSeq_set_absolute_maximum(&sample->connection , ((tms_MAXLEN_connection)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortIdSeq_set_maximum(&sample->connection, ((tms_MAXLEN_connection)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortIdSeq_set_length(&sample->connection, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerSwitchStatusSeq_initialize(&sample->switchStatus )){
            return RTI_FALSE;
        };
        if(!tms_PowerSwitchStatusSeq_set_element_allocation_params(&sample->switchStatus ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerSwitchStatusSeq_set_absolute_maximum(&sample->switchStatus , ((tms_MAXLEN_switchStatus)))){
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchStatusSeq_set_maximum(&sample->switchStatus, ((tms_MAXLEN_switchStatus)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerSwitchStatusSeq_set_length(&sample->switchStatus, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_PowerPortStatus_finalize_w_return(
    tms_PowerPortStatus* sample)
{
    tms_PowerPortStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortStatus_finalize(
    tms_PowerPortStatus* sample)
{

    tms_PowerPortStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortStatus_finalize_ex(
    tms_PowerPortStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortStatus_finalize_w_params(
    tms_PowerPortStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_CableSenseStatus_finalize_w_params(&sample->cableStatus,deallocParams);

    if(!tms_FingerprintSeq_set_element_deallocation_params(
        &sample->cableId,deallocParams)){
        return; 
    }
    if(!tms_FingerprintSeq_finalize(&sample->cableId)){
        return;
    }

    if(!tms_PowerPortIdSeq_set_element_deallocation_params(
        &sample->connection,deallocParams)){
        return; 
    }
    if(!tms_PowerPortIdSeq_finalize(&sample->connection)){
        return;
    }

    if(!tms_PowerSwitchStatusSeq_set_element_deallocation_params(
        &sample->switchStatus,deallocParams)){
        return; 
    }
    if(!tms_PowerSwitchStatusSeq_finalize(&sample->switchStatus)){
        return;
    }

}

void tms_PowerPortStatus_finalize_optional_members(
    tms_PowerPortStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortStatus_copy(
    tms_PowerPortStatus* dst,
    const tms_PowerPortStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_CableSenseStatus_copy(
            &dst->cableStatus,(const tms_CableSenseStatus*)&src->cableStatus)) {
            return RTI_FALSE;
        } 
        if (!tms_FingerprintSeq_copy(&dst->cableId ,
        &src->cableId )) {
            return RTI_FALSE;
        }
        if (!tms_PowerPortIdSeq_copy(&dst->connection ,
        &src->connection )) {
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchStatusSeq_copy(&dst->switchStatus ,
        &src->switchStatus )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortStatus' sequence class.
*/
#define T tms_PowerPortStatus
#define TSeq tms_PowerPortStatusSeq

#define T_initialize_w_params tms_PowerPortStatus_initialize_w_params

#define T_finalize_w_params   tms_PowerPortStatus_finalize_w_params
#define T_copy       tms_PowerPortStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerConnectionDetectionTypeTYPENAME = "tms::PowerConnectionDetectionType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerConnectionDetectionType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerConnectionDetectionType_g_tc_members[5]=
    {

        {
            (char *)"PCDT_OPERATOR",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PCDT_OPERATOR, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PCDT_CABLE_ID",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PCDT_CABLE_ID, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PCDT_PROBE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PCDT_PROBE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PCDT_CORRELATION",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PCDT_CORRELATION, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"PCDT_HISTORY",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            PCDT_HISTORY, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerConnectionDetectionType_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerConnectionDetectionType", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_PowerConnectionDetectionType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerConnectionDetectionType*/

    if (is_initialized) {
        return &tms_PowerConnectionDetectionType_g_tc;
    }

    tms_PowerConnectionDetectionType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerConnectionDetectionType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerConnectionDetectionType_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerConnectionDetectionType_g_tc._data._sampleAccessInfo =
    tms_PowerConnectionDetectionType_get_sample_access_info();
    tms_PowerConnectionDetectionType_g_tc._data._typePlugin =
    tms_PowerConnectionDetectionType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerConnectionDetectionType_g_tc;
}

#define TSeq tms_PowerConnectionDetectionTypeSeq
#define T tms_PowerConnectionDetectionType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerConnectionDetectionType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerConnectionDetectionType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerConnectionDetectionTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerConnectionDetectionTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerConnectionDetectionType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerConnectionDetectionType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerConnectionDetectionType_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerConnectionDetectionType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectionDetectionType_g_sampleAccessInfo;
    }

    tms_PowerConnectionDetectionType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerConnectionDetectionType_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerConnectionDetectionType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerConnectionDetectionType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerConnectionDetectionType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerConnectionDetectionType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerConnectionDetectionType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerConnectionDetectionType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerConnectionDetectionType_get_member_value_pointer;

    tms_PowerConnectionDetectionType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectionDetectionType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerConnectionDetectionType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerConnectionDetectionType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerConnectionDetectionType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerConnectionDetectionType_finalize_w_return,
        NULL
    };

    return &tms_PowerConnectionDetectionType_g_typePlugin;
}
#endif

RTIBool tms_PowerConnectionDetectionType_initialize(
    tms_PowerConnectionDetectionType* sample) {
    *sample = PCDT_OPERATOR;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectionDetectionType_initialize_ex(
    tms_PowerConnectionDetectionType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerConnectionDetectionType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerConnectionDetectionType_initialize_w_params(
    tms_PowerConnectionDetectionType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = PCDT_OPERATOR;
    return RTI_TRUE;
}

RTIBool tms_PowerConnectionDetectionType_finalize_w_return(
    tms_PowerConnectionDetectionType* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerConnectionDetectionType_finalize(
    tms_PowerConnectionDetectionType* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerConnectionDetectionType_finalize_ex(
    tms_PowerConnectionDetectionType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerConnectionDetectionType_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerConnectionDetectionType_finalize_w_params(
    tms_PowerConnectionDetectionType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerConnectionDetectionType_finalize_optional_members(
    tms_PowerConnectionDetectionType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerConnectionDetectionType_copy(
    tms_PowerConnectionDetectionType* dst,
    const tms_PowerConnectionDetectionType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerConnectionDetectionType' sequence class.
*/
#define T tms_PowerConnectionDetectionType
#define TSeq tms_PowerConnectionDetectionTypeSeq

#define T_initialize_w_params tms_PowerConnectionDetectionType_initialize_w_params

#define T_finalize_w_params   tms_PowerConnectionDetectionType_finalize_w_params
#define T_copy       tms_PowerConnectionDetectionType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerConnectionTYPENAME = "tms::PowerConnection";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerConnection_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerConnection_g_tc_members[4]=
    {

        {
            (char *)"connectionId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"detectionType",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"detectionSource",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"detectionConfidence",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerConnection_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerConnection", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_PowerConnection_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerConnection*/

    if (is_initialized) {
        return &tms_PowerConnection_g_tc;
    }

    tms_PowerConnection_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerConnection_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerConnectionId_get_typecode();
    tms_PowerConnection_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PowerConnectionDetectionType_get_typecode();
    tms_PowerConnection_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_PowerConnection_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_PowerConnection_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerConnection_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerConnection_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerConnection_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerConnection_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerConnection_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerConnection_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerConnection_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerConnection_g_tc._data._sampleAccessInfo =
    tms_PowerConnection_get_sample_access_info();
    tms_PowerConnection_g_tc._data._typePlugin =
    tms_PowerConnection_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerConnection_g_tc;
}

#define TSeq tms_PowerConnectionSeq
#define T tms_PowerConnection
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerConnection_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerConnection_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerConnectionSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerConnectionSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerConnection_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerConnection_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerConnection *sample;

    static RTIXCdrMemberAccessInfo tms_PowerConnection_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerConnection_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerConnection_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerConnection);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerConnection_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->connectionId - (char *)sample);

    tms_PowerConnection_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->detectionType - (char *)sample);

    tms_PowerConnection_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->detectionSource - (char *)sample);

    tms_PowerConnection_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->detectionConfidence - (char *)sample);

    tms_PowerConnection_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerConnection_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerConnection);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerConnection_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerConnection_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerConnection_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerConnection_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerConnection_get_member_value_pointer;

    tms_PowerConnection_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerConnection_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerConnection_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerConnection_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerConnection_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerConnection_finalize_w_return,
        NULL
    };

    return &tms_PowerConnection_g_typePlugin;
}
#endif

RTIBool tms_PowerConnection_initialize(
    tms_PowerConnection* sample) {
    return tms_PowerConnection_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerConnection_initialize_ex(
    tms_PowerConnection* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerConnection_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerConnection_initialize_w_params(
    tms_PowerConnection* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_PowerConnectionId_initialize_w_params(&sample->connectionId,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->detectionType = PCDT_OPERATOR;
    if (!tms_Fingerprint_initialize_w_params(&sample->detectionSource,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->detectionConfidence = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_PowerConnection_finalize_w_return(
    tms_PowerConnection* sample)
{
    tms_PowerConnection_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerConnection_finalize(
    tms_PowerConnection* sample)
{

    tms_PowerConnection_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerConnection_finalize_ex(
    tms_PowerConnection* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerConnection_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerConnection_finalize_w_params(
    tms_PowerConnection* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_PowerConnectionId_finalize_w_params(&sample->connectionId,deallocParams);

    tms_PowerConnectionDetectionType_finalize_w_params(&sample->detectionType,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->detectionSource,deallocParams);

}

void tms_PowerConnection_finalize_optional_members(
    tms_PowerConnection* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerConnection_copy(
    tms_PowerConnection* dst,
    const tms_PowerConnection* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_PowerConnectionId_copy(
            &dst->connectionId,(const tms_PowerConnectionId*)&src->connectionId)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerConnectionDetectionType_copy(
            &dst->detectionType,(const tms_PowerConnectionDetectionType*)&src->detectionType)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->detectionSource,(const tms_Fingerprint*)&src->detectionSource)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->detectionConfidence, &src->detectionConfidence)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerConnection' sequence class.
*/
#define T tms_PowerConnection
#define TSeq tms_PowerConnectionSeq

#define T_initialize_w_params tms_PowerConnection_initialize_w_params

#define T_finalize_w_params   tms_PowerConnection_finalize_w_params
#define T_copy       tms_PowerConnection_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DevicePowerPortTypesTYPENAME = "tms::DevicePowerPortTypes";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DevicePowerPortTypes_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DevicePowerPortTypes_g_tc_ports_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_ports)),NULL);

    static DDS_TypeCode_Member tms_DevicePowerPortTypes_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ports",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DevicePowerPortTypes_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DevicePowerPortTypes", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_DevicePowerPortTypes_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DevicePowerPortTypes*/

    if (is_initialized) {
        return &tms_DevicePowerPortTypes_g_tc;
    }

    tms_DevicePowerPortTypes_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DevicePowerPortTypes_g_tc_ports_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortType_get_typecode();
    tms_DevicePowerPortTypes_g_tc_ports_sequence._data._sampleAccessInfo = tms_PowerPortType_get_sample_seq_access_info();
    tms_DevicePowerPortTypes_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DevicePowerPortTypes_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_DevicePowerPortTypes_g_tc_ports_sequence;

    /* Initialize the values for member annotations. */

    tms_DevicePowerPortTypes_g_tc._data._sampleAccessInfo =
    tms_DevicePowerPortTypes_get_sample_access_info();
    tms_DevicePowerPortTypes_g_tc._data._typePlugin =
    tms_DevicePowerPortTypes_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DevicePowerPortTypes_g_tc;
}

#define TSeq tms_DevicePowerPortTypesSeq
#define T tms_DevicePowerPortTypes
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DevicePowerPortTypes_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DevicePowerPortTypes_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DevicePowerPortTypesSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DevicePowerPortTypesSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DevicePowerPortTypes_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DevicePowerPortTypes_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DevicePowerPortTypes *sample;

    static RTIXCdrMemberAccessInfo tms_DevicePowerPortTypes_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DevicePowerPortTypes_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DevicePowerPortTypes_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DevicePowerPortTypes);
    if (sample == NULL) {
        return NULL;
    }

    tms_DevicePowerPortTypes_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DevicePowerPortTypes_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->ports - (char *)sample);

    tms_DevicePowerPortTypes_g_sampleAccessInfo.memberAccessInfos = 
    tms_DevicePowerPortTypes_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DevicePowerPortTypes);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DevicePowerPortTypes_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DevicePowerPortTypes_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DevicePowerPortTypes_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DevicePowerPortTypes_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DevicePowerPortTypes_get_member_value_pointer;

    tms_DevicePowerPortTypes_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DevicePowerPortTypes_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DevicePowerPortTypes_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DevicePowerPortTypes_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DevicePowerPortTypes_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DevicePowerPortTypes_finalize_w_return,
        NULL
    };

    return &tms_DevicePowerPortTypes_g_typePlugin;
}
#endif

RTIBool tms_DevicePowerPortTypes_initialize(
    tms_DevicePowerPortTypes* sample) {
    return tms_DevicePowerPortTypes_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DevicePowerPortTypes_initialize_ex(
    tms_DevicePowerPortTypes* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DevicePowerPortTypes_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DevicePowerPortTypes_initialize_w_params(
    tms_DevicePowerPortTypes* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerPortTypeSeq_initialize(&sample->ports )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortTypeSeq_set_element_allocation_params(&sample->ports ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortTypeSeq_set_absolute_maximum(&sample->ports , ((tms_MAXLEN_ports)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortTypeSeq_set_maximum(&sample->ports, ((tms_MAXLEN_ports)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortTypeSeq_set_length(&sample->ports, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DevicePowerPortTypes_finalize_w_return(
    tms_DevicePowerPortTypes* sample)
{
    tms_DevicePowerPortTypes_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DevicePowerPortTypes_finalize(
    tms_DevicePowerPortTypes* sample)
{

    tms_DevicePowerPortTypes_finalize_ex(sample,RTI_TRUE);
}

void tms_DevicePowerPortTypes_finalize_ex(
    tms_DevicePowerPortTypes* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DevicePowerPortTypes_finalize_w_params(
        sample,&deallocParams);
}

void tms_DevicePowerPortTypes_finalize_w_params(
    tms_DevicePowerPortTypes* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_PowerPortTypeSeq_set_element_deallocation_params(
        &sample->ports,deallocParams)){
        return; 
    }
    if(!tms_PowerPortTypeSeq_finalize(&sample->ports)){
        return;
    }

}

void tms_DevicePowerPortTypes_finalize_optional_members(
    tms_DevicePowerPortTypes* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DevicePowerPortTypes_copy(
    tms_DevicePowerPortTypes* dst,
    const tms_DevicePowerPortTypes* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerPortTypeSeq_copy(&dst->ports ,
        &src->ports )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DevicePowerPortTypes' sequence class.
*/
#define T tms_DevicePowerPortTypes
#define TSeq tms_DevicePowerPortTypesSeq

#define T_initialize_w_params tms_DevicePowerPortTypes_initialize_w_params

#define T_finalize_w_params   tms_DevicePowerPortTypes_finalize_w_params
#define T_copy       tms_DevicePowerPortTypes_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DevicePowerPortStatusesTYPENAME = "tms::DevicePowerPortStatuses";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DevicePowerPortStatuses_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DevicePowerPortStatuses_g_tc_ports_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_ports)),NULL);

    static DDS_TypeCode_Member tms_DevicePowerPortStatuses_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ports",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DevicePowerPortStatuses_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DevicePowerPortStatuses", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_DevicePowerPortStatuses_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DevicePowerPortStatuses*/

    if (is_initialized) {
        return &tms_DevicePowerPortStatuses_g_tc;
    }

    tms_DevicePowerPortStatuses_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DevicePowerPortStatuses_g_tc_ports_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortStatus_get_typecode();
    tms_DevicePowerPortStatuses_g_tc_ports_sequence._data._sampleAccessInfo = tms_PowerPortStatus_get_sample_seq_access_info();
    tms_DevicePowerPortStatuses_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DevicePowerPortStatuses_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_DevicePowerPortStatuses_g_tc_ports_sequence;

    /* Initialize the values for member annotations. */

    tms_DevicePowerPortStatuses_g_tc._data._sampleAccessInfo =
    tms_DevicePowerPortStatuses_get_sample_access_info();
    tms_DevicePowerPortStatuses_g_tc._data._typePlugin =
    tms_DevicePowerPortStatuses_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DevicePowerPortStatuses_g_tc;
}

#define TSeq tms_DevicePowerPortStatusesSeq
#define T tms_DevicePowerPortStatuses
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DevicePowerPortStatuses_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DevicePowerPortStatuses_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DevicePowerPortStatusesSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DevicePowerPortStatusesSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DevicePowerPortStatuses_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DevicePowerPortStatuses_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DevicePowerPortStatuses *sample;

    static RTIXCdrMemberAccessInfo tms_DevicePowerPortStatuses_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DevicePowerPortStatuses_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DevicePowerPortStatuses_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DevicePowerPortStatuses);
    if (sample == NULL) {
        return NULL;
    }

    tms_DevicePowerPortStatuses_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DevicePowerPortStatuses_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->ports - (char *)sample);

    tms_DevicePowerPortStatuses_g_sampleAccessInfo.memberAccessInfos = 
    tms_DevicePowerPortStatuses_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DevicePowerPortStatuses);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DevicePowerPortStatuses_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DevicePowerPortStatuses_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DevicePowerPortStatuses_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DevicePowerPortStatuses_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DevicePowerPortStatuses_get_member_value_pointer;

    tms_DevicePowerPortStatuses_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DevicePowerPortStatuses_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DevicePowerPortStatuses_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DevicePowerPortStatuses_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DevicePowerPortStatuses_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DevicePowerPortStatuses_finalize_w_return,
        NULL
    };

    return &tms_DevicePowerPortStatuses_g_typePlugin;
}
#endif

RTIBool tms_DevicePowerPortStatuses_initialize(
    tms_DevicePowerPortStatuses* sample) {
    return tms_DevicePowerPortStatuses_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DevicePowerPortStatuses_initialize_ex(
    tms_DevicePowerPortStatuses* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DevicePowerPortStatuses_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DevicePowerPortStatuses_initialize_w_params(
    tms_DevicePowerPortStatuses* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerPortStatusSeq_initialize(&sample->ports )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortStatusSeq_set_element_allocation_params(&sample->ports ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortStatusSeq_set_absolute_maximum(&sample->ports , ((tms_MAXLEN_ports)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortStatusSeq_set_maximum(&sample->ports, ((tms_MAXLEN_ports)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortStatusSeq_set_length(&sample->ports, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DevicePowerPortStatuses_finalize_w_return(
    tms_DevicePowerPortStatuses* sample)
{
    tms_DevicePowerPortStatuses_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DevicePowerPortStatuses_finalize(
    tms_DevicePowerPortStatuses* sample)
{

    tms_DevicePowerPortStatuses_finalize_ex(sample,RTI_TRUE);
}

void tms_DevicePowerPortStatuses_finalize_ex(
    tms_DevicePowerPortStatuses* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DevicePowerPortStatuses_finalize_w_params(
        sample,&deallocParams);
}

void tms_DevicePowerPortStatuses_finalize_w_params(
    tms_DevicePowerPortStatuses* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_PowerPortStatusSeq_set_element_deallocation_params(
        &sample->ports,deallocParams)){
        return; 
    }
    if(!tms_PowerPortStatusSeq_finalize(&sample->ports)){
        return;
    }

}

void tms_DevicePowerPortStatuses_finalize_optional_members(
    tms_DevicePowerPortStatuses* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DevicePowerPortStatuses_copy(
    tms_DevicePowerPortStatuses* dst,
    const tms_DevicePowerPortStatuses* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerPortStatusSeq_copy(&dst->ports ,
        &src->ports )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DevicePowerPortStatuses' sequence class.
*/
#define T tms_DevicePowerPortStatuses
#define TSeq tms_DevicePowerPortStatusesSeq

#define T_initialize_w_params tms_DevicePowerPortStatuses_initialize_w_params

#define T_finalize_w_params   tms_DevicePowerPortStatuses_finalize_w_params
#define T_copy       tms_DevicePowerPortStatuses_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerConnectionListTYPENAME = "tms::PowerConnectionList";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerConnectionList_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_PowerConnectionList_g_tc_connections_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_connections)),NULL);

    static DDS_TypeCode_Member tms_PowerConnectionList_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"connections",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerConnectionList_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerConnectionList", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_PowerConnectionList_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerConnectionList*/

    if (is_initialized) {
        return &tms_PowerConnectionList_g_tc;
    }

    tms_PowerConnectionList_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerConnectionList_g_tc_connections_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerConnection_get_typecode();
    tms_PowerConnectionList_g_tc_connections_sequence._data._sampleAccessInfo = tms_PowerConnection_get_sample_seq_access_info();
    tms_PowerConnectionList_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_PowerConnectionList_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_PowerConnectionList_g_tc_connections_sequence;

    /* Initialize the values for member annotations. */

    tms_PowerConnectionList_g_tc._data._sampleAccessInfo =
    tms_PowerConnectionList_get_sample_access_info();
    tms_PowerConnectionList_g_tc._data._typePlugin =
    tms_PowerConnectionList_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerConnectionList_g_tc;
}

#define TSeq tms_PowerConnectionListSeq
#define T tms_PowerConnectionList
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerConnectionList_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerConnectionList_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerConnectionListSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerConnectionListSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerConnectionList_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerConnectionList_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerConnectionList *sample;

    static RTIXCdrMemberAccessInfo tms_PowerConnectionList_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerConnectionList_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectionList_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerConnectionList);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerConnectionList_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_PowerConnectionList_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->connections - (char *)sample);

    tms_PowerConnectionList_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerConnectionList_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerConnectionList);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerConnectionList_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerConnectionList_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerConnectionList_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerConnectionList_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerConnectionList_get_member_value_pointer;

    tms_PowerConnectionList_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerConnectionList_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerConnectionList_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerConnectionList_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerConnectionList_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerConnectionList_finalize_w_return,
        NULL
    };

    return &tms_PowerConnectionList_g_typePlugin;
}
#endif

RTIBool tms_PowerConnectionList_initialize(
    tms_PowerConnectionList* sample) {
    return tms_PowerConnectionList_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerConnectionList_initialize_ex(
    tms_PowerConnectionList* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerConnectionList_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerConnectionList_initialize_w_params(
    tms_PowerConnectionList* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerConnectionSeq_initialize(&sample->connections )){
            return RTI_FALSE;
        };
        if(!tms_PowerConnectionSeq_set_element_allocation_params(&sample->connections ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerConnectionSeq_set_absolute_maximum(&sample->connections , ((tms_MAXLEN_connections)))){
            return RTI_FALSE;
        }
        if (!tms_PowerConnectionSeq_set_maximum(&sample->connections, ((tms_MAXLEN_connections)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerConnectionSeq_set_length(&sample->connections, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_PowerConnectionList_finalize_w_return(
    tms_PowerConnectionList* sample)
{
    tms_PowerConnectionList_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerConnectionList_finalize(
    tms_PowerConnectionList* sample)
{

    tms_PowerConnectionList_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerConnectionList_finalize_ex(
    tms_PowerConnectionList* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerConnectionList_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerConnectionList_finalize_w_params(
    tms_PowerConnectionList* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_PowerConnectionSeq_set_element_deallocation_params(
        &sample->connections,deallocParams)){
        return; 
    }
    if(!tms_PowerConnectionSeq_finalize(&sample->connections)){
        return;
    }

}

void tms_PowerConnectionList_finalize_optional_members(
    tms_PowerConnectionList* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerConnectionList_copy(
    tms_PowerConnectionList* dst,
    const tms_PowerConnectionList* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerConnectionSeq_copy(&dst->connections ,
        &src->connections )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerConnectionList' sequence class.
*/
#define T tms_PowerConnectionList
#define TSeq tms_PowerConnectionListSeq

#define T_initialize_w_params tms_PowerConnectionList_initialize_w_params

#define T_finalize_w_params   tms_PowerConnectionList_finalize_w_params
#define T_copy       tms_PowerConnectionList_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GroundingCircuitNumber_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_GroundingCircuitNumber_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::GroundingCircuitNumber", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_GroundingCircuitNumber */

    if (is_initialized) {
        return &tms_GroundingCircuitNumber_g_tc;
    }

    tms_GroundingCircuitNumber_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_GroundingCircuitNumber_g_tc._data._typeCode =  (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;

    /* Initialize the values for member annotations. */
    tms_GroundingCircuitNumber_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingCircuitNumber_g_tc._data._annotations._defaultValue._u.ulong_value = 0u;
    tms_GroundingCircuitNumber_g_tc._data._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingCircuitNumber_g_tc._data._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_GroundingCircuitNumber_g_tc._data._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingCircuitNumber_g_tc._data._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_GroundingCircuitNumber_g_tc._data._sampleAccessInfo =
    tms_GroundingCircuitNumber_get_sample_access_info();
    tms_GroundingCircuitNumber_g_tc._data._typePlugin =
    tms_GroundingCircuitNumber_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GroundingCircuitNumber_g_tc;
}

#define TSeq tms_GroundingCircuitNumberSeq
#define T tms_GroundingCircuitNumber
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GroundingCircuitNumber_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GroundingCircuitNumber_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GroundingCircuitNumberSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GroundingCircuitNumberSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GroundingCircuitNumber_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GroundingCircuitNumber_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_GroundingCircuitNumber_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GroundingCircuitNumber_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GroundingCircuitNumber_g_sampleAccessInfo;
    }

    tms_GroundingCircuitNumber_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_GroundingCircuitNumber_g_sampleAccessInfo.memberAccessInfos = 
    tms_GroundingCircuitNumber_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GroundingCircuitNumber);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GroundingCircuitNumber_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GroundingCircuitNumber_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GroundingCircuitNumber_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GroundingCircuitNumber_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GroundingCircuitNumber_get_member_value_pointer;

    tms_GroundingCircuitNumber_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GroundingCircuitNumber_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GroundingCircuitNumber_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GroundingCircuitNumber_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GroundingCircuitNumber_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GroundingCircuitNumber_finalize_w_return,
        NULL
    };

    return &tms_GroundingCircuitNumber_g_typePlugin;
}
#endif

RTIBool tms_GroundingCircuitNumber_initialize(
    tms_GroundingCircuitNumber* sample) {
    return tms_GroundingCircuitNumber_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_GroundingCircuitNumber_initialize_ex(
    tms_GroundingCircuitNumber* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GroundingCircuitNumber_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GroundingCircuitNumber_initialize_w_params(
    tms_GroundingCircuitNumber* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    (*sample) = 0u;

    return RTI_TRUE;
}

RTIBool tms_GroundingCircuitNumber_finalize_w_return(
    tms_GroundingCircuitNumber* sample)
{
    tms_GroundingCircuitNumber_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_GroundingCircuitNumber_finalize(
    tms_GroundingCircuitNumber* sample)
{

    tms_GroundingCircuitNumber_finalize_ex(sample,RTI_TRUE);
}

void tms_GroundingCircuitNumber_finalize_ex(
    tms_GroundingCircuitNumber* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GroundingCircuitNumber_finalize_w_params(
        sample,&deallocParams);
}

void tms_GroundingCircuitNumber_finalize_w_params(
    tms_GroundingCircuitNumber* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_GroundingCircuitNumber_finalize_optional_members(
    tms_GroundingCircuitNumber* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GroundingCircuitNumber_copy(
    tms_GroundingCircuitNumber* dst,
    const tms_GroundingCircuitNumber* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            dst, src)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GroundingCircuitNumber' sequence class.
*/
#define T tms_GroundingCircuitNumber
#define TSeq tms_GroundingCircuitNumberSeq

#define T_initialize_w_params tms_GroundingCircuitNumber_initialize_w_params

#define T_finalize_w_params   tms_GroundingCircuitNumber_finalize_w_params
#define T_copy       tms_GroundingCircuitNumber_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_GroundingDesignTypeTYPENAME = "tms::GroundingDesignType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GroundingDesignType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_GroundingDesignType_g_tc_members[6]=
    {

        {
            (char *)"GROUNDING_INVALID",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GROUNDING_INVALID, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GROUNDING_UNGROUNDED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GROUNDING_UNGROUNDED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GROUNDING_SOLID",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GROUNDING_SOLID, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GROUNDING_HIGH_RESISTANCE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GROUNDING_HIGH_RESISTANCE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GROUNDING_LOW_RESISTANCE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GROUNDING_LOW_RESISTANCE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GROUNDING_REACTANCE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GROUNDING_REACTANCE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_GroundingDesignType_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::GroundingDesignType", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_GroundingDesignType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_GroundingDesignType*/

    if (is_initialized) {
        return &tms_GroundingDesignType_g_tc;
    }

    tms_GroundingDesignType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_GroundingDesignType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundingDesignType_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_GroundingDesignType_g_tc._data._sampleAccessInfo =
    tms_GroundingDesignType_get_sample_access_info();
    tms_GroundingDesignType_g_tc._data._typePlugin =
    tms_GroundingDesignType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GroundingDesignType_g_tc;
}

#define TSeq tms_GroundingDesignTypeSeq
#define T tms_GroundingDesignType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GroundingDesignType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GroundingDesignType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GroundingDesignTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GroundingDesignTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GroundingDesignType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GroundingDesignType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_GroundingDesignType_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GroundingDesignType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GroundingDesignType_g_sampleAccessInfo;
    }

    tms_GroundingDesignType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_GroundingDesignType_g_sampleAccessInfo.memberAccessInfos = 
    tms_GroundingDesignType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GroundingDesignType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GroundingDesignType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GroundingDesignType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GroundingDesignType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GroundingDesignType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GroundingDesignType_get_member_value_pointer;

    tms_GroundingDesignType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GroundingDesignType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GroundingDesignType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GroundingDesignType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GroundingDesignType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GroundingDesignType_finalize_w_return,
        NULL
    };

    return &tms_GroundingDesignType_g_typePlugin;
}
#endif

RTIBool tms_GroundingDesignType_initialize(
    tms_GroundingDesignType* sample) {
    *sample = GROUNDING_INVALID;
    return RTI_TRUE;
}

RTIBool tms_GroundingDesignType_initialize_ex(
    tms_GroundingDesignType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GroundingDesignType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GroundingDesignType_initialize_w_params(
    tms_GroundingDesignType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = GROUNDING_INVALID;
    return RTI_TRUE;
}

RTIBool tms_GroundingDesignType_finalize_w_return(
    tms_GroundingDesignType* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_GroundingDesignType_finalize(
    tms_GroundingDesignType* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_GroundingDesignType_finalize_ex(
    tms_GroundingDesignType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GroundingDesignType_finalize_w_params(
        sample,&deallocParams);
}

void tms_GroundingDesignType_finalize_w_params(
    tms_GroundingDesignType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_GroundingDesignType_finalize_optional_members(
    tms_GroundingDesignType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GroundingDesignType_copy(
    tms_GroundingDesignType* dst,
    const tms_GroundingDesignType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GroundingDesignType' sequence class.
*/
#define T tms_GroundingDesignType
#define TSeq tms_GroundingDesignTypeSeq

#define T_initialize_w_params tms_GroundingDesignType_initialize_w_params

#define T_finalize_w_params   tms_GroundingDesignType_finalize_w_params
#define T_copy       tms_GroundingDesignType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_GroundingTypeTYPENAME = "tms::GroundingType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GroundingType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_GroundingType_g_tc_protectedPorts_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_protectedPorts)),NULL);

    static DDS_TypeCode_Member tms_GroundingType_g_tc_members[5]=
    {

        {
            (char *)"groundNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"type",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"protectedPorts",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"controlType",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"pulseType",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_GroundingType_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::GroundingType", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_GroundingType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_GroundingType*/

    if (is_initialized) {
        return &tms_GroundingType_g_tc;
    }

    tms_GroundingType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_GroundingType_g_tc_protectedPorts_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_GroundingType_g_tc_protectedPorts_sequence._data._sampleAccessInfo = tms_PowerPortNumber_get_sample_seq_access_info();
    tms_GroundingType_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_GroundingCircuitNumber_get_typecode();
    tms_GroundingType_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_GroundingDesignType_get_typecode();
    tms_GroundingType_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)& tms_GroundingType_g_tc_protectedPorts_sequence;
    tms_GroundingType_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_PowerSwitchControl_get_typecode();
    tms_GroundingType_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_PowerSwitchControl_get_typecode();

    /* Initialize the values for member annotations. */
    tms_GroundingType_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingType_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_GroundingType_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingType_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_GroundingType_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingType_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_GroundingType_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundingType_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_GroundingType_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundingType_g_tc_members[3]._annotations._defaultValue._u.enumerated_value = 0;

    tms_GroundingType_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundingType_g_tc_members[4]._annotations._defaultValue._u.enumerated_value = 0;

    tms_GroundingType_g_tc._data._sampleAccessInfo =
    tms_GroundingType_get_sample_access_info();
    tms_GroundingType_g_tc._data._typePlugin =
    tms_GroundingType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GroundingType_g_tc;
}

#define TSeq tms_GroundingTypeSeq
#define T tms_GroundingType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GroundingType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GroundingType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GroundingTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GroundingTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GroundingType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GroundingType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_GroundingType *sample;

    static RTIXCdrMemberAccessInfo tms_GroundingType_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GroundingType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GroundingType_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_GroundingType);
    if (sample == NULL) {
        return NULL;
    }

    tms_GroundingType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->groundNumber - (char *)sample);

    tms_GroundingType_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->type - (char *)sample);

    tms_GroundingType_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->protectedPorts - (char *)sample);

    tms_GroundingType_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->controlType - (char *)sample);

    tms_GroundingType_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->pulseType - (char *)sample);

    tms_GroundingType_g_sampleAccessInfo.memberAccessInfos = 
    tms_GroundingType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GroundingType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GroundingType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GroundingType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GroundingType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GroundingType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GroundingType_get_member_value_pointer;

    tms_GroundingType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GroundingType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GroundingType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GroundingType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GroundingType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GroundingType_finalize_w_return,
        NULL
    };

    return &tms_GroundingType_g_typePlugin;
}
#endif

RTIBool tms_GroundingType_initialize(
    tms_GroundingType* sample) {
    return tms_GroundingType_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_GroundingType_initialize_ex(
    tms_GroundingType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GroundingType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GroundingType_initialize_w_params(
    tms_GroundingType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->groundNumber = 0u;

    sample->type = GROUNDING_INVALID;
    if (allocParams->allocate_memory) {
        if(!DDS_UnsignedLongSeq_initialize(&sample->protectedPorts  )){
            return RTI_FALSE;
        }
        if(!DDS_UnsignedLongSeq_set_absolute_maximum(&sample->protectedPorts , ((tms_MAXLEN_protectedPorts)))){
            return RTI_FALSE;
        }
        if (!DDS_UnsignedLongSeq_set_maximum(&sample->protectedPorts , ((tms_MAXLEN_protectedPorts)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!DDS_UnsignedLongSeq_set_length(&sample->protectedPorts, 0)){
            return RTI_FALSE;
        }    
    }
    sample->controlType = PSC_NONE;
    sample->pulseType = PSC_NONE;
    return RTI_TRUE;
}

RTIBool tms_GroundingType_finalize_w_return(
    tms_GroundingType* sample)
{
    tms_GroundingType_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_GroundingType_finalize(
    tms_GroundingType* sample)
{

    tms_GroundingType_finalize_ex(sample,RTI_TRUE);
}

void tms_GroundingType_finalize_ex(
    tms_GroundingType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GroundingType_finalize_w_params(
        sample,&deallocParams);
}

void tms_GroundingType_finalize_w_params(
    tms_GroundingType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_GroundingDesignType_finalize_w_params(&sample->type,deallocParams);

    if(!DDS_UnsignedLongSeq_finalize(&sample->protectedPorts)){
        return;
    }

    tms_PowerSwitchControl_finalize_w_params(&sample->controlType,deallocParams);

    tms_PowerSwitchControl_finalize_w_params(&sample->pulseType,deallocParams);

}

void tms_GroundingType_finalize_optional_members(
    tms_GroundingType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GroundingType_copy(
    tms_GroundingType* dst,
    const tms_GroundingType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->groundNumber, &src->groundNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_GroundingDesignType_copy(
            &dst->type,(const tms_GroundingDesignType*)&src->type)) {
            return RTI_FALSE;
        } 
        if (!DDS_UnsignedLongSeq_copy(&dst->protectedPorts ,
        &src->protectedPorts )) {
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchControl_copy(
            &dst->controlType,(const tms_PowerSwitchControl*)&src->controlType)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerSwitchControl_copy(
            &dst->pulseType,(const tms_PowerSwitchControl*)&src->pulseType)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GroundingType' sequence class.
*/
#define T tms_GroundingType
#define TSeq tms_GroundingTypeSeq

#define T_initialize_w_params tms_GroundingType_initialize_w_params

#define T_finalize_w_params   tms_GroundingType_finalize_w_params
#define T_copy       tms_GroundingType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceGroundingTypeTYPENAME = "tms::DeviceGroundingType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceGroundingType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DeviceGroundingType_g_tc_grounds_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_grounds)),NULL);

    static DDS_TypeCode_Member tms_DeviceGroundingType_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"grounds",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceGroundingType_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceGroundingType", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_DeviceGroundingType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceGroundingType*/

    if (is_initialized) {
        return &tms_DeviceGroundingType_g_tc;
    }

    tms_DeviceGroundingType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DeviceGroundingType_g_tc_grounds_sequence._data._typeCode = (RTICdrTypeCode *)tms_GroundingType_get_typecode();
    tms_DeviceGroundingType_g_tc_grounds_sequence._data._sampleAccessInfo = tms_GroundingType_get_sample_seq_access_info();
    tms_DeviceGroundingType_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DeviceGroundingType_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_DeviceGroundingType_g_tc_grounds_sequence;

    /* Initialize the values for member annotations. */

    tms_DeviceGroundingType_g_tc._data._sampleAccessInfo =
    tms_DeviceGroundingType_get_sample_access_info();
    tms_DeviceGroundingType_g_tc._data._typePlugin =
    tms_DeviceGroundingType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceGroundingType_g_tc;
}

#define TSeq tms_DeviceGroundingTypeSeq
#define T tms_DeviceGroundingType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceGroundingType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceGroundingType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceGroundingTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceGroundingTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceGroundingType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceGroundingType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DeviceGroundingType *sample;

    static RTIXCdrMemberAccessInfo tms_DeviceGroundingType_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceGroundingType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceGroundingType_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DeviceGroundingType);
    if (sample == NULL) {
        return NULL;
    }

    tms_DeviceGroundingType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DeviceGroundingType_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->grounds - (char *)sample);

    tms_DeviceGroundingType_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceGroundingType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceGroundingType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceGroundingType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceGroundingType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceGroundingType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceGroundingType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceGroundingType_get_member_value_pointer;

    tms_DeviceGroundingType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceGroundingType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceGroundingType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceGroundingType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceGroundingType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceGroundingType_finalize_w_return,
        NULL
    };

    return &tms_DeviceGroundingType_g_typePlugin;
}
#endif

RTIBool tms_DeviceGroundingType_initialize(
    tms_DeviceGroundingType* sample) {
    return tms_DeviceGroundingType_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DeviceGroundingType_initialize_ex(
    tms_DeviceGroundingType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceGroundingType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceGroundingType_initialize_w_params(
    tms_DeviceGroundingType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_GroundingTypeSeq_initialize(&sample->grounds )){
            return RTI_FALSE;
        };
        if(!tms_GroundingTypeSeq_set_element_allocation_params(&sample->grounds ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_GroundingTypeSeq_set_absolute_maximum(&sample->grounds , ((tms_MAXLEN_grounds)))){
            return RTI_FALSE;
        }
        if (!tms_GroundingTypeSeq_set_maximum(&sample->grounds, ((tms_MAXLEN_grounds)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_GroundingTypeSeq_set_length(&sample->grounds, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DeviceGroundingType_finalize_w_return(
    tms_DeviceGroundingType* sample)
{
    tms_DeviceGroundingType_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DeviceGroundingType_finalize(
    tms_DeviceGroundingType* sample)
{

    tms_DeviceGroundingType_finalize_ex(sample,RTI_TRUE);
}

void tms_DeviceGroundingType_finalize_ex(
    tms_DeviceGroundingType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceGroundingType_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceGroundingType_finalize_w_params(
    tms_DeviceGroundingType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_GroundingTypeSeq_set_element_deallocation_params(
        &sample->grounds,deallocParams)){
        return; 
    }
    if(!tms_GroundingTypeSeq_finalize(&sample->grounds)){
        return;
    }

}

void tms_DeviceGroundingType_finalize_optional_members(
    tms_DeviceGroundingType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceGroundingType_copy(
    tms_DeviceGroundingType* dst,
    const tms_DeviceGroundingType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_GroundingTypeSeq_copy(&dst->grounds ,
        &src->grounds )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceGroundingType' sequence class.
*/
#define T tms_DeviceGroundingType
#define TSeq tms_DeviceGroundingTypeSeq

#define T_initialize_w_params tms_DeviceGroundingType_initialize_w_params

#define T_finalize_w_params   tms_DeviceGroundingType_finalize_w_params
#define T_copy       tms_DeviceGroundingType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_GroundFaultDetectionTYPENAME = "tms::GroundFaultDetection";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GroundFaultDetection_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_GroundFaultDetection_g_tc_members[8]=
    {

        {
            (char *)"GFD_INVALID",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_INVALID, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GFD_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GFD_ANY",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_ANY, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GFD_A",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_A, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GFD_B",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_B, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GFD_C",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_C, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GFD_DCPOS",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_DCPOS, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"GFD_DCNEG",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            GFD_DCNEG, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_GroundFaultDetection_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::GroundFaultDetection", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            8, /* Number of members */
            tms_GroundFaultDetection_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_GroundFaultDetection*/

    if (is_initialized) {
        return &tms_GroundFaultDetection_g_tc;
    }

    tms_GroundFaultDetection_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_GroundFaultDetection_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundFaultDetection_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_GroundFaultDetection_g_tc._data._sampleAccessInfo =
    tms_GroundFaultDetection_get_sample_access_info();
    tms_GroundFaultDetection_g_tc._data._typePlugin =
    tms_GroundFaultDetection_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GroundFaultDetection_g_tc;
}

#define TSeq tms_GroundFaultDetectionSeq
#define T tms_GroundFaultDetection
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GroundFaultDetection_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GroundFaultDetection_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GroundFaultDetectionSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GroundFaultDetectionSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GroundFaultDetection_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GroundFaultDetection_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_GroundFaultDetection_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GroundFaultDetection_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GroundFaultDetection_g_sampleAccessInfo;
    }

    tms_GroundFaultDetection_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_GroundFaultDetection_g_sampleAccessInfo.memberAccessInfos = 
    tms_GroundFaultDetection_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GroundFaultDetection);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GroundFaultDetection_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GroundFaultDetection_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GroundFaultDetection_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GroundFaultDetection_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GroundFaultDetection_get_member_value_pointer;

    tms_GroundFaultDetection_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GroundFaultDetection_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GroundFaultDetection_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GroundFaultDetection_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GroundFaultDetection_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GroundFaultDetection_finalize_w_return,
        NULL
    };

    return &tms_GroundFaultDetection_g_typePlugin;
}
#endif

RTIBool tms_GroundFaultDetection_initialize(
    tms_GroundFaultDetection* sample) {
    *sample = GFD_INVALID;
    return RTI_TRUE;
}

RTIBool tms_GroundFaultDetection_initialize_ex(
    tms_GroundFaultDetection* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GroundFaultDetection_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GroundFaultDetection_initialize_w_params(
    tms_GroundFaultDetection* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = GFD_INVALID;
    return RTI_TRUE;
}

RTIBool tms_GroundFaultDetection_finalize_w_return(
    tms_GroundFaultDetection* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_GroundFaultDetection_finalize(
    tms_GroundFaultDetection* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_GroundFaultDetection_finalize_ex(
    tms_GroundFaultDetection* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GroundFaultDetection_finalize_w_params(
        sample,&deallocParams);
}

void tms_GroundFaultDetection_finalize_w_params(
    tms_GroundFaultDetection* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_GroundFaultDetection_finalize_optional_members(
    tms_GroundFaultDetection* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GroundFaultDetection_copy(
    tms_GroundFaultDetection* dst,
    const tms_GroundFaultDetection* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GroundFaultDetection' sequence class.
*/
#define T tms_GroundFaultDetection
#define TSeq tms_GroundFaultDetectionSeq

#define T_initialize_w_params tms_GroundFaultDetection_initialize_w_params

#define T_finalize_w_params   tms_GroundFaultDetection_finalize_w_params
#define T_copy       tms_GroundFaultDetection_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_GroundingStatusTYPENAME = "tms::GroundingStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GroundingStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_GroundingStatus_g_tc_control_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_control)),NULL);
    static DDS_TypeCode tms_GroundingStatus_g_tc_pulse_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_pulse)),NULL);

    static DDS_TypeCode_Member tms_GroundingStatus_g_tc_members[4]=
    {

        {
            (char *)"groundNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"control",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"pulse",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"faultDetection",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_GroundingStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::GroundingStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_GroundingStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_GroundingStatus*/

    if (is_initialized) {
        return &tms_GroundingStatus_g_tc;
    }

    tms_GroundingStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_GroundingStatus_g_tc_control_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerSwitchStatus_get_typecode();
    tms_GroundingStatus_g_tc_control_sequence._data._sampleAccessInfo = tms_PowerSwitchStatus_get_sample_seq_access_info();
    tms_GroundingStatus_g_tc_pulse_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerSwitchStatus_get_typecode();
    tms_GroundingStatus_g_tc_pulse_sequence._data._sampleAccessInfo = tms_PowerSwitchStatus_get_sample_seq_access_info();
    tms_GroundingStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_GroundingCircuitNumber_get_typecode();
    tms_GroundingStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_GroundingStatus_g_tc_control_sequence;
    tms_GroundingStatus_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)& tms_GroundingStatus_g_tc_pulse_sequence;
    tms_GroundingStatus_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_GroundFaultDetection_get_typecode();

    /* Initialize the values for member annotations. */
    tms_GroundingStatus_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingStatus_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_GroundingStatus_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingStatus_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_GroundingStatus_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingStatus_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_GroundingStatus_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundingStatus_g_tc_members[3]._annotations._defaultValue._u.enumerated_value = 0;

    tms_GroundingStatus_g_tc._data._sampleAccessInfo =
    tms_GroundingStatus_get_sample_access_info();
    tms_GroundingStatus_g_tc._data._typePlugin =
    tms_GroundingStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GroundingStatus_g_tc;
}

#define TSeq tms_GroundingStatusSeq
#define T tms_GroundingStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GroundingStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GroundingStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GroundingStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GroundingStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GroundingStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GroundingStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_GroundingStatus *sample;

    static RTIXCdrMemberAccessInfo tms_GroundingStatus_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GroundingStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GroundingStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_GroundingStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_GroundingStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->groundNumber - (char *)sample);

    tms_GroundingStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->control - (char *)sample);

    tms_GroundingStatus_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->pulse - (char *)sample);

    tms_GroundingStatus_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->faultDetection - (char *)sample);

    tms_GroundingStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_GroundingStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GroundingStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GroundingStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GroundingStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GroundingStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GroundingStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GroundingStatus_get_member_value_pointer;

    tms_GroundingStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GroundingStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GroundingStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GroundingStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GroundingStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GroundingStatus_finalize_w_return,
        NULL
    };

    return &tms_GroundingStatus_g_typePlugin;
}
#endif

RTIBool tms_GroundingStatus_initialize(
    tms_GroundingStatus* sample) {
    return tms_GroundingStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_GroundingStatus_initialize_ex(
    tms_GroundingStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GroundingStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GroundingStatus_initialize_w_params(
    tms_GroundingStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->groundNumber = 0u;

    if (allocParams->allocate_memory) {
        if(!tms_PowerSwitchStatusSeq_initialize(&sample->control )){
            return RTI_FALSE;
        };
        if(!tms_PowerSwitchStatusSeq_set_element_allocation_params(&sample->control ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerSwitchStatusSeq_set_absolute_maximum(&sample->control , ((tms_MAXLEN_control)))){
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchStatusSeq_set_maximum(&sample->control, ((tms_MAXLEN_control)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerSwitchStatusSeq_set_length(&sample->control, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerSwitchStatusSeq_initialize(&sample->pulse )){
            return RTI_FALSE;
        };
        if(!tms_PowerSwitchStatusSeq_set_element_allocation_params(&sample->pulse ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerSwitchStatusSeq_set_absolute_maximum(&sample->pulse , ((tms_MAXLEN_pulse)))){
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchStatusSeq_set_maximum(&sample->pulse, ((tms_MAXLEN_pulse)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerSwitchStatusSeq_set_length(&sample->pulse, 0)){
            return RTI_FALSE;
        }    
    }
    sample->faultDetection = GFD_INVALID;
    return RTI_TRUE;
}

RTIBool tms_GroundingStatus_finalize_w_return(
    tms_GroundingStatus* sample)
{
    tms_GroundingStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_GroundingStatus_finalize(
    tms_GroundingStatus* sample)
{

    tms_GroundingStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_GroundingStatus_finalize_ex(
    tms_GroundingStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GroundingStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_GroundingStatus_finalize_w_params(
    tms_GroundingStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!tms_PowerSwitchStatusSeq_set_element_deallocation_params(
        &sample->control,deallocParams)){
        return; 
    }
    if(!tms_PowerSwitchStatusSeq_finalize(&sample->control)){
        return;
    }

    if(!tms_PowerSwitchStatusSeq_set_element_deallocation_params(
        &sample->pulse,deallocParams)){
        return; 
    }
    if(!tms_PowerSwitchStatusSeq_finalize(&sample->pulse)){
        return;
    }

    tms_GroundFaultDetection_finalize_w_params(&sample->faultDetection,deallocParams);

}

void tms_GroundingStatus_finalize_optional_members(
    tms_GroundingStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GroundingStatus_copy(
    tms_GroundingStatus* dst,
    const tms_GroundingStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->groundNumber, &src->groundNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchStatusSeq_copy(&dst->control ,
        &src->control )) {
            return RTI_FALSE;
        }
        if (!tms_PowerSwitchStatusSeq_copy(&dst->pulse ,
        &src->pulse )) {
            return RTI_FALSE;
        }
        if (!tms_GroundFaultDetection_copy(
            &dst->faultDetection,(const tms_GroundFaultDetection*)&src->faultDetection)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GroundingStatus' sequence class.
*/
#define T tms_GroundingStatus
#define TSeq tms_GroundingStatusSeq

#define T_initialize_w_params tms_GroundingStatus_initialize_w_params

#define T_finalize_w_params   tms_GroundingStatus_finalize_w_params
#define T_copy       tms_GroundingStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceGroundingStatusTYPENAME = "tms::DeviceGroundingStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceGroundingStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DeviceGroundingStatus_g_tc_grounds_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_grounds)),NULL);

    static DDS_TypeCode_Member tms_DeviceGroundingStatus_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"grounds",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceGroundingStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceGroundingStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_DeviceGroundingStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceGroundingStatus*/

    if (is_initialized) {
        return &tms_DeviceGroundingStatus_g_tc;
    }

    tms_DeviceGroundingStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DeviceGroundingStatus_g_tc_grounds_sequence._data._typeCode = (RTICdrTypeCode *)tms_GroundingStatus_get_typecode();
    tms_DeviceGroundingStatus_g_tc_grounds_sequence._data._sampleAccessInfo = tms_GroundingStatus_get_sample_seq_access_info();
    tms_DeviceGroundingStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DeviceGroundingStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_DeviceGroundingStatus_g_tc_grounds_sequence;

    /* Initialize the values for member annotations. */

    tms_DeviceGroundingStatus_g_tc._data._sampleAccessInfo =
    tms_DeviceGroundingStatus_get_sample_access_info();
    tms_DeviceGroundingStatus_g_tc._data._typePlugin =
    tms_DeviceGroundingStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceGroundingStatus_g_tc;
}

#define TSeq tms_DeviceGroundingStatusSeq
#define T tms_DeviceGroundingStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceGroundingStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceGroundingStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceGroundingStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceGroundingStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceGroundingStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceGroundingStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DeviceGroundingStatus *sample;

    static RTIXCdrMemberAccessInfo tms_DeviceGroundingStatus_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceGroundingStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceGroundingStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DeviceGroundingStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_DeviceGroundingStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DeviceGroundingStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->grounds - (char *)sample);

    tms_DeviceGroundingStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceGroundingStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceGroundingStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceGroundingStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceGroundingStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceGroundingStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceGroundingStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceGroundingStatus_get_member_value_pointer;

    tms_DeviceGroundingStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceGroundingStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceGroundingStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceGroundingStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceGroundingStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceGroundingStatus_finalize_w_return,
        NULL
    };

    return &tms_DeviceGroundingStatus_g_typePlugin;
}
#endif

RTIBool tms_DeviceGroundingStatus_initialize(
    tms_DeviceGroundingStatus* sample) {
    return tms_DeviceGroundingStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DeviceGroundingStatus_initialize_ex(
    tms_DeviceGroundingStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceGroundingStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceGroundingStatus_initialize_w_params(
    tms_DeviceGroundingStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_GroundingStatusSeq_initialize(&sample->grounds )){
            return RTI_FALSE;
        };
        if(!tms_GroundingStatusSeq_set_element_allocation_params(&sample->grounds ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_GroundingStatusSeq_set_absolute_maximum(&sample->grounds , ((tms_MAXLEN_grounds)))){
            return RTI_FALSE;
        }
        if (!tms_GroundingStatusSeq_set_maximum(&sample->grounds, ((tms_MAXLEN_grounds)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_GroundingStatusSeq_set_length(&sample->grounds, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DeviceGroundingStatus_finalize_w_return(
    tms_DeviceGroundingStatus* sample)
{
    tms_DeviceGroundingStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DeviceGroundingStatus_finalize(
    tms_DeviceGroundingStatus* sample)
{

    tms_DeviceGroundingStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_DeviceGroundingStatus_finalize_ex(
    tms_DeviceGroundingStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceGroundingStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceGroundingStatus_finalize_w_params(
    tms_DeviceGroundingStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_GroundingStatusSeq_set_element_deallocation_params(
        &sample->grounds,deallocParams)){
        return; 
    }
    if(!tms_GroundingStatusSeq_finalize(&sample->grounds)){
        return;
    }

}

void tms_DeviceGroundingStatus_finalize_optional_members(
    tms_DeviceGroundingStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceGroundingStatus_copy(
    tms_DeviceGroundingStatus* dst,
    const tms_DeviceGroundingStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_GroundingStatusSeq_copy(&dst->grounds ,
        &src->grounds )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceGroundingStatus' sequence class.
*/
#define T tms_DeviceGroundingStatus
#define TSeq tms_DeviceGroundingStatusSeq

#define T_initialize_w_params tms_DeviceGroundingStatus_initialize_w_params

#define T_finalize_w_params   tms_DeviceGroundingStatus_finalize_w_params
#define T_copy       tms_DeviceGroundingStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_GroundingCommandTYPENAME = "tms::GroundingCommand";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GroundingCommand_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_GroundingCommand_g_tc_members[6]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"groundNumber",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"control",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"pulse",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_GroundingCommand_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::GroundingCommand", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_GroundingCommand_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_GroundingCommand*/

    if (is_initialized) {
        return &tms_GroundingCommand_g_tc;
    }

    tms_GroundingCommand_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_GroundingCommand_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_GroundingCommand_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_GroundingCommand_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_GroundingCommand_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_GroundingCircuitNumber_get_typecode();
    tms_GroundingCommand_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_DesiredCircuitContinuity_get_typecode();
    tms_GroundingCommand_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_DesiredCircuitContinuity_get_typecode();

    /* Initialize the values for member annotations. */

    tms_GroundingCommand_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_GroundingCommand_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_GroundingCommand_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_GroundingCommand_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_GroundingCommand_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_GroundingCommand_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_GroundingCommand_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingCommand_g_tc_members[3]._annotations._defaultValue._u.ulong_value = 0u;
    tms_GroundingCommand_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingCommand_g_tc_members[3]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_GroundingCommand_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_GroundingCommand_g_tc_members[3]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_GroundingCommand_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundingCommand_g_tc_members[4]._annotations._defaultValue._u.enumerated_value = 0;

    tms_GroundingCommand_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_GroundingCommand_g_tc_members[5]._annotations._defaultValue._u.enumerated_value = 0;

    tms_GroundingCommand_g_tc._data._sampleAccessInfo =
    tms_GroundingCommand_get_sample_access_info();
    tms_GroundingCommand_g_tc._data._typePlugin =
    tms_GroundingCommand_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GroundingCommand_g_tc;
}

#define TSeq tms_GroundingCommandSeq
#define T tms_GroundingCommand
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GroundingCommand_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GroundingCommand_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GroundingCommandSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GroundingCommandSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GroundingCommand_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GroundingCommand_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_GroundingCommand *sample;

    static RTIXCdrMemberAccessInfo tms_GroundingCommand_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GroundingCommand_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GroundingCommand_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_GroundingCommand);
    if (sample == NULL) {
        return NULL;
    }

    tms_GroundingCommand_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_GroundingCommand_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_GroundingCommand_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_GroundingCommand_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->groundNumber - (char *)sample);

    tms_GroundingCommand_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->control - (char *)sample);

    tms_GroundingCommand_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->pulse - (char *)sample);

    tms_GroundingCommand_g_sampleAccessInfo.memberAccessInfos = 
    tms_GroundingCommand_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GroundingCommand);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GroundingCommand_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GroundingCommand_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GroundingCommand_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GroundingCommand_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GroundingCommand_get_member_value_pointer;

    tms_GroundingCommand_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GroundingCommand_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GroundingCommand_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GroundingCommand_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GroundingCommand_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GroundingCommand_finalize_w_return,
        NULL
    };

    return &tms_GroundingCommand_g_typePlugin;
}
#endif

RTIBool tms_GroundingCommand_initialize(
    tms_GroundingCommand* sample) {
    return tms_GroundingCommand_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_GroundingCommand_initialize_ex(
    tms_GroundingCommand* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GroundingCommand_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GroundingCommand_initialize_w_params(
    tms_GroundingCommand* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    sample->groundNumber = 0u;

    sample->control = DCC_OPEN;
    sample->pulse = DCC_OPEN;
    return RTI_TRUE;
}

RTIBool tms_GroundingCommand_finalize_w_return(
    tms_GroundingCommand* sample)
{
    tms_GroundingCommand_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_GroundingCommand_finalize(
    tms_GroundingCommand* sample)
{

    tms_GroundingCommand_finalize_ex(sample,RTI_TRUE);
}

void tms_GroundingCommand_finalize_ex(
    tms_GroundingCommand* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GroundingCommand_finalize_w_params(
        sample,&deallocParams);
}

void tms_GroundingCommand_finalize_w_params(
    tms_GroundingCommand* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_DesiredCircuitContinuity_finalize_w_params(&sample->control,deallocParams);

    tms_DesiredCircuitContinuity_finalize_w_params(&sample->pulse,deallocParams);

}

void tms_GroundingCommand_finalize_optional_members(
    tms_GroundingCommand* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GroundingCommand_copy(
    tms_GroundingCommand* dst,
    const tms_GroundingCommand* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->groundNumber, &src->groundNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_DesiredCircuitContinuity_copy(
            &dst->control,(const tms_DesiredCircuitContinuity*)&src->control)) {
            return RTI_FALSE;
        } 
        if (!tms_DesiredCircuitContinuity_copy(
            &dst->pulse,(const tms_DesiredCircuitContinuity*)&src->pulse)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GroundingCommand' sequence class.
*/
#define T tms_GroundingCommand
#define TSeq tms_GroundingCommandSeq

#define T_initialize_w_params tms_GroundingCommand_initialize_w_params

#define T_finalize_w_params   tms_GroundingCommand_finalize_w_params
#define T_copy       tms_GroundingCommand_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerMeasurementLineTYPENAME = "tms::PowerMeasurementLine";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerMeasurementLine_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerMeasurementLine_g_tc_members[8]=
    {

        {
            (char *)"v",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"i",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"phi",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"p",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"q",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"f",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"vThd",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"iThd",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerMeasurementLine_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerMeasurementLine", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            8, /* Number of members */
            tms_PowerMeasurementLine_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerMeasurementLine*/

    if (is_initialized) {
        return &tms_PowerMeasurementLine_g_tc;
    }

    tms_PowerMeasurementLine_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerMeasurementLine_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementLine_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementLine_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementLine_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementLine_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementLine_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementLine_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementLine_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */
    tms_PowerMeasurementLine_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[0]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[0]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[0]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[5]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[5]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[5]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[5]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[5]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[6]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[6]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[6]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[6]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[6]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[7]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementLine_g_tc_members[7]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[7]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementLine_g_tc_members[7]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementLine_g_tc_members[7]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementLine_g_tc._data._sampleAccessInfo =
    tms_PowerMeasurementLine_get_sample_access_info();
    tms_PowerMeasurementLine_g_tc._data._typePlugin =
    tms_PowerMeasurementLine_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerMeasurementLine_g_tc;
}

#define TSeq tms_PowerMeasurementLineSeq
#define T tms_PowerMeasurementLine
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerMeasurementLine_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerMeasurementLine_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerMeasurementLineSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerMeasurementLineSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerMeasurementLine_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerMeasurementLine_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerMeasurementLine *sample;

    static RTIXCdrMemberAccessInfo tms_PowerMeasurementLine_g_memberAccessInfos[8] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerMeasurementLine_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerMeasurementLine_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerMeasurementLine);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerMeasurementLine_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->v - (char *)sample);

    tms_PowerMeasurementLine_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->i - (char *)sample);

    tms_PowerMeasurementLine_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->phi - (char *)sample);

    tms_PowerMeasurementLine_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->p - (char *)sample);

    tms_PowerMeasurementLine_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->q - (char *)sample);

    tms_PowerMeasurementLine_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->f - (char *)sample);

    tms_PowerMeasurementLine_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->vThd - (char *)sample);

    tms_PowerMeasurementLine_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->iThd - (char *)sample);

    tms_PowerMeasurementLine_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerMeasurementLine_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerMeasurementLine);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerMeasurementLine_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerMeasurementLine_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerMeasurementLine_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerMeasurementLine_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerMeasurementLine_get_member_value_pointer;

    tms_PowerMeasurementLine_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerMeasurementLine_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerMeasurementLine_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerMeasurementLine_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerMeasurementLine_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerMeasurementLine_finalize_w_return,
        NULL
    };

    return &tms_PowerMeasurementLine_g_typePlugin;
}
#endif

RTIBool tms_PowerMeasurementLine_initialize(
    tms_PowerMeasurementLine* sample) {
    return tms_PowerMeasurementLine_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerMeasurementLine_initialize_ex(
    tms_PowerMeasurementLine* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerMeasurementLine_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerMeasurementLine_initialize_w_params(
    tms_PowerMeasurementLine* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->v = 0.0f;

    sample->i = 0.0f;

    sample->phi = 0.0f;

    sample->p = 0.0f;

    sample->q = 0.0f;

    sample->f = 0.0f;

    sample->vThd = 0.0f;

    sample->iThd = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_PowerMeasurementLine_finalize_w_return(
    tms_PowerMeasurementLine* sample)
{
    tms_PowerMeasurementLine_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerMeasurementLine_finalize(
    tms_PowerMeasurementLine* sample)
{

    tms_PowerMeasurementLine_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerMeasurementLine_finalize_ex(
    tms_PowerMeasurementLine* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerMeasurementLine_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerMeasurementLine_finalize_w_params(
    tms_PowerMeasurementLine* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerMeasurementLine_finalize_optional_members(
    tms_PowerMeasurementLine* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerMeasurementLine_copy(
    tms_PowerMeasurementLine* dst,
    const tms_PowerMeasurementLine* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyFloat (
            &dst->v, &src->v)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->i, &src->i)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->phi, &src->phi)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->p, &src->p)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->q, &src->q)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->f, &src->f)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->vThd, &src->vThd)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->iThd, &src->iThd)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerMeasurementLine' sequence class.
*/
#define T tms_PowerMeasurementLine
#define TSeq tms_PowerMeasurementLineSeq

#define T_initialize_w_params tms_PowerMeasurementLine_initialize_w_params

#define T_finalize_w_params   tms_PowerMeasurementLine_finalize_w_params
#define T_copy       tms_PowerMeasurementLine_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerMeasurementWyeTYPENAME = "tms::PowerMeasurementWye";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerMeasurementWye_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerMeasurementWye_g_tc_members[6]=
    {

        {
            (char *)"A",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"B",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"C",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"N",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"phaseAtoB",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"phaseAtoC",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerMeasurementWye_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerMeasurementWye", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_PowerMeasurementWye_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerMeasurementWye*/

    if (is_initialized) {
        return &tms_PowerMeasurementWye_g_tc;
    }

    tms_PowerMeasurementWye_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerMeasurementWye_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerMeasurementLine_get_typecode();
    tms_PowerMeasurementWye_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PowerMeasurementLine_get_typecode();
    tms_PowerMeasurementWye_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_PowerMeasurementLine_get_typecode();
    tms_PowerMeasurementWye_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_PowerMeasurementLine_get_typecode();
    tms_PowerMeasurementWye_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_PowerMeasurementWye_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_PowerMeasurementWye_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementWye_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementWye_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementWye_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementWye_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementWye_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementWye_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementWye_g_tc_members[5]._annotations._defaultValue._u.float_value = 0.0f;
    tms_PowerMeasurementWye_g_tc_members[5]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementWye_g_tc_members[5]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_PowerMeasurementWye_g_tc_members[5]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_PowerMeasurementWye_g_tc_members[5]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_PowerMeasurementWye_g_tc._data._sampleAccessInfo =
    tms_PowerMeasurementWye_get_sample_access_info();
    tms_PowerMeasurementWye_g_tc._data._typePlugin =
    tms_PowerMeasurementWye_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerMeasurementWye_g_tc;
}

#define TSeq tms_PowerMeasurementWyeSeq
#define T tms_PowerMeasurementWye
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerMeasurementWye_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerMeasurementWye_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerMeasurementWyeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerMeasurementWyeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerMeasurementWye_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerMeasurementWye_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerMeasurementWye *sample;

    static RTIXCdrMemberAccessInfo tms_PowerMeasurementWye_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerMeasurementWye_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerMeasurementWye_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerMeasurementWye);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerMeasurementWye_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->A - (char *)sample);

    tms_PowerMeasurementWye_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->B - (char *)sample);

    tms_PowerMeasurementWye_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->C - (char *)sample);

    tms_PowerMeasurementWye_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->N - (char *)sample);

    tms_PowerMeasurementWye_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->phaseAtoB - (char *)sample);

    tms_PowerMeasurementWye_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->phaseAtoC - (char *)sample);

    tms_PowerMeasurementWye_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerMeasurementWye_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerMeasurementWye);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerMeasurementWye_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerMeasurementWye_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerMeasurementWye_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerMeasurementWye_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerMeasurementWye_get_member_value_pointer;

    tms_PowerMeasurementWye_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerMeasurementWye_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerMeasurementWye_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerMeasurementWye_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerMeasurementWye_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerMeasurementWye_finalize_w_return,
        NULL
    };

    return &tms_PowerMeasurementWye_g_typePlugin;
}
#endif

RTIBool tms_PowerMeasurementWye_initialize(
    tms_PowerMeasurementWye* sample) {
    return tms_PowerMeasurementWye_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerMeasurementWye_initialize_ex(
    tms_PowerMeasurementWye* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerMeasurementWye_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerMeasurementWye_initialize_w_params(
    tms_PowerMeasurementWye* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_PowerMeasurementLine_initialize_w_params(&sample->A,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_PowerMeasurementLine_initialize_w_params(&sample->B,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_PowerMeasurementLine_initialize_w_params(&sample->C,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_PowerMeasurementLine_initialize_w_params(&sample->N,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->phaseAtoB = 0.0f;

    sample->phaseAtoC = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_PowerMeasurementWye_finalize_w_return(
    tms_PowerMeasurementWye* sample)
{
    tms_PowerMeasurementWye_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerMeasurementWye_finalize(
    tms_PowerMeasurementWye* sample)
{

    tms_PowerMeasurementWye_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerMeasurementWye_finalize_ex(
    tms_PowerMeasurementWye* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerMeasurementWye_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerMeasurementWye_finalize_w_params(
    tms_PowerMeasurementWye* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_PowerMeasurementLine_finalize_w_params(&sample->A,deallocParams);

    tms_PowerMeasurementLine_finalize_w_params(&sample->B,deallocParams);

    tms_PowerMeasurementLine_finalize_w_params(&sample->C,deallocParams);

    tms_PowerMeasurementLine_finalize_w_params(&sample->N,deallocParams);

}

void tms_PowerMeasurementWye_finalize_optional_members(
    tms_PowerMeasurementWye* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerMeasurementWye_copy(
    tms_PowerMeasurementWye* dst,
    const tms_PowerMeasurementWye* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_PowerMeasurementLine_copy(
            &dst->A,(const tms_PowerMeasurementLine*)&src->A)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerMeasurementLine_copy(
            &dst->B,(const tms_PowerMeasurementLine*)&src->B)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerMeasurementLine_copy(
            &dst->C,(const tms_PowerMeasurementLine*)&src->C)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerMeasurementLine_copy(
            &dst->N,(const tms_PowerMeasurementLine*)&src->N)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->phaseAtoB, &src->phaseAtoB)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->phaseAtoC, &src->phaseAtoC)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerMeasurementWye' sequence class.
*/
#define T tms_PowerMeasurementWye
#define TSeq tms_PowerMeasurementWyeSeq

#define T_initialize_w_params tms_PowerMeasurementWye_initialize_w_params

#define T_finalize_w_params   tms_PowerMeasurementWye_finalize_w_params
#define T_copy       tms_PowerMeasurementWye_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerPortMeasurementTYPENAME = "tms::PowerPortMeasurement";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortMeasurement_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerPortMeasurement_g_tc_members[2]=
    {

        {
            (char *)"portNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"measurement",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerPortMeasurement_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerPortMeasurement", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_PowerPortMeasurement_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerPortMeasurement*/

    if (is_initialized) {
        return &tms_PowerPortMeasurement_g_tc;
    }

    tms_PowerPortMeasurement_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortMeasurement_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_PowerPortMeasurement_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PowerMeasurementWye_get_typecode();

    /* Initialize the values for member annotations. */
    tms_PowerPortMeasurement_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortMeasurement_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortMeasurement_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortMeasurement_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortMeasurement_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortMeasurement_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortMeasurement_g_tc._data._sampleAccessInfo =
    tms_PowerPortMeasurement_get_sample_access_info();
    tms_PowerPortMeasurement_g_tc._data._typePlugin =
    tms_PowerPortMeasurement_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortMeasurement_g_tc;
}

#define TSeq tms_PowerPortMeasurementSeq
#define T tms_PowerPortMeasurement
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortMeasurement_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortMeasurement_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortMeasurementSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortMeasurementSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortMeasurement_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortMeasurement_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerPortMeasurement *sample;

    static RTIXCdrMemberAccessInfo tms_PowerPortMeasurement_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortMeasurement_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortMeasurement_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerPortMeasurement);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerPortMeasurement_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerPortMeasurement_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->measurement - (char *)sample);

    tms_PowerPortMeasurement_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortMeasurement_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortMeasurement);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortMeasurement_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortMeasurement_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortMeasurement_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortMeasurement_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortMeasurement_get_member_value_pointer;

    tms_PowerPortMeasurement_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortMeasurement_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortMeasurement_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortMeasurement_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortMeasurement_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortMeasurement_finalize_w_return,
        NULL
    };

    return &tms_PowerPortMeasurement_g_typePlugin;
}
#endif

RTIBool tms_PowerPortMeasurement_initialize(
    tms_PowerPortMeasurement* sample) {
    return tms_PowerPortMeasurement_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortMeasurement_initialize_ex(
    tms_PowerPortMeasurement* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortMeasurement_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortMeasurement_initialize_w_params(
    tms_PowerPortMeasurement* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    if (!tms_PowerMeasurementWye_initialize_w_params(&sample->measurement,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_PowerPortMeasurement_finalize_w_return(
    tms_PowerPortMeasurement* sample)
{
    tms_PowerPortMeasurement_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortMeasurement_finalize(
    tms_PowerPortMeasurement* sample)
{

    tms_PowerPortMeasurement_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortMeasurement_finalize_ex(
    tms_PowerPortMeasurement* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortMeasurement_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortMeasurement_finalize_w_params(
    tms_PowerPortMeasurement* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_PowerMeasurementWye_finalize_w_params(&sample->measurement,deallocParams);

}

void tms_PowerPortMeasurement_finalize_optional_members(
    tms_PowerPortMeasurement* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortMeasurement_copy(
    tms_PowerPortMeasurement* dst,
    const tms_PowerPortMeasurement* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_PowerMeasurementWye_copy(
            &dst->measurement,(const tms_PowerMeasurementWye*)&src->measurement)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortMeasurement' sequence class.
*/
#define T tms_PowerPortMeasurement
#define TSeq tms_PowerPortMeasurementSeq

#define T_initialize_w_params tms_PowerPortMeasurement_initialize_w_params

#define T_finalize_w_params   tms_PowerPortMeasurement_finalize_w_params
#define T_copy       tms_PowerPortMeasurement_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DevicePowerMeasurementsTYPENAME = "tms::DevicePowerMeasurements";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DevicePowerMeasurements_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DevicePowerMeasurements_g_tc_ports_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_ports)),NULL);

    static DDS_TypeCode_Member tms_DevicePowerMeasurements_g_tc_members[3]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"timeMeasured",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ports",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DevicePowerMeasurements_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DevicePowerMeasurements", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_DevicePowerMeasurements_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DevicePowerMeasurements*/

    if (is_initialized) {
        return &tms_DevicePowerMeasurements_g_tc;
    }

    tms_DevicePowerMeasurements_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DevicePowerMeasurements_g_tc_ports_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortMeasurement_get_typecode();
    tms_DevicePowerMeasurements_g_tc_ports_sequence._data._sampleAccessInfo = tms_PowerPortMeasurement_get_sample_seq_access_info();
    tms_DevicePowerMeasurements_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DevicePowerMeasurements_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_DevicePowerMeasurements_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)& tms_DevicePowerMeasurements_g_tc_ports_sequence;

    /* Initialize the values for member annotations. */

    tms_DevicePowerMeasurements_g_tc._data._sampleAccessInfo =
    tms_DevicePowerMeasurements_get_sample_access_info();
    tms_DevicePowerMeasurements_g_tc._data._typePlugin =
    tms_DevicePowerMeasurements_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DevicePowerMeasurements_g_tc;
}

#define TSeq tms_DevicePowerMeasurementsSeq
#define T tms_DevicePowerMeasurements
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DevicePowerMeasurements_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DevicePowerMeasurements_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DevicePowerMeasurementsSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DevicePowerMeasurementsSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DevicePowerMeasurements_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DevicePowerMeasurements_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DevicePowerMeasurements *sample;

    static RTIXCdrMemberAccessInfo tms_DevicePowerMeasurements_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DevicePowerMeasurements_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DevicePowerMeasurements_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DevicePowerMeasurements);
    if (sample == NULL) {
        return NULL;
    }

    tms_DevicePowerMeasurements_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DevicePowerMeasurements_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->timeMeasured - (char *)sample);

    tms_DevicePowerMeasurements_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->ports - (char *)sample);

    tms_DevicePowerMeasurements_g_sampleAccessInfo.memberAccessInfos = 
    tms_DevicePowerMeasurements_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DevicePowerMeasurements);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DevicePowerMeasurements_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DevicePowerMeasurements_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DevicePowerMeasurements_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DevicePowerMeasurements_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DevicePowerMeasurements_get_member_value_pointer;

    tms_DevicePowerMeasurements_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DevicePowerMeasurements_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DevicePowerMeasurements_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DevicePowerMeasurements_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DevicePowerMeasurements_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DevicePowerMeasurements_finalize_w_return,
        NULL
    };

    return &tms_DevicePowerMeasurements_g_typePlugin;
}
#endif

RTIBool tms_DevicePowerMeasurements_initialize(
    tms_DevicePowerMeasurements* sample) {
    return tms_DevicePowerMeasurements_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DevicePowerMeasurements_initialize_ex(
    tms_DevicePowerMeasurements* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DevicePowerMeasurements_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DevicePowerMeasurements_initialize_w_params(
    tms_DevicePowerMeasurements* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockMonotonic_initialize_w_params(&sample->timeMeasured,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerPortMeasurementSeq_initialize(&sample->ports )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortMeasurementSeq_set_element_allocation_params(&sample->ports ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortMeasurementSeq_set_absolute_maximum(&sample->ports , ((tms_MAXLEN_ports)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortMeasurementSeq_set_maximum(&sample->ports, ((tms_MAXLEN_ports)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortMeasurementSeq_set_length(&sample->ports, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DevicePowerMeasurements_finalize_w_return(
    tms_DevicePowerMeasurements* sample)
{
    tms_DevicePowerMeasurements_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DevicePowerMeasurements_finalize(
    tms_DevicePowerMeasurements* sample)
{

    tms_DevicePowerMeasurements_finalize_ex(sample,RTI_TRUE);
}

void tms_DevicePowerMeasurements_finalize_ex(
    tms_DevicePowerMeasurements* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DevicePowerMeasurements_finalize_w_params(
        sample,&deallocParams);
}

void tms_DevicePowerMeasurements_finalize_w_params(
    tms_DevicePowerMeasurements* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->timeMeasured,deallocParams);

    if(!tms_PowerPortMeasurementSeq_set_element_deallocation_params(
        &sample->ports,deallocParams)){
        return; 
    }
    if(!tms_PowerPortMeasurementSeq_finalize(&sample->ports)){
        return;
    }

}

void tms_DevicePowerMeasurements_finalize_optional_members(
    tms_DevicePowerMeasurements* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DevicePowerMeasurements_copy(
    tms_DevicePowerMeasurements* dst,
    const tms_DevicePowerMeasurements* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->timeMeasured,(const tms_ClockMonotonic*)&src->timeMeasured)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerPortMeasurementSeq_copy(&dst->ports ,
        &src->ports )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DevicePowerMeasurements' sequence class.
*/
#define T tms_DevicePowerMeasurements
#define TSeq tms_DevicePowerMeasurementsSeq

#define T_initialize_w_params tms_DevicePowerMeasurements_initialize_w_params

#define T_finalize_w_params   tms_DevicePowerMeasurements_finalize_w_params
#define T_copy       tms_DevicePowerMeasurements_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_NicknameString_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_NicknameString_g_tc_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_NicknameString)));

    static DDS_TypeCode tms_NicknameString_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::NicknameString", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_NicknameString */

    if (is_initialized) {
        return &tms_NicknameString_g_tc;
    }

    tms_NicknameString_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_NicknameString_g_tc._data._typeCode =  (RTICdrTypeCode *)&tms_NicknameString_g_tc_string;

    /* Initialize the values for member annotations. */
    tms_NicknameString_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_NicknameString_g_tc._data._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_NicknameString_g_tc._data._sampleAccessInfo =
    tms_NicknameString_get_sample_access_info();
    tms_NicknameString_g_tc._data._typePlugin =
    tms_NicknameString_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_NicknameString_g_tc;
}

#define TSeq tms_NicknameStringSeq
#define T tms_NicknameString
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_NicknameString_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_NicknameString_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_NicknameStringSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_NicknameStringSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_NicknameString_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_NicknameString_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_NicknameString_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_NicknameString_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_NicknameString_g_sampleAccessInfo;
    }

    tms_NicknameString_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_NicknameString_g_sampleAccessInfo.memberAccessInfos = 
    tms_NicknameString_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_NicknameString);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_NicknameString_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_NicknameString_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_NicknameString_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_NicknameString_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_NicknameString_get_member_value_pointer;

    tms_NicknameString_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_NicknameString_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_NicknameString_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_NicknameString_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_NicknameString_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_NicknameString_finalize_w_return,
        NULL
    };

    return &tms_NicknameString_g_typePlugin;
}
#endif

RTIBool tms_NicknameString_initialize(
    tms_NicknameString* sample) {
    return tms_NicknameString_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_NicknameString_initialize_ex(
    tms_NicknameString* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_NicknameString_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_NicknameString_initialize_w_params(
    tms_NicknameString* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        (*sample) = DDS_String_alloc(((tms_MAXLEN_NicknameString)));
        RTICdrType_copyStringEx(
            &(*sample),
            "",
            ((tms_MAXLEN_NicknameString)),
            RTI_FALSE);
        if ((*sample) == NULL) {
            return RTI_FALSE;
        }
    } else {
        if ((*sample) != NULL) {
            RTICdrType_copyStringEx(
                &(*sample),
                "",
                ((tms_MAXLEN_NicknameString)),
                RTI_FALSE);
            if ((*sample) == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_NicknameString_finalize_w_return(
    tms_NicknameString* sample)
{
    tms_NicknameString_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_NicknameString_finalize(
    tms_NicknameString* sample)
{

    tms_NicknameString_finalize_ex(sample,RTI_TRUE);
}

void tms_NicknameString_finalize_ex(
    tms_NicknameString* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_NicknameString_finalize_w_params(
        sample,&deallocParams);
}

void tms_NicknameString_finalize_w_params(
    tms_NicknameString* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if ((*sample) != NULL) {
        DDS_String_free((*sample));
        (*sample)=NULL;

    }
}

void tms_NicknameString_finalize_optional_members(
    tms_NicknameString* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_NicknameString_copy(
    tms_NicknameString* dst,
    const tms_NicknameString* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyStringEx (
            &(*dst), (*src), 
            ((tms_MAXLEN_NicknameString)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_NicknameString' sequence class.
*/
#define T tms_NicknameString
#define TSeq tms_NicknameStringSeq

#define T_initialize_w_params tms_NicknameString_initialize_w_params

#define T_finalize_w_params   tms_NicknameString_finalize_w_params
#define T_copy       tms_NicknameString_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_FingerprintNicknameTYPENAME = "tms::FingerprintNickname";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_FingerprintNickname_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_FingerprintNickname_g_tc_members[2]=
    {

        {
            (char *)"id",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nickname",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_FingerprintNickname_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::FingerprintNickname", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_FingerprintNickname_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_FingerprintNickname*/

    if (is_initialized) {
        return &tms_FingerprintNickname_g_tc;
    }

    tms_FingerprintNickname_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_FingerprintNickname_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_FingerprintNickname_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_NicknameString_get_typecode();

    /* Initialize the values for member annotations. */

    tms_FingerprintNickname_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_FingerprintNickname_g_tc_members[1]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_FingerprintNickname_g_tc._data._sampleAccessInfo =
    tms_FingerprintNickname_get_sample_access_info();
    tms_FingerprintNickname_g_tc._data._typePlugin =
    tms_FingerprintNickname_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_FingerprintNickname_g_tc;
}

#define TSeq tms_FingerprintNicknameSeq
#define T tms_FingerprintNickname
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_FingerprintNickname_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_FingerprintNickname_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_FingerprintNicknameSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_FingerprintNicknameSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_FingerprintNickname_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_FingerprintNickname_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_FingerprintNickname *sample;

    static RTIXCdrMemberAccessInfo tms_FingerprintNickname_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_FingerprintNickname_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_FingerprintNickname_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_FingerprintNickname);
    if (sample == NULL) {
        return NULL;
    }

    tms_FingerprintNickname_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->id - (char *)sample);

    tms_FingerprintNickname_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nickname - (char *)sample);

    tms_FingerprintNickname_g_sampleAccessInfo.memberAccessInfos = 
    tms_FingerprintNickname_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_FingerprintNickname);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_FingerprintNickname_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_FingerprintNickname_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_FingerprintNickname_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_FingerprintNickname_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_FingerprintNickname_get_member_value_pointer;

    tms_FingerprintNickname_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_FingerprintNickname_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_FingerprintNickname_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_FingerprintNickname_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_FingerprintNickname_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_FingerprintNickname_finalize_w_return,
        NULL
    };

    return &tms_FingerprintNickname_g_typePlugin;
}
#endif

RTIBool tms_FingerprintNickname_initialize(
    tms_FingerprintNickname* sample) {
    return tms_FingerprintNickname_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_FingerprintNickname_initialize_ex(
    tms_FingerprintNickname* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_FingerprintNickname_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_FingerprintNickname_initialize_w_params(
    tms_FingerprintNickname* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->id,
    allocParams)) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        sample->nickname = DDS_String_alloc(((tms_MAXLEN_NicknameString)));
        RTICdrType_copyStringEx(
            &sample->nickname,
            "",
            ((tms_MAXLEN_NicknameString)),
            RTI_FALSE);
        if (sample->nickname == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->nickname != NULL) {
            RTICdrType_copyStringEx(
                &sample->nickname,
                "",
                ((tms_MAXLEN_NicknameString)),
                RTI_FALSE);
            if (sample->nickname == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_FingerprintNickname_finalize_w_return(
    tms_FingerprintNickname* sample)
{
    tms_FingerprintNickname_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_FingerprintNickname_finalize(
    tms_FingerprintNickname* sample)
{

    tms_FingerprintNickname_finalize_ex(sample,RTI_TRUE);
}

void tms_FingerprintNickname_finalize_ex(
    tms_FingerprintNickname* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_FingerprintNickname_finalize_w_params(
        sample,&deallocParams);
}

void tms_FingerprintNickname_finalize_w_params(
    tms_FingerprintNickname* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->id,deallocParams);

    if (sample->nickname != NULL) {
        DDS_String_free(sample->nickname);
        sample->nickname=NULL;

    }
}

void tms_FingerprintNickname_finalize_optional_members(
    tms_FingerprintNickname* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_FingerprintNickname_copy(
    tms_FingerprintNickname* dst,
    const tms_FingerprintNickname* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->id,(const tms_Fingerprint*)&src->id)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyStringEx (
            &dst->nickname, src->nickname, 
            ((tms_MAXLEN_NicknameString)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_FingerprintNickname' sequence class.
*/
#define T tms_FingerprintNickname
#define TSeq tms_FingerprintNicknameSeq

#define T_initialize_w_params tms_FingerprintNickname_initialize_w_params

#define T_finalize_w_params   tms_FingerprintNickname_finalize_w_params
#define T_copy       tms_FingerprintNickname_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ChangeNicknameRequestTYPENAME = "tms::ChangeNicknameRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ChangeNicknameRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ChangeNicknameRequest_g_tc_members[3]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"id",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nickname",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ChangeNicknameRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ChangeNicknameRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_ChangeNicknameRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ChangeNicknameRequest*/

    if (is_initialized) {
        return &tms_ChangeNicknameRequest_g_tc;
    }

    tms_ChangeNicknameRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ChangeNicknameRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_ChangeNicknameRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_ChangeNicknameRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_NicknameString_get_typecode();

    /* Initialize the values for member annotations. */

    tms_ChangeNicknameRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_ChangeNicknameRequest_g_tc_members[2]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_ChangeNicknameRequest_g_tc._data._sampleAccessInfo =
    tms_ChangeNicknameRequest_get_sample_access_info();
    tms_ChangeNicknameRequest_g_tc._data._typePlugin =
    tms_ChangeNicknameRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ChangeNicknameRequest_g_tc;
}

#define TSeq tms_ChangeNicknameRequestSeq
#define T tms_ChangeNicknameRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ChangeNicknameRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ChangeNicknameRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ChangeNicknameRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ChangeNicknameRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ChangeNicknameRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ChangeNicknameRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ChangeNicknameRequest *sample;

    static RTIXCdrMemberAccessInfo tms_ChangeNicknameRequest_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ChangeNicknameRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ChangeNicknameRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ChangeNicknameRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_ChangeNicknameRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_ChangeNicknameRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->id - (char *)sample);

    tms_ChangeNicknameRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nickname - (char *)sample);

    tms_ChangeNicknameRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_ChangeNicknameRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ChangeNicknameRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ChangeNicknameRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ChangeNicknameRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ChangeNicknameRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ChangeNicknameRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ChangeNicknameRequest_get_member_value_pointer;

    tms_ChangeNicknameRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ChangeNicknameRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ChangeNicknameRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ChangeNicknameRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ChangeNicknameRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ChangeNicknameRequest_finalize_w_return,
        NULL
    };

    return &tms_ChangeNicknameRequest_g_typePlugin;
}
#endif

RTIBool tms_ChangeNicknameRequest_initialize(
    tms_ChangeNicknameRequest* sample) {
    return tms_ChangeNicknameRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ChangeNicknameRequest_initialize_ex(
    tms_ChangeNicknameRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ChangeNicknameRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ChangeNicknameRequest_initialize_w_params(
    tms_ChangeNicknameRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->id,
    allocParams)) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        sample->nickname = DDS_String_alloc(((tms_MAXLEN_NicknameString)));
        RTICdrType_copyStringEx(
            &sample->nickname,
            "",
            ((tms_MAXLEN_NicknameString)),
            RTI_FALSE);
        if (sample->nickname == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->nickname != NULL) {
            RTICdrType_copyStringEx(
                &sample->nickname,
                "",
                ((tms_MAXLEN_NicknameString)),
                RTI_FALSE);
            if (sample->nickname == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_ChangeNicknameRequest_finalize_w_return(
    tms_ChangeNicknameRequest* sample)
{
    tms_ChangeNicknameRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ChangeNicknameRequest_finalize(
    tms_ChangeNicknameRequest* sample)
{

    tms_ChangeNicknameRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_ChangeNicknameRequest_finalize_ex(
    tms_ChangeNicknameRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ChangeNicknameRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_ChangeNicknameRequest_finalize_w_params(
    tms_ChangeNicknameRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->id,deallocParams);

    if (sample->nickname != NULL) {
        DDS_String_free(sample->nickname);
        sample->nickname=NULL;

    }
}

void tms_ChangeNicknameRequest_finalize_optional_members(
    tms_ChangeNicknameRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ChangeNicknameRequest_copy(
    tms_ChangeNicknameRequest* dst,
    const tms_ChangeNicknameRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->id,(const tms_Fingerprint*)&src->id)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyStringEx (
            &dst->nickname, src->nickname, 
            ((tms_MAXLEN_NicknameString)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ChangeNicknameRequest' sequence class.
*/
#define T tms_ChangeNicknameRequest
#define TSeq tms_ChangeNicknameRequestSeq

#define T_initialize_w_params tms_ChangeNicknameRequest_initialize_w_params

#define T_finalize_w_params   tms_ChangeNicknameRequest_finalize_w_params
#define T_copy       tms_ChangeNicknameRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceIconTYPENAME = "tms::DeviceIcon";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceIcon_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DeviceIcon_g_tc_mimeType_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_mimeType)));
    static DDS_TypeCode tms_DeviceIcon_g_tc_data_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_data)),NULL);

    static DDS_TypeCode_Member tms_DeviceIcon_g_tc_members[4]=
    {

        {
            (char *)"nsn",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"gtin",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"mimeType",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"data",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceIcon_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceIcon", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_DeviceIcon_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceIcon*/

    if (is_initialized) {
        return &tms_DeviceIcon_g_tc;
    }

    tms_DeviceIcon_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DeviceIcon_g_tc_data_sequence._data._typeCode = (RTICdrTypeCode *)&DDS_g_tc_octet_w_new;
    tms_DeviceIcon_g_tc_data_sequence._data._sampleAccessInfo = &DDS_g_sai_octet_seq;
    tms_DeviceIcon_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_NatoStockNumber_get_typecode();
    tms_DeviceIcon_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_GlobalTradeItemNumber_get_typecode();
    tms_DeviceIcon_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&tms_DeviceIcon_g_tc_mimeType_string;
    tms_DeviceIcon_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_DeviceIcon_g_tc_data_sequence;

    /* Initialize the values for member annotations. */

    tms_DeviceIcon_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_DeviceIcon_g_tc_members[2]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_DeviceIcon_g_tc._data._sampleAccessInfo =
    tms_DeviceIcon_get_sample_access_info();
    tms_DeviceIcon_g_tc._data._typePlugin =
    tms_DeviceIcon_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceIcon_g_tc;
}

#define TSeq tms_DeviceIconSeq
#define T tms_DeviceIcon
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceIcon_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceIcon_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceIconSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceIconSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceIcon_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceIcon_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DeviceIcon *sample;

    static RTIXCdrMemberAccessInfo tms_DeviceIcon_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceIcon_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceIcon_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DeviceIcon);
    if (sample == NULL) {
        return NULL;
    }

    tms_DeviceIcon_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nsn - (char *)sample);

    tms_DeviceIcon_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->gtin - (char *)sample);

    tms_DeviceIcon_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->mimeType - (char *)sample);

    tms_DeviceIcon_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->data - (char *)sample);

    tms_DeviceIcon_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceIcon_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceIcon);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceIcon_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceIcon_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceIcon_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceIcon_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceIcon_get_member_value_pointer;

    tms_DeviceIcon_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceIcon_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceIcon_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceIcon_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceIcon_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceIcon_finalize_w_return,
        NULL
    };

    return &tms_DeviceIcon_g_typePlugin;
}
#endif

RTIBool tms_DeviceIcon_initialize(
    tms_DeviceIcon* sample) {
    return tms_DeviceIcon_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DeviceIcon_initialize_ex(
    tms_DeviceIcon* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceIcon_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceIcon_initialize_w_params(
    tms_DeviceIcon* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_NatoStockNumber_initialize_w_params(&sample->nsn,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_GlobalTradeItemNumber_initialize_w_params(&sample->gtin,
    allocParams)) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        sample->mimeType = DDS_String_alloc(((tms_MAXLEN_mimeType)));
        RTICdrType_copyStringEx(
            &sample->mimeType,
            "",
            ((tms_MAXLEN_mimeType)),
            RTI_FALSE);
        if (sample->mimeType == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->mimeType != NULL) {
            RTICdrType_copyStringEx(
                &sample->mimeType,
                "",
                ((tms_MAXLEN_mimeType)),
                RTI_FALSE);
            if (sample->mimeType == NULL) {
                return RTI_FALSE;
            }
        }
    }

    if (allocParams->allocate_memory) {
        if(!DDS_OctetSeq_initialize(&sample->data  )){
            return RTI_FALSE;
        }
        if(!DDS_OctetSeq_set_absolute_maximum(&sample->data , ((tms_MAXLEN_data)))){
            return RTI_FALSE;
        }
        if (!DDS_OctetSeq_set_maximum(&sample->data , ((tms_MAXLEN_data)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!DDS_OctetSeq_set_length(&sample->data, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DeviceIcon_finalize_w_return(
    tms_DeviceIcon* sample)
{
    tms_DeviceIcon_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DeviceIcon_finalize(
    tms_DeviceIcon* sample)
{

    tms_DeviceIcon_finalize_ex(sample,RTI_TRUE);
}

void tms_DeviceIcon_finalize_ex(
    tms_DeviceIcon* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceIcon_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceIcon_finalize_w_params(
    tms_DeviceIcon* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_NatoStockNumber_finalize_w_params(&sample->nsn,deallocParams);

    tms_GlobalTradeItemNumber_finalize_w_params(&sample->gtin,deallocParams);

    if (sample->mimeType != NULL) {
        DDS_String_free(sample->mimeType);
        sample->mimeType=NULL;

    }
    if(!DDS_OctetSeq_finalize(&sample->data)){
        return;
    }

}

void tms_DeviceIcon_finalize_optional_members(
    tms_DeviceIcon* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceIcon_copy(
    tms_DeviceIcon* dst,
    const tms_DeviceIcon* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_NatoStockNumber_copy(
            &dst->nsn,(const tms_NatoStockNumber*)&src->nsn)) {
            return RTI_FALSE;
        } 
        if (!tms_GlobalTradeItemNumber_copy(
            &dst->gtin,(const tms_GlobalTradeItemNumber*)&src->gtin)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyStringEx (
            &dst->mimeType, src->mimeType, 
            ((tms_MAXLEN_mimeType)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }
        if (!DDS_OctetSeq_copy(&dst->data ,
        &src->data )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceIcon' sequence class.
*/
#define T tms_DeviceIcon
#define TSeq tms_DeviceIconSeq

#define T_initialize_w_params tms_DeviceIcon_initialize_w_params

#define T_finalize_w_params   tms_DeviceIcon_finalize_w_params
#define T_copy       tms_DeviceIcon_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_OperatingModeTYPENAME = "tms::OperatingMode";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_OperatingMode_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_OperatingMode_g_tc_members[2]=
    {

        {
            (char *)"OPM_NORMAL",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            OPM_NORMAL, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"OPM_EMERGENCY",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            OPM_EMERGENCY, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_OperatingMode_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::OperatingMode", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_OperatingMode_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_OperatingMode*/

    if (is_initialized) {
        return &tms_OperatingMode_g_tc;
    }

    tms_OperatingMode_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_OperatingMode_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_OperatingMode_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_OperatingMode_g_tc._data._sampleAccessInfo =
    tms_OperatingMode_get_sample_access_info();
    tms_OperatingMode_g_tc._data._typePlugin =
    tms_OperatingMode_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_OperatingMode_g_tc;
}

#define TSeq tms_OperatingModeSeq
#define T tms_OperatingMode
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_OperatingMode_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_OperatingMode_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_OperatingModeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_OperatingModeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_OperatingMode_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_OperatingMode_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_OperatingMode_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_OperatingMode_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_OperatingMode_g_sampleAccessInfo;
    }

    tms_OperatingMode_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_OperatingMode_g_sampleAccessInfo.memberAccessInfos = 
    tms_OperatingMode_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_OperatingMode);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_OperatingMode_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_OperatingMode_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_OperatingMode_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_OperatingMode_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_OperatingMode_get_member_value_pointer;

    tms_OperatingMode_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_OperatingMode_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_OperatingMode_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_OperatingMode_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_OperatingMode_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_OperatingMode_finalize_w_return,
        NULL
    };

    return &tms_OperatingMode_g_typePlugin;
}
#endif

RTIBool tms_OperatingMode_initialize(
    tms_OperatingMode* sample) {
    *sample = OPM_NORMAL;
    return RTI_TRUE;
}

RTIBool tms_OperatingMode_initialize_ex(
    tms_OperatingMode* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_OperatingMode_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_OperatingMode_initialize_w_params(
    tms_OperatingMode* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = OPM_NORMAL;
    return RTI_TRUE;
}

RTIBool tms_OperatingMode_finalize_w_return(
    tms_OperatingMode* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_OperatingMode_finalize(
    tms_OperatingMode* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_OperatingMode_finalize_ex(
    tms_OperatingMode* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_OperatingMode_finalize_w_params(
        sample,&deallocParams);
}

void tms_OperatingMode_finalize_w_params(
    tms_OperatingMode* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_OperatingMode_finalize_optional_members(
    tms_OperatingMode* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_OperatingMode_copy(
    tms_OperatingMode* dst,
    const tms_OperatingMode* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_OperatingMode' sequence class.
*/
#define T tms_OperatingMode
#define TSeq tms_OperatingModeSeq

#define T_initialize_w_params tms_OperatingMode_initialize_w_params

#define T_finalize_w_params   tms_OperatingMode_finalize_w_params
#define T_copy       tms_OperatingMode_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PriorityValue_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_PriorityValue_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::PriorityValue", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_PriorityValue */

    if (is_initialized) {
        return &tms_PriorityValue_g_tc;
    }

    tms_PriorityValue_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PriorityValue_g_tc._data._typeCode =  (RTICdrTypeCode *)&DDS_g_tc_long_w_new;

    /* Initialize the values for member annotations. */
    tms_PriorityValue_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_PriorityValue_g_tc._data._annotations._defaultValue._u.long_value = 0;
    tms_PriorityValue_g_tc._data._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_PriorityValue_g_tc._data._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_PriorityValue_g_tc._data._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_PriorityValue_g_tc._data._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_PriorityValue_g_tc._data._sampleAccessInfo =
    tms_PriorityValue_get_sample_access_info();
    tms_PriorityValue_g_tc._data._typePlugin =
    tms_PriorityValue_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PriorityValue_g_tc;
}

#define TSeq tms_PriorityValueSeq
#define T tms_PriorityValue
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PriorityValue_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PriorityValue_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PriorityValueSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PriorityValueSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PriorityValue_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PriorityValue_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PriorityValue_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PriorityValue_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PriorityValue_g_sampleAccessInfo;
    }

    tms_PriorityValue_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PriorityValue_g_sampleAccessInfo.memberAccessInfos = 
    tms_PriorityValue_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PriorityValue);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PriorityValue_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PriorityValue_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PriorityValue_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PriorityValue_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PriorityValue_get_member_value_pointer;

    tms_PriorityValue_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PriorityValue_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PriorityValue_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PriorityValue_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PriorityValue_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PriorityValue_finalize_w_return,
        NULL
    };

    return &tms_PriorityValue_g_typePlugin;
}
#endif

RTIBool tms_PriorityValue_initialize(
    tms_PriorityValue* sample) {
    return tms_PriorityValue_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PriorityValue_initialize_ex(
    tms_PriorityValue* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PriorityValue_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PriorityValue_initialize_w_params(
    tms_PriorityValue* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    (*sample) = 0;

    return RTI_TRUE;
}

RTIBool tms_PriorityValue_finalize_w_return(
    tms_PriorityValue* sample)
{
    tms_PriorityValue_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PriorityValue_finalize(
    tms_PriorityValue* sample)
{

    tms_PriorityValue_finalize_ex(sample,RTI_TRUE);
}

void tms_PriorityValue_finalize_ex(
    tms_PriorityValue* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PriorityValue_finalize_w_params(
        sample,&deallocParams);
}

void tms_PriorityValue_finalize_w_params(
    tms_PriorityValue* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PriorityValue_finalize_optional_members(
    tms_PriorityValue* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PriorityValue_copy(
    tms_PriorityValue* dst,
    const tms_PriorityValue* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyLong (
            dst, src)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PriorityValue' sequence class.
*/
#define T tms_PriorityValue
#define TSeq tms_PriorityValueSeq

#define T_initialize_w_params tms_PriorityValue_initialize_w_params

#define T_finalize_w_params   tms_PriorityValue_finalize_w_params
#define T_copy       tms_PriorityValue_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_Guid_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_Guid_g_tc_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_Guid)));

    static DDS_TypeCode tms_Guid_g_tc =
    {{
            DDS_TK_ALIAS, /* Kind*/
            DDS_BOOLEAN_FALSE,/* Is a pointer? */
            -1, /* Ignored */
            (char *)"tms::Guid", /* Name */
            NULL, /* Content type code is assigned later */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for  tms_Guid */

    if (is_initialized) {
        return &tms_Guid_g_tc;
    }

    tms_Guid_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_Guid_g_tc._data._typeCode =  (RTICdrTypeCode *)&tms_Guid_g_tc_string;

    /* Initialize the values for member annotations. */
    tms_Guid_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_Guid_g_tc._data._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_Guid_g_tc._data._sampleAccessInfo =
    tms_Guid_get_sample_access_info();
    tms_Guid_g_tc._data._typePlugin =
    tms_Guid_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_Guid_g_tc;
}

#define TSeq tms_GuidSeq
#define T tms_Guid
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_Guid_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_Guid_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GuidSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GuidSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_Guid_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_Guid_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_Guid_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_Guid_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_Guid_g_sampleAccessInfo;
    }

    tms_Guid_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_Guid_g_sampleAccessInfo.memberAccessInfos = 
    tms_Guid_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_Guid);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_Guid_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_Guid_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_Guid_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_Guid_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_Guid_get_member_value_pointer;

    tms_Guid_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_Guid_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_Guid_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_Guid_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_Guid_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_Guid_finalize_w_return,
        NULL
    };

    return &tms_Guid_g_typePlugin;
}
#endif

RTIBool tms_Guid_initialize(
    tms_Guid* sample) {
    return tms_Guid_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_Guid_initialize_ex(
    tms_Guid* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_Guid_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_Guid_initialize_w_params(
    tms_Guid* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        (*sample) = DDS_String_alloc(((tms_MAXLEN_Guid)));
        RTICdrType_copyStringEx(
            &(*sample),
            "",
            ((tms_MAXLEN_Guid)),
            RTI_FALSE);
        if ((*sample) == NULL) {
            return RTI_FALSE;
        }
    } else {
        if ((*sample) != NULL) {
            RTICdrType_copyStringEx(
                &(*sample),
                "",
                ((tms_MAXLEN_Guid)),
                RTI_FALSE);
            if ((*sample) == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_Guid_finalize_w_return(
    tms_Guid* sample)
{
    tms_Guid_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_Guid_finalize(
    tms_Guid* sample)
{

    tms_Guid_finalize_ex(sample,RTI_TRUE);
}

void tms_Guid_finalize_ex(
    tms_Guid* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_Guid_finalize_w_params(
        sample,&deallocParams);
}

void tms_Guid_finalize_w_params(
    tms_Guid* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if ((*sample) != NULL) {
        DDS_String_free((*sample));
        (*sample)=NULL;

    }
}

void tms_Guid_finalize_optional_members(
    tms_Guid* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_Guid_copy(
    tms_Guid* dst,
    const tms_Guid* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyStringEx (
            &(*dst), (*src), 
            ((tms_MAXLEN_Guid)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_Guid' sequence class.
*/
#define T tms_Guid
#define TSeq tms_GuidSeq

#define T_initialize_w_params tms_Guid_initialize_w_params

#define T_finalize_w_params   tms_Guid_finalize_w_params
#define T_copy       tms_Guid_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DurationTYPENAME = "tms::Duration";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_Duration_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_Duration_g_tc_members[2]=
    {

        {
            (char *)"second",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nanosecond",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_Duration_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::Duration", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_Duration_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_Duration*/

    if (is_initialized) {
        return &tms_Duration_g_tc;
    }

    tms_Duration_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_Duration_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulonglong_w_new;
    tms_Duration_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulonglong_w_new;

    /* Initialize the values for member annotations. */
    tms_Duration_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_Duration_g_tc_members[0]._annotations._defaultValue._u.ulong_long_value = 0ull;
    tms_Duration_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_Duration_g_tc_members[0]._annotations._minValue._u.ulong_long_value = RTIXCdrUnsignedLongLong_MIN;
    tms_Duration_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_Duration_g_tc_members[0]._annotations._maxValue._u.ulong_long_value = RTIXCdrUnsignedLongLong_MAX;

    tms_Duration_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_Duration_g_tc_members[1]._annotations._defaultValue._u.ulong_long_value = 0ull;
    tms_Duration_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_Duration_g_tc_members[1]._annotations._minValue._u.ulong_long_value = RTIXCdrUnsignedLongLong_MIN;
    tms_Duration_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONGLONG;
    tms_Duration_g_tc_members[1]._annotations._maxValue._u.ulong_long_value = RTIXCdrUnsignedLongLong_MAX;

    tms_Duration_g_tc._data._sampleAccessInfo =
    tms_Duration_get_sample_access_info();
    tms_Duration_g_tc._data._typePlugin =
    tms_Duration_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_Duration_g_tc;
}

#define TSeq tms_DurationSeq
#define T tms_Duration
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_Duration_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_Duration_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DurationSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DurationSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_Duration_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_Duration_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_Duration *sample;

    static RTIXCdrMemberAccessInfo tms_Duration_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_Duration_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_Duration_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_Duration);
    if (sample == NULL) {
        return NULL;
    }

    tms_Duration_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->second - (char *)sample);

    tms_Duration_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nanosecond - (char *)sample);

    tms_Duration_g_sampleAccessInfo.memberAccessInfos = 
    tms_Duration_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_Duration);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_Duration_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_Duration_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_Duration_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_Duration_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_Duration_get_member_value_pointer;

    tms_Duration_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_Duration_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_Duration_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_Duration_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_Duration_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_Duration_finalize_w_return,
        NULL
    };

    return &tms_Duration_g_typePlugin;
}
#endif

RTIBool tms_Duration_initialize(
    tms_Duration* sample) {
    return tms_Duration_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_Duration_initialize_ex(
    tms_Duration* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_Duration_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_Duration_initialize_w_params(
    tms_Duration* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->second = 0ull;

    sample->nanosecond = 0ull;

    return RTI_TRUE;
}

RTIBool tms_Duration_finalize_w_return(
    tms_Duration* sample)
{
    tms_Duration_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_Duration_finalize(
    tms_Duration* sample)
{

    tms_Duration_finalize_ex(sample,RTI_TRUE);
}

void tms_Duration_finalize_ex(
    tms_Duration* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_Duration_finalize_w_params(
        sample,&deallocParams);
}

void tms_Duration_finalize_w_params(
    tms_Duration* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_Duration_finalize_optional_members(
    tms_Duration* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_Duration_copy(
    tms_Duration* dst,
    const tms_Duration* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLongLong (
            &dst->second, &src->second)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLongLong (
            &dst->nanosecond, &src->nanosecond)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_Duration' sequence class.
*/
#define T tms_Duration
#define TSeq tms_DurationSeq

#define T_initialize_w_params tms_Duration_initialize_w_params

#define T_finalize_w_params   tms_Duration_finalize_w_params
#define T_copy       tms_Duration_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_MicrogridIntentTYPENAME = "tms::MicrogridIntent";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_MicrogridIntent_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_MicrogridIntent_g_tc_members[6]=
    {

        {
            (char *)"operatingMode",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"increaseCapacityThreshold",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"decreaseCapacityThreshold",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"decreaseCapacityDuration",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priorityLoadCurtailmentAllowed",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priorityCircuitSheddingAllowed",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_MicrogridIntent_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::MicrogridIntent", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_MicrogridIntent_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_MicrogridIntent*/

    if (is_initialized) {
        return &tms_MicrogridIntent_g_tc;
    }

    tms_MicrogridIntent_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_MicrogridIntent_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_OperatingMode_get_typecode();
    tms_MicrogridIntent_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;
    tms_MicrogridIntent_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_ulong_w_new;
    tms_MicrogridIntent_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_Duration_get_typecode();
    tms_MicrogridIntent_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_PriorityValue_get_typecode();
    tms_MicrogridIntent_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_PriorityValue_get_typecode();

    /* Initialize the values for member annotations. */
    tms_MicrogridIntent_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_MicrogridIntent_g_tc_members[0]._annotations._defaultValue._u.enumerated_value = 0;

    tms_MicrogridIntent_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_MicrogridIntent_g_tc_members[1]._annotations._defaultValue._u.ulong_value = 0u;
    tms_MicrogridIntent_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_MicrogridIntent_g_tc_members[1]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_MicrogridIntent_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_MicrogridIntent_g_tc_members[1]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_MicrogridIntent_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_MicrogridIntent_g_tc_members[2]._annotations._defaultValue._u.ulong_value = 0u;
    tms_MicrogridIntent_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_MicrogridIntent_g_tc_members[2]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_MicrogridIntent_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_MicrogridIntent_g_tc_members[2]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_MicrogridIntent_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_MicrogridIntent_g_tc_members[4]._annotations._defaultValue._u.long_value = 0;
    tms_MicrogridIntent_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_MicrogridIntent_g_tc_members[4]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_MicrogridIntent_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_MicrogridIntent_g_tc_members[4]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_MicrogridIntent_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_MicrogridIntent_g_tc_members[5]._annotations._defaultValue._u.long_value = 0;
    tms_MicrogridIntent_g_tc_members[5]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_MicrogridIntent_g_tc_members[5]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_MicrogridIntent_g_tc_members[5]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_MicrogridIntent_g_tc_members[5]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_MicrogridIntent_g_tc._data._sampleAccessInfo =
    tms_MicrogridIntent_get_sample_access_info();
    tms_MicrogridIntent_g_tc._data._typePlugin =
    tms_MicrogridIntent_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_MicrogridIntent_g_tc;
}

#define TSeq tms_MicrogridIntentSeq
#define T tms_MicrogridIntent
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_MicrogridIntent_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_MicrogridIntent_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_MicrogridIntentSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_MicrogridIntentSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_MicrogridIntent_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_MicrogridIntent_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_MicrogridIntent *sample;

    static RTIXCdrMemberAccessInfo tms_MicrogridIntent_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_MicrogridIntent_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_MicrogridIntent_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_MicrogridIntent);
    if (sample == NULL) {
        return NULL;
    }

    tms_MicrogridIntent_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->operatingMode - (char *)sample);

    tms_MicrogridIntent_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->increaseCapacityThreshold - (char *)sample);

    tms_MicrogridIntent_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->decreaseCapacityThreshold - (char *)sample);

    tms_MicrogridIntent_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->decreaseCapacityDuration - (char *)sample);

    tms_MicrogridIntent_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priorityLoadCurtailmentAllowed - (char *)sample);

    tms_MicrogridIntent_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priorityCircuitSheddingAllowed - (char *)sample);

    tms_MicrogridIntent_g_sampleAccessInfo.memberAccessInfos = 
    tms_MicrogridIntent_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_MicrogridIntent);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_MicrogridIntent_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_MicrogridIntent_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_MicrogridIntent_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_MicrogridIntent_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_MicrogridIntent_get_member_value_pointer;

    tms_MicrogridIntent_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_MicrogridIntent_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_MicrogridIntent_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_MicrogridIntent_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_MicrogridIntent_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_MicrogridIntent_finalize_w_return,
        NULL
    };

    return &tms_MicrogridIntent_g_typePlugin;
}
#endif

RTIBool tms_MicrogridIntent_initialize(
    tms_MicrogridIntent* sample) {
    return tms_MicrogridIntent_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_MicrogridIntent_initialize_ex(
    tms_MicrogridIntent* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_MicrogridIntent_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_MicrogridIntent_initialize_w_params(
    tms_MicrogridIntent* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->operatingMode = OPM_NORMAL;

    sample->increaseCapacityThreshold = 0u;

    sample->decreaseCapacityThreshold = 0u;

    if (!tms_Duration_initialize_w_params(&sample->decreaseCapacityDuration,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->priorityLoadCurtailmentAllowed = 0;

    sample->priorityCircuitSheddingAllowed = 0;

    return RTI_TRUE;
}

RTIBool tms_MicrogridIntent_finalize_w_return(
    tms_MicrogridIntent* sample)
{
    tms_MicrogridIntent_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_MicrogridIntent_finalize(
    tms_MicrogridIntent* sample)
{

    tms_MicrogridIntent_finalize_ex(sample,RTI_TRUE);
}

void tms_MicrogridIntent_finalize_ex(
    tms_MicrogridIntent* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_MicrogridIntent_finalize_w_params(
        sample,&deallocParams);
}

void tms_MicrogridIntent_finalize_w_params(
    tms_MicrogridIntent* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_OperatingMode_finalize_w_params(&sample->operatingMode,deallocParams);

    tms_Duration_finalize_w_params(&sample->decreaseCapacityDuration,deallocParams);

}

void tms_MicrogridIntent_finalize_optional_members(
    tms_MicrogridIntent* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_MicrogridIntent_copy(
    tms_MicrogridIntent* dst,
    const tms_MicrogridIntent* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_OperatingMode_copy(
            &dst->operatingMode,(const tms_OperatingMode*)&src->operatingMode)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedLong (
            &dst->increaseCapacityThreshold, &src->increaseCapacityThreshold)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyUnsignedLong (
            &dst->decreaseCapacityThreshold, &src->decreaseCapacityThreshold)) { 
            return RTI_FALSE;
        }
        if (!tms_Duration_copy(
            &dst->decreaseCapacityDuration,(const tms_Duration*)&src->decreaseCapacityDuration)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyLong (
            &dst->priorityLoadCurtailmentAllowed, &src->priorityLoadCurtailmentAllowed)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyLong (
            &dst->priorityCircuitSheddingAllowed, &src->priorityCircuitSheddingAllowed)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_MicrogridIntent' sequence class.
*/
#define T tms_MicrogridIntent
#define TSeq tms_MicrogridIntentSeq

#define T_initialize_w_params tms_MicrogridIntent_initialize_w_params

#define T_finalize_w_params   tms_MicrogridIntent_finalize_w_params
#define T_copy       tms_MicrogridIntent_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_OverCurrentDisconnectTYPENAME = "tms::OverCurrentDisconnect";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_OverCurrentDisconnect_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_OverCurrentDisconnect_g_tc_members[5]=
    {

        {
            (char *)"currentA",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"currentB",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"currentC",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"currentN",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"delay",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_OverCurrentDisconnect_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::OverCurrentDisconnect", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_OverCurrentDisconnect_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_OverCurrentDisconnect*/

    if (is_initialized) {
        return &tms_OverCurrentDisconnect_g_tc;
    }

    tms_OverCurrentDisconnect_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_OverCurrentDisconnect_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_OverCurrentDisconnect_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_OverCurrentDisconnect_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_OverCurrentDisconnect_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_OverCurrentDisconnect_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_Duration_get_typecode();

    /* Initialize the values for member annotations. */
    tms_OverCurrentDisconnect_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[0]._annotations._defaultValue._u.float_value = 0.0f;
    tms_OverCurrentDisconnect_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[0]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_OverCurrentDisconnect_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[0]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_OverCurrentDisconnect_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_OverCurrentDisconnect_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_OverCurrentDisconnect_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_OverCurrentDisconnect_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_OverCurrentDisconnect_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_OverCurrentDisconnect_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_OverCurrentDisconnect_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_OverCurrentDisconnect_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_OverCurrentDisconnect_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverCurrentDisconnect_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_OverCurrentDisconnect_g_tc._data._sampleAccessInfo =
    tms_OverCurrentDisconnect_get_sample_access_info();
    tms_OverCurrentDisconnect_g_tc._data._typePlugin =
    tms_OverCurrentDisconnect_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_OverCurrentDisconnect_g_tc;
}

#define TSeq tms_OverCurrentDisconnectSeq
#define T tms_OverCurrentDisconnect
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_OverCurrentDisconnect_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_OverCurrentDisconnect_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_OverCurrentDisconnectSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_OverCurrentDisconnectSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_OverCurrentDisconnect_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_OverCurrentDisconnect_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_OverCurrentDisconnect *sample;

    static RTIXCdrMemberAccessInfo tms_OverCurrentDisconnect_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_OverCurrentDisconnect_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_OverCurrentDisconnect_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_OverCurrentDisconnect);
    if (sample == NULL) {
        return NULL;
    }

    tms_OverCurrentDisconnect_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->currentA - (char *)sample);

    tms_OverCurrentDisconnect_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->currentB - (char *)sample);

    tms_OverCurrentDisconnect_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->currentC - (char *)sample);

    tms_OverCurrentDisconnect_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->currentN - (char *)sample);

    tms_OverCurrentDisconnect_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->delay - (char *)sample);

    tms_OverCurrentDisconnect_g_sampleAccessInfo.memberAccessInfos = 
    tms_OverCurrentDisconnect_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_OverCurrentDisconnect);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_OverCurrentDisconnect_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_OverCurrentDisconnect_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_OverCurrentDisconnect_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_OverCurrentDisconnect_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_OverCurrentDisconnect_get_member_value_pointer;

    tms_OverCurrentDisconnect_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_OverCurrentDisconnect_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_OverCurrentDisconnect_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_OverCurrentDisconnect_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_OverCurrentDisconnect_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_OverCurrentDisconnect_finalize_w_return,
        NULL
    };

    return &tms_OverCurrentDisconnect_g_typePlugin;
}
#endif

RTIBool tms_OverCurrentDisconnect_initialize(
    tms_OverCurrentDisconnect* sample) {
    return tms_OverCurrentDisconnect_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_OverCurrentDisconnect_initialize_ex(
    tms_OverCurrentDisconnect* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_OverCurrentDisconnect_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_OverCurrentDisconnect_initialize_w_params(
    tms_OverCurrentDisconnect* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->currentA = 0.0f;

    sample->currentB = 0.0f;

    sample->currentC = 0.0f;

    sample->currentN = 0.0f;

    if (!tms_Duration_initialize_w_params(&sample->delay,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_OverCurrentDisconnect_finalize_w_return(
    tms_OverCurrentDisconnect* sample)
{
    tms_OverCurrentDisconnect_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_OverCurrentDisconnect_finalize(
    tms_OverCurrentDisconnect* sample)
{

    tms_OverCurrentDisconnect_finalize_ex(sample,RTI_TRUE);
}

void tms_OverCurrentDisconnect_finalize_ex(
    tms_OverCurrentDisconnect* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_OverCurrentDisconnect_finalize_w_params(
        sample,&deallocParams);
}

void tms_OverCurrentDisconnect_finalize_w_params(
    tms_OverCurrentDisconnect* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Duration_finalize_w_params(&sample->delay,deallocParams);

}

void tms_OverCurrentDisconnect_finalize_optional_members(
    tms_OverCurrentDisconnect* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_OverCurrentDisconnect_copy(
    tms_OverCurrentDisconnect* dst,
    const tms_OverCurrentDisconnect* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyFloat (
            &dst->currentA, &src->currentA)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->currentB, &src->currentB)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->currentC, &src->currentC)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->currentN, &src->currentN)) { 
            return RTI_FALSE;
        }
        if (!tms_Duration_copy(
            &dst->delay,(const tms_Duration*)&src->delay)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_OverCurrentDisconnect' sequence class.
*/
#define T tms_OverCurrentDisconnect
#define TSeq tms_OverCurrentDisconnectSeq

#define T_initialize_w_params tms_OverCurrentDisconnect_initialize_w_params

#define T_finalize_w_params   tms_OverCurrentDisconnect_finalize_w_params
#define T_copy       tms_OverCurrentDisconnect_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_OverEnergyDisconnectTYPENAME = "tms::OverEnergyDisconnect";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_OverEnergyDisconnect_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_OverEnergyDisconnect_g_tc_members[3]=
    {

        {
            (char *)"balance",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"maxBalance",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"refillRate",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_OverEnergyDisconnect_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::OverEnergyDisconnect", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_OverEnergyDisconnect_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_OverEnergyDisconnect*/

    if (is_initialized) {
        return &tms_OverEnergyDisconnect_g_tc;
    }

    tms_OverEnergyDisconnect_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_OverEnergyDisconnect_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_OverEnergyDisconnect_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_OverEnergyDisconnect_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */
    tms_OverEnergyDisconnect_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[0]._annotations._defaultValue._u.float_value = 0.0f;
    tms_OverEnergyDisconnect_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[0]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_OverEnergyDisconnect_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[0]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_OverEnergyDisconnect_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_OverEnergyDisconnect_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_OverEnergyDisconnect_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_OverEnergyDisconnect_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_OverEnergyDisconnect_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_OverEnergyDisconnect_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_OverEnergyDisconnect_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_OverEnergyDisconnect_g_tc._data._sampleAccessInfo =
    tms_OverEnergyDisconnect_get_sample_access_info();
    tms_OverEnergyDisconnect_g_tc._data._typePlugin =
    tms_OverEnergyDisconnect_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_OverEnergyDisconnect_g_tc;
}

#define TSeq tms_OverEnergyDisconnectSeq
#define T tms_OverEnergyDisconnect
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_OverEnergyDisconnect_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_OverEnergyDisconnect_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_OverEnergyDisconnectSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_OverEnergyDisconnectSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_OverEnergyDisconnect_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_OverEnergyDisconnect_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_OverEnergyDisconnect *sample;

    static RTIXCdrMemberAccessInfo tms_OverEnergyDisconnect_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_OverEnergyDisconnect_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_OverEnergyDisconnect_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_OverEnergyDisconnect);
    if (sample == NULL) {
        return NULL;
    }

    tms_OverEnergyDisconnect_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->balance - (char *)sample);

    tms_OverEnergyDisconnect_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->maxBalance - (char *)sample);

    tms_OverEnergyDisconnect_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->refillRate - (char *)sample);

    tms_OverEnergyDisconnect_g_sampleAccessInfo.memberAccessInfos = 
    tms_OverEnergyDisconnect_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_OverEnergyDisconnect);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_OverEnergyDisconnect_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_OverEnergyDisconnect_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_OverEnergyDisconnect_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_OverEnergyDisconnect_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_OverEnergyDisconnect_get_member_value_pointer;

    tms_OverEnergyDisconnect_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_OverEnergyDisconnect_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_OverEnergyDisconnect_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_OverEnergyDisconnect_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_OverEnergyDisconnect_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_OverEnergyDisconnect_finalize_w_return,
        NULL
    };

    return &tms_OverEnergyDisconnect_g_typePlugin;
}
#endif

RTIBool tms_OverEnergyDisconnect_initialize(
    tms_OverEnergyDisconnect* sample) {
    return tms_OverEnergyDisconnect_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_OverEnergyDisconnect_initialize_ex(
    tms_OverEnergyDisconnect* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_OverEnergyDisconnect_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_OverEnergyDisconnect_initialize_w_params(
    tms_OverEnergyDisconnect* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->balance = 0.0f;

    sample->maxBalance = 0.0f;

    sample->refillRate = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_OverEnergyDisconnect_finalize_w_return(
    tms_OverEnergyDisconnect* sample)
{
    tms_OverEnergyDisconnect_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_OverEnergyDisconnect_finalize(
    tms_OverEnergyDisconnect* sample)
{

    tms_OverEnergyDisconnect_finalize_ex(sample,RTI_TRUE);
}

void tms_OverEnergyDisconnect_finalize_ex(
    tms_OverEnergyDisconnect* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_OverEnergyDisconnect_finalize_w_params(
        sample,&deallocParams);
}

void tms_OverEnergyDisconnect_finalize_w_params(
    tms_OverEnergyDisconnect* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_OverEnergyDisconnect_finalize_optional_members(
    tms_OverEnergyDisconnect* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_OverEnergyDisconnect_copy(
    tms_OverEnergyDisconnect* dst,
    const tms_OverEnergyDisconnect* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyFloat (
            &dst->balance, &src->balance)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->maxBalance, &src->maxBalance)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->refillRate, &src->refillRate)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_OverEnergyDisconnect' sequence class.
*/
#define T tms_OverEnergyDisconnect
#define TSeq tms_OverEnergyDisconnectSeq

#define T_initialize_w_params tms_OverEnergyDisconnect_initialize_w_params

#define T_finalize_w_params   tms_OverEnergyDisconnect_finalize_w_params
#define T_copy       tms_OverEnergyDisconnect_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_UnderFrequencyDisconnectTYPENAME = "tms::UnderFrequencyDisconnect";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_UnderFrequencyDisconnect_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_UnderFrequencyDisconnect_g_tc_members[3]=
    {

        {
            (char *)"frequency",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"delay",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"objective",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_UnderFrequencyDisconnect_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::UnderFrequencyDisconnect", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_UnderFrequencyDisconnect_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_UnderFrequencyDisconnect*/

    if (is_initialized) {
        return &tms_UnderFrequencyDisconnect_g_tc;
    }

    tms_UnderFrequencyDisconnect_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_UnderFrequencyDisconnect_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_UnderFrequencyDisconnect_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Duration_get_typecode();
    tms_UnderFrequencyDisconnect_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */
    tms_UnderFrequencyDisconnect_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_UnderFrequencyDisconnect_g_tc_members[0]._annotations._defaultValue._u.float_value = 0.0f;
    tms_UnderFrequencyDisconnect_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_UnderFrequencyDisconnect_g_tc_members[0]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_UnderFrequencyDisconnect_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_UnderFrequencyDisconnect_g_tc_members[0]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_UnderFrequencyDisconnect_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_UnderFrequencyDisconnect_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_UnderFrequencyDisconnect_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_UnderFrequencyDisconnect_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_UnderFrequencyDisconnect_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_UnderFrequencyDisconnect_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_UnderFrequencyDisconnect_g_tc._data._sampleAccessInfo =
    tms_UnderFrequencyDisconnect_get_sample_access_info();
    tms_UnderFrequencyDisconnect_g_tc._data._typePlugin =
    tms_UnderFrequencyDisconnect_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_UnderFrequencyDisconnect_g_tc;
}

#define TSeq tms_UnderFrequencyDisconnectSeq
#define T tms_UnderFrequencyDisconnect
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_UnderFrequencyDisconnect_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_UnderFrequencyDisconnect_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_UnderFrequencyDisconnectSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_UnderFrequencyDisconnectSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_UnderFrequencyDisconnect_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_UnderFrequencyDisconnect_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_UnderFrequencyDisconnect *sample;

    static RTIXCdrMemberAccessInfo tms_UnderFrequencyDisconnect_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_UnderFrequencyDisconnect_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_UnderFrequencyDisconnect_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_UnderFrequencyDisconnect);
    if (sample == NULL) {
        return NULL;
    }

    tms_UnderFrequencyDisconnect_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->frequency - (char *)sample);

    tms_UnderFrequencyDisconnect_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->delay - (char *)sample);

    tms_UnderFrequencyDisconnect_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->objective - (char *)sample);

    tms_UnderFrequencyDisconnect_g_sampleAccessInfo.memberAccessInfos = 
    tms_UnderFrequencyDisconnect_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_UnderFrequencyDisconnect);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_UnderFrequencyDisconnect_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_UnderFrequencyDisconnect_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_UnderFrequencyDisconnect_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_UnderFrequencyDisconnect_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_UnderFrequencyDisconnect_get_member_value_pointer;

    tms_UnderFrequencyDisconnect_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_UnderFrequencyDisconnect_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_UnderFrequencyDisconnect_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_UnderFrequencyDisconnect_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_UnderFrequencyDisconnect_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_UnderFrequencyDisconnect_finalize_w_return,
        NULL
    };

    return &tms_UnderFrequencyDisconnect_g_typePlugin;
}
#endif

RTIBool tms_UnderFrequencyDisconnect_initialize(
    tms_UnderFrequencyDisconnect* sample) {
    return tms_UnderFrequencyDisconnect_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_UnderFrequencyDisconnect_initialize_ex(
    tms_UnderFrequencyDisconnect* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_UnderFrequencyDisconnect_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_UnderFrequencyDisconnect_initialize_w_params(
    tms_UnderFrequencyDisconnect* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->frequency = 0.0f;

    if (!tms_Duration_initialize_w_params(&sample->delay,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->objective = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_UnderFrequencyDisconnect_finalize_w_return(
    tms_UnderFrequencyDisconnect* sample)
{
    tms_UnderFrequencyDisconnect_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_UnderFrequencyDisconnect_finalize(
    tms_UnderFrequencyDisconnect* sample)
{

    tms_UnderFrequencyDisconnect_finalize_ex(sample,RTI_TRUE);
}

void tms_UnderFrequencyDisconnect_finalize_ex(
    tms_UnderFrequencyDisconnect* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_UnderFrequencyDisconnect_finalize_w_params(
        sample,&deallocParams);
}

void tms_UnderFrequencyDisconnect_finalize_w_params(
    tms_UnderFrequencyDisconnect* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Duration_finalize_w_params(&sample->delay,deallocParams);

}

void tms_UnderFrequencyDisconnect_finalize_optional_members(
    tms_UnderFrequencyDisconnect* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_UnderFrequencyDisconnect_copy(
    tms_UnderFrequencyDisconnect* dst,
    const tms_UnderFrequencyDisconnect* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyFloat (
            &dst->frequency, &src->frequency)) { 
            return RTI_FALSE;
        }
        if (!tms_Duration_copy(
            &dst->delay,(const tms_Duration*)&src->delay)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->objective, &src->objective)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_UnderFrequencyDisconnect' sequence class.
*/
#define T tms_UnderFrequencyDisconnect
#define TSeq tms_UnderFrequencyDisconnectSeq

#define T_initialize_w_params tms_UnderFrequencyDisconnect_initialize_w_params

#define T_finalize_w_params   tms_UnderFrequencyDisconnect_finalize_w_params
#define T_copy       tms_UnderFrequencyDisconnect_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LocalPowerPortPriorityTYPENAME = "tms::LocalPowerPortPriority";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LocalPowerPortPriority_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LocalPowerPortPriority_g_tc_members[7]=
    {

        {
            (char *)"LPPP_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPPP_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPPP_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPPP_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPPP_OFF",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPPP_OFF, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPPP_LOW",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPPP_LOW, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPPP_MEDIUM",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPPP_MEDIUM, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPPP_HIGH",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPPP_HIGH, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPPP_ON",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPPP_ON, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LocalPowerPortPriority_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LocalPowerPortPriority", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            7, /* Number of members */
            tms_LocalPowerPortPriority_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LocalPowerPortPriority*/

    if (is_initialized) {
        return &tms_LocalPowerPortPriority_g_tc;
    }

    tms_LocalPowerPortPriority_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_LocalPowerPortPriority_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_LocalPowerPortPriority_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_LocalPowerPortPriority_g_tc._data._sampleAccessInfo =
    tms_LocalPowerPortPriority_get_sample_access_info();
    tms_LocalPowerPortPriority_g_tc._data._typePlugin =
    tms_LocalPowerPortPriority_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LocalPowerPortPriority_g_tc;
}

#define TSeq tms_LocalPowerPortPrioritySeq
#define T tms_LocalPowerPortPriority
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LocalPowerPortPriority_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LocalPowerPortPriority_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LocalPowerPortPrioritySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LocalPowerPortPrioritySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LocalPowerPortPriority_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LocalPowerPortPriority_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_LocalPowerPortPriority_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LocalPowerPortPriority_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LocalPowerPortPriority_g_sampleAccessInfo;
    }

    tms_LocalPowerPortPriority_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_LocalPowerPortPriority_g_sampleAccessInfo.memberAccessInfos = 
    tms_LocalPowerPortPriority_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LocalPowerPortPriority);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LocalPowerPortPriority_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LocalPowerPortPriority_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LocalPowerPortPriority_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LocalPowerPortPriority_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LocalPowerPortPriority_get_member_value_pointer;

    tms_LocalPowerPortPriority_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LocalPowerPortPriority_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LocalPowerPortPriority_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LocalPowerPortPriority_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LocalPowerPortPriority_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LocalPowerPortPriority_finalize_w_return,
        NULL
    };

    return &tms_LocalPowerPortPriority_g_typePlugin;
}
#endif

RTIBool tms_LocalPowerPortPriority_initialize(
    tms_LocalPowerPortPriority* sample) {
    *sample = LPPP_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_LocalPowerPortPriority_initialize_ex(
    tms_LocalPowerPortPriority* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LocalPowerPortPriority_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LocalPowerPortPriority_initialize_w_params(
    tms_LocalPowerPortPriority* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = LPPP_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_LocalPowerPortPriority_finalize_w_return(
    tms_LocalPowerPortPriority* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_LocalPowerPortPriority_finalize(
    tms_LocalPowerPortPriority* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_LocalPowerPortPriority_finalize_ex(
    tms_LocalPowerPortPriority* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LocalPowerPortPriority_finalize_w_params(
        sample,&deallocParams);
}

void tms_LocalPowerPortPriority_finalize_w_params(
    tms_LocalPowerPortPriority* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_LocalPowerPortPriority_finalize_optional_members(
    tms_LocalPowerPortPriority* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LocalPowerPortPriority_copy(
    tms_LocalPowerPortPriority* dst,
    const tms_LocalPowerPortPriority* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LocalPowerPortPriority' sequence class.
*/
#define T tms_LocalPowerPortPriority
#define TSeq tms_LocalPowerPortPrioritySeq

#define T_initialize_w_params tms_LocalPowerPortPriority_initialize_w_params

#define T_finalize_w_params   tms_LocalPowerPortPriority_finalize_w_params
#define T_copy       tms_LocalPowerPortPriority_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LocalPowerPortPriorityAssignmentTYPENAME = "tms::LocalPowerPortPriorityAssignment";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LocalPowerPortPriorityAssignment_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LocalPowerPortPriorityAssignment_g_tc_members[2]=
    {

        {
            (char *)"portNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priority",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LocalPowerPortPriorityAssignment_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LocalPowerPortPriorityAssignment", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_LocalPowerPortPriorityAssignment_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LocalPowerPortPriorityAssignment*/

    if (is_initialized) {
        return &tms_LocalPowerPortPriorityAssignment_g_tc;
    }

    tms_LocalPowerPortPriorityAssignment_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LocalPowerPortPriorityAssignment_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_LocalPowerPortPriorityAssignment_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriority_get_typecode();

    /* Initialize the values for member annotations. */
    tms_LocalPowerPortPriorityAssignment_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_LocalPowerPortPriorityAssignment_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_LocalPowerPortPriorityAssignment_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_LocalPowerPortPriorityAssignment_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_LocalPowerPortPriorityAssignment_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_LocalPowerPortPriorityAssignment_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_LocalPowerPortPriorityAssignment_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_LocalPowerPortPriorityAssignment_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_LocalPowerPortPriorityAssignment_g_tc._data._sampleAccessInfo =
    tms_LocalPowerPortPriorityAssignment_get_sample_access_info();
    tms_LocalPowerPortPriorityAssignment_g_tc._data._typePlugin =
    tms_LocalPowerPortPriorityAssignment_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LocalPowerPortPriorityAssignment_g_tc;
}

#define TSeq tms_LocalPowerPortPriorityAssignmentSeq
#define T tms_LocalPowerPortPriorityAssignment
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LocalPowerPortPriorityAssignment_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LocalPowerPortPriorityAssignment_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LocalPowerPortPriorityAssignmentSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LocalPowerPortPriorityAssignmentSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LocalPowerPortPriorityAssignment_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LocalPowerPortPriorityAssignment_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LocalPowerPortPriorityAssignment *sample;

    static RTIXCdrMemberAccessInfo tms_LocalPowerPortPriorityAssignment_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LocalPowerPortPriorityAssignment);
    if (sample == NULL) {
        return NULL;
    }

    tms_LocalPowerPortPriorityAssignment_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_LocalPowerPortPriorityAssignment_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priority - (char *)sample);

    tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo.memberAccessInfos = 
    tms_LocalPowerPortPriorityAssignment_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LocalPowerPortPriorityAssignment);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LocalPowerPortPriorityAssignment_get_member_value_pointer;

    tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LocalPowerPortPriorityAssignment_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LocalPowerPortPriorityAssignment_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LocalPowerPortPriorityAssignment_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LocalPowerPortPriorityAssignment_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LocalPowerPortPriorityAssignment_finalize_w_return,
        NULL
    };

    return &tms_LocalPowerPortPriorityAssignment_g_typePlugin;
}
#endif

RTIBool tms_LocalPowerPortPriorityAssignment_initialize(
    tms_LocalPowerPortPriorityAssignment* sample) {
    return tms_LocalPowerPortPriorityAssignment_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LocalPowerPortPriorityAssignment_initialize_ex(
    tms_LocalPowerPortPriorityAssignment* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LocalPowerPortPriorityAssignment_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LocalPowerPortPriorityAssignment_initialize_w_params(
    tms_LocalPowerPortPriorityAssignment* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    sample->priority = LPPP_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_LocalPowerPortPriorityAssignment_finalize_w_return(
    tms_LocalPowerPortPriorityAssignment* sample)
{
    tms_LocalPowerPortPriorityAssignment_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LocalPowerPortPriorityAssignment_finalize(
    tms_LocalPowerPortPriorityAssignment* sample)
{

    tms_LocalPowerPortPriorityAssignment_finalize_ex(sample,RTI_TRUE);
}

void tms_LocalPowerPortPriorityAssignment_finalize_ex(
    tms_LocalPowerPortPriorityAssignment* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LocalPowerPortPriorityAssignment_finalize_w_params(
        sample,&deallocParams);
}

void tms_LocalPowerPortPriorityAssignment_finalize_w_params(
    tms_LocalPowerPortPriorityAssignment* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_LocalPowerPortPriority_finalize_w_params(&sample->priority,deallocParams);

}

void tms_LocalPowerPortPriorityAssignment_finalize_optional_members(
    tms_LocalPowerPortPriorityAssignment* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LocalPowerPortPriorityAssignment_copy(
    tms_LocalPowerPortPriorityAssignment* dst,
    const tms_LocalPowerPortPriorityAssignment* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_LocalPowerPortPriority_copy(
            &dst->priority,(const tms_LocalPowerPortPriority*)&src->priority)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LocalPowerPortPriorityAssignment' sequence class.
*/
#define T tms_LocalPowerPortPriorityAssignment
#define TSeq tms_LocalPowerPortPriorityAssignmentSeq

#define T_initialize_w_params tms_LocalPowerPortPriorityAssignment_initialize_w_params

#define T_finalize_w_params   tms_LocalPowerPortPriorityAssignment_finalize_w_params
#define T_copy       tms_LocalPowerPortPriorityAssignment_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerPortLoadPolicyTYPENAME = "tms::PowerPortLoadPolicy";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortLoadPolicy_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerPortLoadPolicy_g_tc_members[6]=
    {

        {
            (char *)"portNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"inrushCurrent",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"steadyCurrent",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"inrushFrequency",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"steadyFrequency",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"energy",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerPortLoadPolicy_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerPortLoadPolicy", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_PowerPortLoadPolicy_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerPortLoadPolicy*/

    if (is_initialized) {
        return &tms_PowerPortLoadPolicy_g_tc;
    }

    tms_PowerPortLoadPolicy_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortLoadPolicy_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_PowerPortLoadPolicy_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_OverCurrentDisconnect_get_typecode();
    tms_PowerPortLoadPolicy_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_OverCurrentDisconnect_get_typecode();
    tms_PowerPortLoadPolicy_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_UnderFrequencyDisconnect_get_typecode();
    tms_PowerPortLoadPolicy_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_UnderFrequencyDisconnect_get_typecode();
    tms_PowerPortLoadPolicy_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_OverEnergyDisconnect_get_typecode();

    /* Initialize the values for member annotations. */
    tms_PowerPortLoadPolicy_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortLoadPolicy_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortLoadPolicy_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortLoadPolicy_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortLoadPolicy_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortLoadPolicy_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortLoadPolicy_g_tc._data._sampleAccessInfo =
    tms_PowerPortLoadPolicy_get_sample_access_info();
    tms_PowerPortLoadPolicy_g_tc._data._typePlugin =
    tms_PowerPortLoadPolicy_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortLoadPolicy_g_tc;
}

#define TSeq tms_PowerPortLoadPolicySeq
#define T tms_PowerPortLoadPolicy
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortLoadPolicy_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortLoadPolicy_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortLoadPolicySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortLoadPolicySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortLoadPolicy_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortLoadPolicy_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerPortLoadPolicy *sample;

    static RTIXCdrMemberAccessInfo tms_PowerPortLoadPolicy_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortLoadPolicy_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortLoadPolicy_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerPortLoadPolicy);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerPortLoadPolicy_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerPortLoadPolicy_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->inrushCurrent - (char *)sample);

    tms_PowerPortLoadPolicy_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->steadyCurrent - (char *)sample);

    tms_PowerPortLoadPolicy_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->inrushFrequency - (char *)sample);

    tms_PowerPortLoadPolicy_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->steadyFrequency - (char *)sample);

    tms_PowerPortLoadPolicy_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->energy - (char *)sample);

    tms_PowerPortLoadPolicy_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortLoadPolicy_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortLoadPolicy);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortLoadPolicy_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortLoadPolicy_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortLoadPolicy_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortLoadPolicy_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortLoadPolicy_get_member_value_pointer;

    tms_PowerPortLoadPolicy_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortLoadPolicy_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortLoadPolicy_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortLoadPolicy_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortLoadPolicy_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortLoadPolicy_finalize_w_return,
        NULL
    };

    return &tms_PowerPortLoadPolicy_g_typePlugin;
}
#endif

RTIBool tms_PowerPortLoadPolicy_initialize(
    tms_PowerPortLoadPolicy* sample) {
    return tms_PowerPortLoadPolicy_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortLoadPolicy_initialize_ex(
    tms_PowerPortLoadPolicy* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortLoadPolicy_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortLoadPolicy_initialize_w_params(
    tms_PowerPortLoadPolicy* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    if (!tms_OverCurrentDisconnect_initialize_w_params(&sample->inrushCurrent,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_OverCurrentDisconnect_initialize_w_params(&sample->steadyCurrent,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_UnderFrequencyDisconnect_initialize_w_params(&sample->inrushFrequency,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_UnderFrequencyDisconnect_initialize_w_params(&sample->steadyFrequency,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_OverEnergyDisconnect_initialize_w_params(&sample->energy,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_PowerPortLoadPolicy_finalize_w_return(
    tms_PowerPortLoadPolicy* sample)
{
    tms_PowerPortLoadPolicy_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortLoadPolicy_finalize(
    tms_PowerPortLoadPolicy* sample)
{

    tms_PowerPortLoadPolicy_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortLoadPolicy_finalize_ex(
    tms_PowerPortLoadPolicy* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortLoadPolicy_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortLoadPolicy_finalize_w_params(
    tms_PowerPortLoadPolicy* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_OverCurrentDisconnect_finalize_w_params(&sample->inrushCurrent,deallocParams);

    tms_OverCurrentDisconnect_finalize_w_params(&sample->steadyCurrent,deallocParams);

    tms_UnderFrequencyDisconnect_finalize_w_params(&sample->inrushFrequency,deallocParams);

    tms_UnderFrequencyDisconnect_finalize_w_params(&sample->steadyFrequency,deallocParams);

    tms_OverEnergyDisconnect_finalize_w_params(&sample->energy,deallocParams);

}

void tms_PowerPortLoadPolicy_finalize_optional_members(
    tms_PowerPortLoadPolicy* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortLoadPolicy_copy(
    tms_PowerPortLoadPolicy* dst,
    const tms_PowerPortLoadPolicy* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_OverCurrentDisconnect_copy(
            &dst->inrushCurrent,(const tms_OverCurrentDisconnect*)&src->inrushCurrent)) {
            return RTI_FALSE;
        } 
        if (!tms_OverCurrentDisconnect_copy(
            &dst->steadyCurrent,(const tms_OverCurrentDisconnect*)&src->steadyCurrent)) {
            return RTI_FALSE;
        } 
        if (!tms_UnderFrequencyDisconnect_copy(
            &dst->inrushFrequency,(const tms_UnderFrequencyDisconnect*)&src->inrushFrequency)) {
            return RTI_FALSE;
        } 
        if (!tms_UnderFrequencyDisconnect_copy(
            &dst->steadyFrequency,(const tms_UnderFrequencyDisconnect*)&src->steadyFrequency)) {
            return RTI_FALSE;
        } 
        if (!tms_OverEnergyDisconnect_copy(
            &dst->energy,(const tms_OverEnergyDisconnect*)&src->energy)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortLoadPolicy' sequence class.
*/
#define T tms_PowerPortLoadPolicy
#define TSeq tms_PowerPortLoadPolicySeq

#define T_initialize_w_params tms_PowerPortLoadPolicy_initialize_w_params

#define T_finalize_w_params   tms_PowerPortLoadPolicy_finalize_w_params
#define T_copy       tms_PowerPortLoadPolicy_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_BusbarLoadPolicyTYPENAME = "tms::BusbarLoadPolicy";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_BusbarLoadPolicy_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_BusbarLoadPolicy_g_tc_members[10]=
    {

        {
            (char *)"inrushCurrent",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"inrushCurrentPriority",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"steadyCurrent",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"steadyCurrentPriority",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"inrushFrequency",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"inrushFrequencyPriority",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"steadyFrequency",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"steadyFrequencyPriority",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"energy",/* Member name */
            {
                8,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"energyPriority",/* Member name */
            {
                9,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_BusbarLoadPolicy_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::BusbarLoadPolicy", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            10, /* Number of members */
            tms_BusbarLoadPolicy_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_BusbarLoadPolicy*/

    if (is_initialized) {
        return &tms_BusbarLoadPolicy_g_tc;
    }

    tms_BusbarLoadPolicy_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_BusbarLoadPolicy_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_OverCurrentDisconnect_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriority_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_OverCurrentDisconnect_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriority_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_UnderFrequencyDisconnect_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriority_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)tms_UnderFrequencyDisconnect_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriority_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[8]._representation._typeCode = (RTICdrTypeCode *)tms_OverEnergyDisconnect_get_typecode();
    tms_BusbarLoadPolicy_g_tc_members[9]._representation._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriority_get_typecode();

    /* Initialize the values for member annotations. */

    tms_BusbarLoadPolicy_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_BusbarLoadPolicy_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_BusbarLoadPolicy_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_BusbarLoadPolicy_g_tc_members[3]._annotations._defaultValue._u.enumerated_value = 0;

    tms_BusbarLoadPolicy_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_BusbarLoadPolicy_g_tc_members[5]._annotations._defaultValue._u.enumerated_value = 0;

    tms_BusbarLoadPolicy_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_BusbarLoadPolicy_g_tc_members[7]._annotations._defaultValue._u.enumerated_value = 0;

    tms_BusbarLoadPolicy_g_tc_members[9]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_BusbarLoadPolicy_g_tc_members[9]._annotations._defaultValue._u.enumerated_value = 0;

    tms_BusbarLoadPolicy_g_tc._data._sampleAccessInfo =
    tms_BusbarLoadPolicy_get_sample_access_info();
    tms_BusbarLoadPolicy_g_tc._data._typePlugin =
    tms_BusbarLoadPolicy_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_BusbarLoadPolicy_g_tc;
}

#define TSeq tms_BusbarLoadPolicySeq
#define T tms_BusbarLoadPolicy
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_BusbarLoadPolicy_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_BusbarLoadPolicy_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_BusbarLoadPolicySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_BusbarLoadPolicySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_BusbarLoadPolicy_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_BusbarLoadPolicy_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_BusbarLoadPolicy *sample;

    static RTIXCdrMemberAccessInfo tms_BusbarLoadPolicy_g_memberAccessInfos[10] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_BusbarLoadPolicy_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_BusbarLoadPolicy_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_BusbarLoadPolicy);
    if (sample == NULL) {
        return NULL;
    }

    tms_BusbarLoadPolicy_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->inrushCurrent - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->inrushCurrentPriority - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->steadyCurrent - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->steadyCurrentPriority - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->inrushFrequency - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->inrushFrequencyPriority - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->steadyFrequency - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->steadyFrequencyPriority - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[8].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->energy - (char *)sample);

    tms_BusbarLoadPolicy_g_memberAccessInfos[9].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->energyPriority - (char *)sample);

    tms_BusbarLoadPolicy_g_sampleAccessInfo.memberAccessInfos = 
    tms_BusbarLoadPolicy_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_BusbarLoadPolicy);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_BusbarLoadPolicy_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_BusbarLoadPolicy_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_BusbarLoadPolicy_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_BusbarLoadPolicy_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_BusbarLoadPolicy_get_member_value_pointer;

    tms_BusbarLoadPolicy_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_BusbarLoadPolicy_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_BusbarLoadPolicy_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_BusbarLoadPolicy_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_BusbarLoadPolicy_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_BusbarLoadPolicy_finalize_w_return,
        NULL
    };

    return &tms_BusbarLoadPolicy_g_typePlugin;
}
#endif

RTIBool tms_BusbarLoadPolicy_initialize(
    tms_BusbarLoadPolicy* sample) {
    return tms_BusbarLoadPolicy_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_BusbarLoadPolicy_initialize_ex(
    tms_BusbarLoadPolicy* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_BusbarLoadPolicy_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_BusbarLoadPolicy_initialize_w_params(
    tms_BusbarLoadPolicy* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_OverCurrentDisconnect_initialize_w_params(&sample->inrushCurrent,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->inrushCurrentPriority = LPPP_UNINITIALIZED;
    if (!tms_OverCurrentDisconnect_initialize_w_params(&sample->steadyCurrent,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->steadyCurrentPriority = LPPP_UNINITIALIZED;
    if (!tms_UnderFrequencyDisconnect_initialize_w_params(&sample->inrushFrequency,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->inrushFrequencyPriority = LPPP_UNINITIALIZED;
    if (!tms_UnderFrequencyDisconnect_initialize_w_params(&sample->steadyFrequency,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->steadyFrequencyPriority = LPPP_UNINITIALIZED;
    if (!tms_OverEnergyDisconnect_initialize_w_params(&sample->energy,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->energyPriority = LPPP_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_BusbarLoadPolicy_finalize_w_return(
    tms_BusbarLoadPolicy* sample)
{
    tms_BusbarLoadPolicy_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_BusbarLoadPolicy_finalize(
    tms_BusbarLoadPolicy* sample)
{

    tms_BusbarLoadPolicy_finalize_ex(sample,RTI_TRUE);
}

void tms_BusbarLoadPolicy_finalize_ex(
    tms_BusbarLoadPolicy* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_BusbarLoadPolicy_finalize_w_params(
        sample,&deallocParams);
}

void tms_BusbarLoadPolicy_finalize_w_params(
    tms_BusbarLoadPolicy* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_OverCurrentDisconnect_finalize_w_params(&sample->inrushCurrent,deallocParams);

    tms_LocalPowerPortPriority_finalize_w_params(&sample->inrushCurrentPriority,deallocParams);

    tms_OverCurrentDisconnect_finalize_w_params(&sample->steadyCurrent,deallocParams);

    tms_LocalPowerPortPriority_finalize_w_params(&sample->steadyCurrentPriority,deallocParams);

    tms_UnderFrequencyDisconnect_finalize_w_params(&sample->inrushFrequency,deallocParams);

    tms_LocalPowerPortPriority_finalize_w_params(&sample->inrushFrequencyPriority,deallocParams);

    tms_UnderFrequencyDisconnect_finalize_w_params(&sample->steadyFrequency,deallocParams);

    tms_LocalPowerPortPriority_finalize_w_params(&sample->steadyFrequencyPriority,deallocParams);

    tms_OverEnergyDisconnect_finalize_w_params(&sample->energy,deallocParams);

    tms_LocalPowerPortPriority_finalize_w_params(&sample->energyPriority,deallocParams);

}

void tms_BusbarLoadPolicy_finalize_optional_members(
    tms_BusbarLoadPolicy* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_BusbarLoadPolicy_copy(
    tms_BusbarLoadPolicy* dst,
    const tms_BusbarLoadPolicy* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_OverCurrentDisconnect_copy(
            &dst->inrushCurrent,(const tms_OverCurrentDisconnect*)&src->inrushCurrent)) {
            return RTI_FALSE;
        } 
        if (!tms_LocalPowerPortPriority_copy(
            &dst->inrushCurrentPriority,(const tms_LocalPowerPortPriority*)&src->inrushCurrentPriority)) {
            return RTI_FALSE;
        } 
        if (!tms_OverCurrentDisconnect_copy(
            &dst->steadyCurrent,(const tms_OverCurrentDisconnect*)&src->steadyCurrent)) {
            return RTI_FALSE;
        } 
        if (!tms_LocalPowerPortPriority_copy(
            &dst->steadyCurrentPriority,(const tms_LocalPowerPortPriority*)&src->steadyCurrentPriority)) {
            return RTI_FALSE;
        } 
        if (!tms_UnderFrequencyDisconnect_copy(
            &dst->inrushFrequency,(const tms_UnderFrequencyDisconnect*)&src->inrushFrequency)) {
            return RTI_FALSE;
        } 
        if (!tms_LocalPowerPortPriority_copy(
            &dst->inrushFrequencyPriority,(const tms_LocalPowerPortPriority*)&src->inrushFrequencyPriority)) {
            return RTI_FALSE;
        } 
        if (!tms_UnderFrequencyDisconnect_copy(
            &dst->steadyFrequency,(const tms_UnderFrequencyDisconnect*)&src->steadyFrequency)) {
            return RTI_FALSE;
        } 
        if (!tms_LocalPowerPortPriority_copy(
            &dst->steadyFrequencyPriority,(const tms_LocalPowerPortPriority*)&src->steadyFrequencyPriority)) {
            return RTI_FALSE;
        } 
        if (!tms_OverEnergyDisconnect_copy(
            &dst->energy,(const tms_OverEnergyDisconnect*)&src->energy)) {
            return RTI_FALSE;
        } 
        if (!tms_LocalPowerPortPriority_copy(
            &dst->energyPriority,(const tms_LocalPowerPortPriority*)&src->energyPriority)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_BusbarLoadPolicy' sequence class.
*/
#define T tms_BusbarLoadPolicy
#define TSeq tms_BusbarLoadPolicySeq

#define T_initialize_w_params tms_BusbarLoadPolicy_initialize_w_params

#define T_finalize_w_params   tms_BusbarLoadPolicy_finalize_w_params
#define T_copy       tms_BusbarLoadPolicy_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceIntentTYPENAME = "tms::DeviceIntent";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceIntent_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DeviceIntent_g_tc_busbarPolicy_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_busbarPolicy)),NULL);

    static DDS_TypeCode_Member tms_DeviceIntent_g_tc_members[5]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"battleShort",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priority",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"busbarPolicy",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"rateLimit",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceIntent_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceIntent", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_DeviceIntent_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceIntent*/

    if (is_initialized) {
        return &tms_DeviceIntent_g_tc;
    }

    tms_DeviceIntent_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DeviceIntent_g_tc_busbarPolicy_sequence._data._typeCode = (RTICdrTypeCode *)tms_BusbarLoadPolicy_get_typecode();
    tms_DeviceIntent_g_tc_busbarPolicy_sequence._data._sampleAccessInfo = tms_BusbarLoadPolicy_get_sample_seq_access_info();
    tms_DeviceIntent_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DeviceIntent_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_DeviceIntent_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_PriorityValue_get_typecode();
    tms_DeviceIntent_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_DeviceIntent_g_tc_busbarPolicy_sequence;
    tms_DeviceIntent_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_DeviceIntent_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_DeviceIntent_g_tc_members[1]._annotations._defaultValue._u.boolean_value = 0;

    tms_DeviceIntent_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_DeviceIntent_g_tc_members[2]._annotations._defaultValue._u.long_value = 0;
    tms_DeviceIntent_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_DeviceIntent_g_tc_members[2]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_DeviceIntent_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_DeviceIntent_g_tc_members[2]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_DeviceIntent_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_DeviceIntent_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_DeviceIntent_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_DeviceIntent_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_DeviceIntent_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_DeviceIntent_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_DeviceIntent_g_tc._data._sampleAccessInfo =
    tms_DeviceIntent_get_sample_access_info();
    tms_DeviceIntent_g_tc._data._typePlugin =
    tms_DeviceIntent_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceIntent_g_tc;
}

#define TSeq tms_DeviceIntentSeq
#define T tms_DeviceIntent
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceIntent_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceIntent_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceIntentSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceIntentSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceIntent_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceIntent_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DeviceIntent *sample;

    static RTIXCdrMemberAccessInfo tms_DeviceIntent_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceIntent_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceIntent_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DeviceIntent);
    if (sample == NULL) {
        return NULL;
    }

    tms_DeviceIntent_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DeviceIntent_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->battleShort - (char *)sample);

    tms_DeviceIntent_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priority - (char *)sample);

    tms_DeviceIntent_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->busbarPolicy - (char *)sample);

    tms_DeviceIntent_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->rateLimit - (char *)sample);

    tms_DeviceIntent_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceIntent_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceIntent);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceIntent_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceIntent_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceIntent_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceIntent_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceIntent_get_member_value_pointer;

    tms_DeviceIntent_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceIntent_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceIntent_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceIntent_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceIntent_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceIntent_finalize_w_return,
        NULL
    };

    return &tms_DeviceIntent_g_typePlugin;
}
#endif

RTIBool tms_DeviceIntent_initialize(
    tms_DeviceIntent* sample) {
    return tms_DeviceIntent_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DeviceIntent_initialize_ex(
    tms_DeviceIntent* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceIntent_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceIntent_initialize_w_params(
    tms_DeviceIntent* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->battleShort = 0;

    sample->priority = 0;

    if (allocParams->allocate_memory) {
        if(!tms_BusbarLoadPolicySeq_initialize(&sample->busbarPolicy )){
            return RTI_FALSE;
        };
        if(!tms_BusbarLoadPolicySeq_set_element_allocation_params(&sample->busbarPolicy ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_BusbarLoadPolicySeq_set_absolute_maximum(&sample->busbarPolicy , ((tms_MAXLEN_busbarPolicy)))){
            return RTI_FALSE;
        }
        if (!tms_BusbarLoadPolicySeq_set_maximum(&sample->busbarPolicy, ((tms_MAXLEN_busbarPolicy)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_BusbarLoadPolicySeq_set_length(&sample->busbarPolicy, 0)){
            return RTI_FALSE;
        }    
    }

    sample->rateLimit = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_DeviceIntent_finalize_w_return(
    tms_DeviceIntent* sample)
{
    tms_DeviceIntent_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DeviceIntent_finalize(
    tms_DeviceIntent* sample)
{

    tms_DeviceIntent_finalize_ex(sample,RTI_TRUE);
}

void tms_DeviceIntent_finalize_ex(
    tms_DeviceIntent* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceIntent_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceIntent_finalize_w_params(
    tms_DeviceIntent* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_BusbarLoadPolicySeq_set_element_deallocation_params(
        &sample->busbarPolicy,deallocParams)){
        return; 
    }
    if(!tms_BusbarLoadPolicySeq_finalize(&sample->busbarPolicy)){
        return;
    }

}

void tms_DeviceIntent_finalize_optional_members(
    tms_DeviceIntent* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceIntent_copy(
    tms_DeviceIntent* dst,
    const tms_DeviceIntent* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyBoolean (
            &dst->battleShort, &src->battleShort)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyLong (
            &dst->priority, &src->priority)) { 
            return RTI_FALSE;
        }
        if (!tms_BusbarLoadPolicySeq_copy(&dst->busbarPolicy ,
        &src->busbarPolicy )) {
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->rateLimit, &src->rateLimit)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceIntent' sequence class.
*/
#define T tms_DeviceIntent
#define TSeq tms_DeviceIntentSeq

#define T_initialize_w_params tms_DeviceIntent_initialize_w_params

#define T_finalize_w_params   tms_DeviceIntent_finalize_w_params
#define T_copy       tms_DeviceIntent_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerPortIntentTYPENAME = "tms::PowerPortIntent";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortIntent_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_PowerPortIntent_g_tc_portPolicy_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_portPolicy)),NULL);

    static DDS_TypeCode_Member tms_PowerPortIntent_g_tc_members[5]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"portNumber",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priority",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"portPolicy",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"localPriority",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerPortIntent_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerPortIntent", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_PowerPortIntent_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerPortIntent*/

    if (is_initialized) {
        return &tms_PowerPortIntent_g_tc;
    }

    tms_PowerPortIntent_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortIntent_g_tc_portPolicy_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortLoadPolicy_get_typecode();
    tms_PowerPortIntent_g_tc_portPolicy_sequence._data._sampleAccessInfo = tms_PowerPortLoadPolicy_get_sample_seq_access_info();
    tms_PowerPortIntent_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_PowerPortIntent_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_PowerPortIntent_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_PriorityValue_get_typecode();
    tms_PowerPortIntent_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_PowerPortIntent_g_tc_portPolicy_sequence;
    tms_PowerPortIntent_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriority_get_typecode();

    /* Initialize the values for member annotations. */

    tms_PowerPortIntent_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortIntent_g_tc_members[1]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortIntent_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortIntent_g_tc_members[1]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortIntent_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortIntent_g_tc_members[1]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortIntent_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_PowerPortIntent_g_tc_members[2]._annotations._defaultValue._u.long_value = 0;
    tms_PowerPortIntent_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_PowerPortIntent_g_tc_members[2]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_PowerPortIntent_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_PowerPortIntent_g_tc_members[2]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_PowerPortIntent_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortIntent_g_tc_members[4]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortIntent_g_tc._data._sampleAccessInfo =
    tms_PowerPortIntent_get_sample_access_info();
    tms_PowerPortIntent_g_tc._data._typePlugin =
    tms_PowerPortIntent_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortIntent_g_tc;
}

#define TSeq tms_PowerPortIntentSeq
#define T tms_PowerPortIntent
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortIntent_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortIntent_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortIntentSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortIntentSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortIntent_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortIntent_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerPortIntent *sample;

    static RTIXCdrMemberAccessInfo tms_PowerPortIntent_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortIntent_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortIntent_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerPortIntent);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerPortIntent_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_PowerPortIntent_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerPortIntent_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priority - (char *)sample);

    tms_PowerPortIntent_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portPolicy - (char *)sample);

    tms_PowerPortIntent_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->localPriority - (char *)sample);

    tms_PowerPortIntent_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortIntent_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortIntent);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortIntent_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortIntent_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortIntent_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortIntent_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortIntent_get_member_value_pointer;

    tms_PowerPortIntent_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortIntent_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortIntent_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortIntent_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortIntent_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortIntent_finalize_w_return,
        NULL
    };

    return &tms_PowerPortIntent_g_typePlugin;
}
#endif

RTIBool tms_PowerPortIntent_initialize(
    tms_PowerPortIntent* sample) {
    return tms_PowerPortIntent_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortIntent_initialize_ex(
    tms_PowerPortIntent* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortIntent_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortIntent_initialize_w_params(
    tms_PowerPortIntent* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    sample->priority = 0;

    if (allocParams->allocate_memory) {
        if(!tms_PowerPortLoadPolicySeq_initialize(&sample->portPolicy )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortLoadPolicySeq_set_element_allocation_params(&sample->portPolicy ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortLoadPolicySeq_set_absolute_maximum(&sample->portPolicy , ((tms_MAXLEN_portPolicy)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortLoadPolicySeq_set_maximum(&sample->portPolicy, ((tms_MAXLEN_portPolicy)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortLoadPolicySeq_set_length(&sample->portPolicy, 0)){
            return RTI_FALSE;
        }    
    }
    sample->localPriority = LPPP_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_PowerPortIntent_finalize_w_return(
    tms_PowerPortIntent* sample)
{
    tms_PowerPortIntent_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortIntent_finalize(
    tms_PowerPortIntent* sample)
{

    tms_PowerPortIntent_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortIntent_finalize_ex(
    tms_PowerPortIntent* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortIntent_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortIntent_finalize_w_params(
    tms_PowerPortIntent* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_PowerPortLoadPolicySeq_set_element_deallocation_params(
        &sample->portPolicy,deallocParams)){
        return; 
    }
    if(!tms_PowerPortLoadPolicySeq_finalize(&sample->portPolicy)){
        return;
    }

    tms_LocalPowerPortPriority_finalize_w_params(&sample->localPriority,deallocParams);

}

void tms_PowerPortIntent_finalize_optional_members(
    tms_PowerPortIntent* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortIntent_copy(
    tms_PowerPortIntent* dst,
    const tms_PowerPortIntent* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyLong (
            &dst->priority, &src->priority)) { 
            return RTI_FALSE;
        }
        if (!tms_PowerPortLoadPolicySeq_copy(&dst->portPolicy ,
        &src->portPolicy )) {
            return RTI_FALSE;
        }
        if (!tms_LocalPowerPortPriority_copy(
            &dst->localPriority,(const tms_LocalPowerPortPriority*)&src->localPriority)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortIntent' sequence class.
*/
#define T tms_PowerPortIntent
#define TSeq tms_PowerPortIntentSeq

#define T_initialize_w_params tms_PowerPortIntent_initialize_w_params

#define T_finalize_w_params   tms_PowerPortIntent_finalize_w_params
#define T_copy       tms_PowerPortIntent_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_OperatorIntentTypeTYPENAME = "tms::OperatorIntentType";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_OperatorIntentType_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_OperatorIntentType_g_tc_members[2]=
    {

        {
            (char *)"OIT_DEFAULT_INTENT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            OIT_DEFAULT_INTENT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"OIT_OPERATOR_DEFINED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            OIT_OPERATOR_DEFINED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_OperatorIntentType_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::OperatorIntentType", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_OperatorIntentType_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_OperatorIntentType*/

    if (is_initialized) {
        return &tms_OperatorIntentType_g_tc;
    }

    tms_OperatorIntentType_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_OperatorIntentType_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_OperatorIntentType_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_OperatorIntentType_g_tc._data._sampleAccessInfo =
    tms_OperatorIntentType_get_sample_access_info();
    tms_OperatorIntentType_g_tc._data._typePlugin =
    tms_OperatorIntentType_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_OperatorIntentType_g_tc;
}

#define TSeq tms_OperatorIntentTypeSeq
#define T tms_OperatorIntentType
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_OperatorIntentType_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_OperatorIntentType_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_OperatorIntentTypeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_OperatorIntentTypeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_OperatorIntentType_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_OperatorIntentType_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_OperatorIntentType_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_OperatorIntentType_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntentType_g_sampleAccessInfo;
    }

    tms_OperatorIntentType_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_OperatorIntentType_g_sampleAccessInfo.memberAccessInfos = 
    tms_OperatorIntentType_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_OperatorIntentType);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_OperatorIntentType_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_OperatorIntentType_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_OperatorIntentType_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_OperatorIntentType_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_OperatorIntentType_get_member_value_pointer;

    tms_OperatorIntentType_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntentType_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_OperatorIntentType_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_OperatorIntentType_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_OperatorIntentType_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_OperatorIntentType_finalize_w_return,
        NULL
    };

    return &tms_OperatorIntentType_g_typePlugin;
}
#endif

RTIBool tms_OperatorIntentType_initialize(
    tms_OperatorIntentType* sample) {
    *sample = OIT_DEFAULT_INTENT;
    return RTI_TRUE;
}

RTIBool tms_OperatorIntentType_initialize_ex(
    tms_OperatorIntentType* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_OperatorIntentType_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_OperatorIntentType_initialize_w_params(
    tms_OperatorIntentType* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = OIT_DEFAULT_INTENT;
    return RTI_TRUE;
}

RTIBool tms_OperatorIntentType_finalize_w_return(
    tms_OperatorIntentType* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_OperatorIntentType_finalize(
    tms_OperatorIntentType* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_OperatorIntentType_finalize_ex(
    tms_OperatorIntentType* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_OperatorIntentType_finalize_w_params(
        sample,&deallocParams);
}

void tms_OperatorIntentType_finalize_w_params(
    tms_OperatorIntentType* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_OperatorIntentType_finalize_optional_members(
    tms_OperatorIntentType* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_OperatorIntentType_copy(
    tms_OperatorIntentType* dst,
    const tms_OperatorIntentType* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_OperatorIntentType' sequence class.
*/
#define T tms_OperatorIntentType
#define TSeq tms_OperatorIntentTypeSeq

#define T_initialize_w_params tms_OperatorIntentType_initialize_w_params

#define T_finalize_w_params   tms_OperatorIntentType_finalize_w_params
#define T_copy       tms_OperatorIntentType_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_OperatorIntentTYPENAME = "tms::OperatorIntent";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_OperatorIntent_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_OperatorIntent_g_tc_devices_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_devices)),NULL);
    static DDS_TypeCode tms_OperatorIntent_g_tc_powerPorts_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_powerPorts)),NULL);

    static DDS_TypeCode_Member tms_OperatorIntent_g_tc_members[5]=
    {

        {
            (char *)"originator",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"intentType",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"microgrid",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"devices",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"powerPorts",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_OperatorIntent_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::OperatorIntent", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_OperatorIntent_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_OperatorIntent*/

    if (is_initialized) {
        return &tms_OperatorIntent_g_tc;
    }

    tms_OperatorIntent_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_OperatorIntent_g_tc_devices_sequence._data._typeCode = (RTICdrTypeCode *)tms_DeviceIntent_get_typecode();
    tms_OperatorIntent_g_tc_devices_sequence._data._sampleAccessInfo = tms_DeviceIntent_get_sample_seq_access_info();
    tms_OperatorIntent_g_tc_powerPorts_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortIntent_get_typecode();
    tms_OperatorIntent_g_tc_powerPorts_sequence._data._sampleAccessInfo = tms_PowerPortIntent_get_sample_seq_access_info();
    tms_OperatorIntent_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_OperatorIntent_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_OperatorIntentType_get_typecode();
    tms_OperatorIntent_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_MicrogridIntent_get_typecode();
    tms_OperatorIntent_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_OperatorIntent_g_tc_devices_sequence;
    tms_OperatorIntent_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)& tms_OperatorIntent_g_tc_powerPorts_sequence;

    /* Initialize the values for member annotations. */

    tms_OperatorIntent_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_OperatorIntent_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_OperatorIntent_g_tc._data._sampleAccessInfo =
    tms_OperatorIntent_get_sample_access_info();
    tms_OperatorIntent_g_tc._data._typePlugin =
    tms_OperatorIntent_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_OperatorIntent_g_tc;
}

#define TSeq tms_OperatorIntentSeq
#define T tms_OperatorIntent
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_OperatorIntent_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_OperatorIntent_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_OperatorIntentSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_OperatorIntentSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_OperatorIntent_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_OperatorIntent_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_OperatorIntent *sample;

    static RTIXCdrMemberAccessInfo tms_OperatorIntent_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_OperatorIntent_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntent_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_OperatorIntent);
    if (sample == NULL) {
        return NULL;
    }

    tms_OperatorIntent_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->originator - (char *)sample);

    tms_OperatorIntent_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->intentType - (char *)sample);

    tms_OperatorIntent_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->microgrid - (char *)sample);

    tms_OperatorIntent_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->devices - (char *)sample);

    tms_OperatorIntent_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->powerPorts - (char *)sample);

    tms_OperatorIntent_g_sampleAccessInfo.memberAccessInfos = 
    tms_OperatorIntent_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_OperatorIntent);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_OperatorIntent_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_OperatorIntent_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_OperatorIntent_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_OperatorIntent_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_OperatorIntent_get_member_value_pointer;

    tms_OperatorIntent_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntent_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_OperatorIntent_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_OperatorIntent_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_OperatorIntent_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_OperatorIntent_finalize_w_return,
        NULL
    };

    return &tms_OperatorIntent_g_typePlugin;
}
#endif

RTIBool tms_OperatorIntent_initialize(
    tms_OperatorIntent* sample) {
    return tms_OperatorIntent_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_OperatorIntent_initialize_ex(
    tms_OperatorIntent* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_OperatorIntent_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_OperatorIntent_initialize_w_params(
    tms_OperatorIntent* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->originator,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->intentType = OIT_DEFAULT_INTENT;
    if (!tms_MicrogridIntent_initialize_w_params(&sample->microgrid,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_DeviceIntentSeq_initialize(&sample->devices )){
            return RTI_FALSE;
        };
        if(!tms_DeviceIntentSeq_set_element_allocation_params(&sample->devices ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_DeviceIntentSeq_set_absolute_maximum(&sample->devices , ((tms_MAXLEN_devices)))){
            return RTI_FALSE;
        }
        if (!tms_DeviceIntentSeq_set_maximum(&sample->devices, ((tms_MAXLEN_devices)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_DeviceIntentSeq_set_length(&sample->devices, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerPortIntentSeq_initialize(&sample->powerPorts )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortIntentSeq_set_element_allocation_params(&sample->powerPorts ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortIntentSeq_set_absolute_maximum(&sample->powerPorts , ((tms_MAXLEN_powerPorts)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortIntentSeq_set_maximum(&sample->powerPorts, ((tms_MAXLEN_powerPorts)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortIntentSeq_set_length(&sample->powerPorts, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_OperatorIntent_finalize_w_return(
    tms_OperatorIntent* sample)
{
    tms_OperatorIntent_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_OperatorIntent_finalize(
    tms_OperatorIntent* sample)
{

    tms_OperatorIntent_finalize_ex(sample,RTI_TRUE);
}

void tms_OperatorIntent_finalize_ex(
    tms_OperatorIntent* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_OperatorIntent_finalize_w_params(
        sample,&deallocParams);
}

void tms_OperatorIntent_finalize_w_params(
    tms_OperatorIntent* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->originator,deallocParams);

    tms_OperatorIntentType_finalize_w_params(&sample->intentType,deallocParams);

    tms_MicrogridIntent_finalize_w_params(&sample->microgrid,deallocParams);

    if(!tms_DeviceIntentSeq_set_element_deallocation_params(
        &sample->devices,deallocParams)){
        return; 
    }
    if(!tms_DeviceIntentSeq_finalize(&sample->devices)){
        return;
    }

    if(!tms_PowerPortIntentSeq_set_element_deallocation_params(
        &sample->powerPorts,deallocParams)){
        return; 
    }
    if(!tms_PowerPortIntentSeq_finalize(&sample->powerPorts)){
        return;
    }

}

void tms_OperatorIntent_finalize_optional_members(
    tms_OperatorIntent* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_OperatorIntent_copy(
    tms_OperatorIntent* dst,
    const tms_OperatorIntent* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->originator,(const tms_Fingerprint*)&src->originator)) {
            return RTI_FALSE;
        } 
        if (!tms_OperatorIntentType_copy(
            &dst->intentType,(const tms_OperatorIntentType*)&src->intentType)) {
            return RTI_FALSE;
        } 
        if (!tms_MicrogridIntent_copy(
            &dst->microgrid,(const tms_MicrogridIntent*)&src->microgrid)) {
            return RTI_FALSE;
        } 
        if (!tms_DeviceIntentSeq_copy(&dst->devices ,
        &src->devices )) {
            return RTI_FALSE;
        }
        if (!tms_PowerPortIntentSeq_copy(&dst->powerPorts ,
        &src->powerPorts )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_OperatorIntent' sequence class.
*/
#define T tms_OperatorIntent
#define TSeq tms_OperatorIntentSeq

#define T_initialize_w_params tms_OperatorIntent_initialize_w_params

#define T_finalize_w_params   tms_OperatorIntent_finalize_w_params
#define T_copy       tms_OperatorIntent_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_OperatorIntentRequestTYPENAME = "tms::OperatorIntentRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_OperatorIntentRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_OperatorIntentRequest_g_tc_members[2]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"desiredOperatorIntent",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_OperatorIntentRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::OperatorIntentRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_OperatorIntentRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_OperatorIntentRequest*/

    if (is_initialized) {
        return &tms_OperatorIntentRequest_g_tc;
    }

    tms_OperatorIntentRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_OperatorIntentRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_OperatorIntentRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_OperatorIntent_get_typecode();

    /* Initialize the values for member annotations. */

    tms_OperatorIntentRequest_g_tc._data._sampleAccessInfo =
    tms_OperatorIntentRequest_get_sample_access_info();
    tms_OperatorIntentRequest_g_tc._data._typePlugin =
    tms_OperatorIntentRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_OperatorIntentRequest_g_tc;
}

#define TSeq tms_OperatorIntentRequestSeq
#define T tms_OperatorIntentRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_OperatorIntentRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_OperatorIntentRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_OperatorIntentRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_OperatorIntentRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_OperatorIntentRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_OperatorIntentRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_OperatorIntentRequest *sample;

    static RTIXCdrMemberAccessInfo tms_OperatorIntentRequest_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_OperatorIntentRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntentRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_OperatorIntentRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_OperatorIntentRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_OperatorIntentRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->desiredOperatorIntent - (char *)sample);

    tms_OperatorIntentRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_OperatorIntentRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_OperatorIntentRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_OperatorIntentRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_OperatorIntentRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_OperatorIntentRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_OperatorIntentRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_OperatorIntentRequest_get_member_value_pointer;

    tms_OperatorIntentRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntentRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_OperatorIntentRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_OperatorIntentRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_OperatorIntentRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_OperatorIntentRequest_finalize_w_return,
        NULL
    };

    return &tms_OperatorIntentRequest_g_typePlugin;
}
#endif

RTIBool tms_OperatorIntentRequest_initialize(
    tms_OperatorIntentRequest* sample) {
    return tms_OperatorIntentRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_OperatorIntentRequest_initialize_ex(
    tms_OperatorIntentRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_OperatorIntentRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_OperatorIntentRequest_initialize_w_params(
    tms_OperatorIntentRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_OperatorIntent_initialize_w_params(&sample->desiredOperatorIntent,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_OperatorIntentRequest_finalize_w_return(
    tms_OperatorIntentRequest* sample)
{
    tms_OperatorIntentRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_OperatorIntentRequest_finalize(
    tms_OperatorIntentRequest* sample)
{

    tms_OperatorIntentRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_OperatorIntentRequest_finalize_ex(
    tms_OperatorIntentRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_OperatorIntentRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_OperatorIntentRequest_finalize_w_params(
    tms_OperatorIntentRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_OperatorIntent_finalize_w_params(&sample->desiredOperatorIntent,deallocParams);

}

void tms_OperatorIntentRequest_finalize_optional_members(
    tms_OperatorIntentRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_OperatorIntentRequest_copy(
    tms_OperatorIntentRequest* dst,
    const tms_OperatorIntentRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_OperatorIntent_copy(
            &dst->desiredOperatorIntent,(const tms_OperatorIntent*)&src->desiredOperatorIntent)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_OperatorIntentRequest' sequence class.
*/
#define T tms_OperatorIntentRequest
#define TSeq tms_OperatorIntentRequestSeq

#define T_initialize_w_params tms_OperatorIntentRequest_initialize_w_params

#define T_finalize_w_params   tms_OperatorIntentRequest_finalize_w_params
#define T_copy       tms_OperatorIntentRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_OperatorIntentStateTYPENAME = "tms::OperatorIntentState";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_OperatorIntentState_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_OperatorIntentState_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"activeOperatorIntent",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_OperatorIntentState_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::OperatorIntentState", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_OperatorIntentState_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_OperatorIntentState*/

    if (is_initialized) {
        return &tms_OperatorIntentState_g_tc;
    }

    tms_OperatorIntentState_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_OperatorIntentState_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_OperatorIntentState_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_OperatorIntent_get_typecode();

    /* Initialize the values for member annotations. */

    tms_OperatorIntentState_g_tc._data._sampleAccessInfo =
    tms_OperatorIntentState_get_sample_access_info();
    tms_OperatorIntentState_g_tc._data._typePlugin =
    tms_OperatorIntentState_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_OperatorIntentState_g_tc;
}

#define TSeq tms_OperatorIntentStateSeq
#define T tms_OperatorIntentState
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_OperatorIntentState_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_OperatorIntentState_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_OperatorIntentStateSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_OperatorIntentStateSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_OperatorIntentState_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_OperatorIntentState_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_OperatorIntentState *sample;

    static RTIXCdrMemberAccessInfo tms_OperatorIntentState_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_OperatorIntentState_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntentState_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_OperatorIntentState);
    if (sample == NULL) {
        return NULL;
    }

    tms_OperatorIntentState_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_OperatorIntentState_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->activeOperatorIntent - (char *)sample);

    tms_OperatorIntentState_g_sampleAccessInfo.memberAccessInfos = 
    tms_OperatorIntentState_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_OperatorIntentState);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_OperatorIntentState_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_OperatorIntentState_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_OperatorIntentState_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_OperatorIntentState_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_OperatorIntentState_get_member_value_pointer;

    tms_OperatorIntentState_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_OperatorIntentState_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_OperatorIntentState_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_OperatorIntentState_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_OperatorIntentState_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_OperatorIntentState_finalize_w_return,
        NULL
    };

    return &tms_OperatorIntentState_g_typePlugin;
}
#endif

RTIBool tms_OperatorIntentState_initialize(
    tms_OperatorIntentState* sample) {
    return tms_OperatorIntentState_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_OperatorIntentState_initialize_ex(
    tms_OperatorIntentState* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_OperatorIntentState_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_OperatorIntentState_initialize_w_params(
    tms_OperatorIntentState* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_OperatorIntent_initialize_w_params(&sample->activeOperatorIntent,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_OperatorIntentState_finalize_w_return(
    tms_OperatorIntentState* sample)
{
    tms_OperatorIntentState_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_OperatorIntentState_finalize(
    tms_OperatorIntentState* sample)
{

    tms_OperatorIntentState_finalize_ex(sample,RTI_TRUE);
}

void tms_OperatorIntentState_finalize_ex(
    tms_OperatorIntentState* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_OperatorIntentState_finalize_w_params(
        sample,&deallocParams);
}

void tms_OperatorIntentState_finalize_w_params(
    tms_OperatorIntentState* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_OperatorIntent_finalize_w_params(&sample->activeOperatorIntent,deallocParams);

}

void tms_OperatorIntentState_finalize_optional_members(
    tms_OperatorIntentState* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_OperatorIntentState_copy(
    tms_OperatorIntentState* dst,
    const tms_OperatorIntentState* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_OperatorIntent_copy(
            &dst->activeOperatorIntent,(const tms_OperatorIntent*)&src->activeOperatorIntent)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_OperatorIntentState' sequence class.
*/
#define T tms_OperatorIntentState
#define TSeq tms_OperatorIntentStateSeq

#define T_initialize_w_params tms_OperatorIntentState_initialize_w_params

#define T_finalize_w_params   tms_OperatorIntentState_finalize_w_params
#define T_copy       tms_OperatorIntentState_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadPolicyRequestTYPENAME = "tms::LoadPolicyRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadPolicyRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_LoadPolicyRequest_g_tc_portPriorities_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_portPriorities)),NULL);
    static DDS_TypeCode tms_LoadPolicyRequest_g_tc_portPolicies_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_portPolicies)),NULL);
    static DDS_TypeCode tms_LoadPolicyRequest_g_tc_busbarPolicy_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_busbarPolicy)),NULL);

    static DDS_TypeCode_Member tms_LoadPolicyRequest_g_tc_members[7]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"portPriorities",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"portPolicies",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"busbarPolicy",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"rateLimit",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadPolicyRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadPolicyRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            7, /* Number of members */
            tms_LoadPolicyRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadPolicyRequest*/

    if (is_initialized) {
        return &tms_LoadPolicyRequest_g_tc;
    }

    tms_LoadPolicyRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadPolicyRequest_g_tc_portPriorities_sequence._data._typeCode = (RTICdrTypeCode *)tms_LocalPowerPortPriorityAssignment_get_typecode();
    tms_LoadPolicyRequest_g_tc_portPriorities_sequence._data._sampleAccessInfo = tms_LocalPowerPortPriorityAssignment_get_sample_seq_access_info();
    tms_LoadPolicyRequest_g_tc_portPolicies_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortLoadPolicy_get_typecode();
    tms_LoadPolicyRequest_g_tc_portPolicies_sequence._data._sampleAccessInfo = tms_PowerPortLoadPolicy_get_sample_seq_access_info();
    tms_LoadPolicyRequest_g_tc_busbarPolicy_sequence._data._typeCode = (RTICdrTypeCode *)tms_BusbarLoadPolicy_get_typecode();
    tms_LoadPolicyRequest_g_tc_busbarPolicy_sequence._data._sampleAccessInfo = tms_BusbarLoadPolicy_get_sample_seq_access_info();
    tms_LoadPolicyRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_LoadPolicyRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_LoadPolicyRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_LoadPolicyRequest_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)& tms_LoadPolicyRequest_g_tc_portPriorities_sequence;
    tms_LoadPolicyRequest_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)& tms_LoadPolicyRequest_g_tc_portPolicies_sequence;
    tms_LoadPolicyRequest_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)& tms_LoadPolicyRequest_g_tc_busbarPolicy_sequence;
    tms_LoadPolicyRequest_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_LoadPolicyRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadPolicyRequest_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_LoadPolicyRequest_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadPolicyRequest_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_LoadPolicyRequest_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadPolicyRequest_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_LoadPolicyRequest_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadPolicyRequest_g_tc_members[6]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadPolicyRequest_g_tc_members[6]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadPolicyRequest_g_tc_members[6]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadPolicyRequest_g_tc_members[6]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadPolicyRequest_g_tc_members[6]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadPolicyRequest_g_tc._data._sampleAccessInfo =
    tms_LoadPolicyRequest_get_sample_access_info();
    tms_LoadPolicyRequest_g_tc._data._typePlugin =
    tms_LoadPolicyRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadPolicyRequest_g_tc;
}

#define TSeq tms_LoadPolicyRequestSeq
#define T tms_LoadPolicyRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadPolicyRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadPolicyRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadPolicyRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadPolicyRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadPolicyRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadPolicyRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadPolicyRequest *sample;

    static RTIXCdrMemberAccessInfo tms_LoadPolicyRequest_g_memberAccessInfos[7] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadPolicyRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadPolicyRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadPolicyRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadPolicyRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_LoadPolicyRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_LoadPolicyRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_LoadPolicyRequest_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portPriorities - (char *)sample);

    tms_LoadPolicyRequest_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portPolicies - (char *)sample);

    tms_LoadPolicyRequest_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->busbarPolicy - (char *)sample);

    tms_LoadPolicyRequest_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->rateLimit - (char *)sample);

    tms_LoadPolicyRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadPolicyRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadPolicyRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadPolicyRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadPolicyRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadPolicyRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadPolicyRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadPolicyRequest_get_member_value_pointer;

    tms_LoadPolicyRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadPolicyRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadPolicyRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadPolicyRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadPolicyRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadPolicyRequest_finalize_w_return,
        NULL
    };

    return &tms_LoadPolicyRequest_g_typePlugin;
}
#endif

RTIBool tms_LoadPolicyRequest_initialize(
    tms_LoadPolicyRequest* sample) {
    return tms_LoadPolicyRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadPolicyRequest_initialize_ex(
    tms_LoadPolicyRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadPolicyRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadPolicyRequest_initialize_w_params(
    tms_LoadPolicyRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    if (allocParams->allocate_memory) {
        if(!tms_LocalPowerPortPriorityAssignmentSeq_initialize(&sample->portPriorities )){
            return RTI_FALSE;
        };
        if(!tms_LocalPowerPortPriorityAssignmentSeq_set_element_allocation_params(&sample->portPriorities ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_LocalPowerPortPriorityAssignmentSeq_set_absolute_maximum(&sample->portPriorities , ((tms_MAXLEN_portPriorities)))){
            return RTI_FALSE;
        }
        if (!tms_LocalPowerPortPriorityAssignmentSeq_set_maximum(&sample->portPriorities, ((tms_MAXLEN_portPriorities)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_LocalPowerPortPriorityAssignmentSeq_set_length(&sample->portPriorities, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerPortLoadPolicySeq_initialize(&sample->portPolicies )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortLoadPolicySeq_set_element_allocation_params(&sample->portPolicies ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortLoadPolicySeq_set_absolute_maximum(&sample->portPolicies , ((tms_MAXLEN_portPolicies)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortLoadPolicySeq_set_maximum(&sample->portPolicies, ((tms_MAXLEN_portPolicies)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortLoadPolicySeq_set_length(&sample->portPolicies, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_BusbarLoadPolicySeq_initialize(&sample->busbarPolicy )){
            return RTI_FALSE;
        };
        if(!tms_BusbarLoadPolicySeq_set_element_allocation_params(&sample->busbarPolicy ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_BusbarLoadPolicySeq_set_absolute_maximum(&sample->busbarPolicy , ((tms_MAXLEN_busbarPolicy)))){
            return RTI_FALSE;
        }
        if (!tms_BusbarLoadPolicySeq_set_maximum(&sample->busbarPolicy, ((tms_MAXLEN_busbarPolicy)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_BusbarLoadPolicySeq_set_length(&sample->busbarPolicy, 0)){
            return RTI_FALSE;
        }    
    }

    sample->rateLimit = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_LoadPolicyRequest_finalize_w_return(
    tms_LoadPolicyRequest* sample)
{
    tms_LoadPolicyRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadPolicyRequest_finalize(
    tms_LoadPolicyRequest* sample)
{

    tms_LoadPolicyRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadPolicyRequest_finalize_ex(
    tms_LoadPolicyRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadPolicyRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadPolicyRequest_finalize_w_params(
    tms_LoadPolicyRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_LocalPowerPortPriorityAssignmentSeq_set_element_deallocation_params(
        &sample->portPriorities,deallocParams)){
        return; 
    }
    if(!tms_LocalPowerPortPriorityAssignmentSeq_finalize(&sample->portPriorities)){
        return;
    }

    if(!tms_PowerPortLoadPolicySeq_set_element_deallocation_params(
        &sample->portPolicies,deallocParams)){
        return; 
    }
    if(!tms_PowerPortLoadPolicySeq_finalize(&sample->portPolicies)){
        return;
    }

    if(!tms_BusbarLoadPolicySeq_set_element_deallocation_params(
        &sample->busbarPolicy,deallocParams)){
        return; 
    }
    if(!tms_BusbarLoadPolicySeq_finalize(&sample->busbarPolicy)){
        return;
    }

}

void tms_LoadPolicyRequest_finalize_optional_members(
    tms_LoadPolicyRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadPolicyRequest_copy(
    tms_LoadPolicyRequest* dst,
    const tms_LoadPolicyRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!tms_LocalPowerPortPriorityAssignmentSeq_copy(&dst->portPriorities ,
        &src->portPriorities )) {
            return RTI_FALSE;
        }
        if (!tms_PowerPortLoadPolicySeq_copy(&dst->portPolicies ,
        &src->portPolicies )) {
            return RTI_FALSE;
        }
        if (!tms_BusbarLoadPolicySeq_copy(&dst->busbarPolicy ,
        &src->busbarPolicy )) {
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->rateLimit, &src->rateLimit)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadPolicyRequest' sequence class.
*/
#define T tms_LoadPolicyRequest
#define TSeq tms_LoadPolicyRequestSeq

#define T_initialize_w_params tms_LoadPolicyRequest_initialize_w_params

#define T_finalize_w_params   tms_LoadPolicyRequest_finalize_w_params
#define T_copy       tms_LoadPolicyRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadPolicyTYPENAME = "tms::LoadPolicy";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadPolicy_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadPolicy_g_tc_members[5]=
    {

        {
            (char *)"LP_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LP_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LP_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LP_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LP_OVER_CURRENT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LP_OVER_CURRENT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LP_OVER_ENERGY",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LP_OVER_ENERGY, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LP_UNDER_FREQUENCY",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LP_UNDER_FREQUENCY, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadPolicy_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadPolicy", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_LoadPolicy_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadPolicy*/

    if (is_initialized) {
        return &tms_LoadPolicy_g_tc;
    }

    tms_LoadPolicy_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_LoadPolicy_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_LoadPolicy_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_LoadPolicy_g_tc._data._sampleAccessInfo =
    tms_LoadPolicy_get_sample_access_info();
    tms_LoadPolicy_g_tc._data._typePlugin =
    tms_LoadPolicy_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadPolicy_g_tc;
}

#define TSeq tms_LoadPolicySeq
#define T tms_LoadPolicy
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadPolicy_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadPolicy_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadPolicySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadPolicySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadPolicy_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadPolicy_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_LoadPolicy_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadPolicy_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadPolicy_g_sampleAccessInfo;
    }

    tms_LoadPolicy_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_LoadPolicy_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadPolicy_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadPolicy);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadPolicy_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadPolicy_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadPolicy_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadPolicy_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadPolicy_get_member_value_pointer;

    tms_LoadPolicy_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadPolicy_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadPolicy_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadPolicy_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadPolicy_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadPolicy_finalize_w_return,
        NULL
    };

    return &tms_LoadPolicy_g_typePlugin;
}
#endif

RTIBool tms_LoadPolicy_initialize(
    tms_LoadPolicy* sample) {
    *sample = LP_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_LoadPolicy_initialize_ex(
    tms_LoadPolicy* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadPolicy_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadPolicy_initialize_w_params(
    tms_LoadPolicy* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = LP_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_LoadPolicy_finalize_w_return(
    tms_LoadPolicy* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_LoadPolicy_finalize(
    tms_LoadPolicy* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_LoadPolicy_finalize_ex(
    tms_LoadPolicy* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadPolicy_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadPolicy_finalize_w_params(
    tms_LoadPolicy* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_LoadPolicy_finalize_optional_members(
    tms_LoadPolicy* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadPolicy_copy(
    tms_LoadPolicy* dst,
    const tms_LoadPolicy* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadPolicy' sequence class.
*/
#define T tms_LoadPolicy
#define TSeq tms_LoadPolicySeq

#define T_initialize_w_params tms_LoadPolicy_initialize_w_params

#define T_finalize_w_params   tms_LoadPolicy_finalize_w_params
#define T_copy       tms_LoadPolicy_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerLineTYPENAME = "tms::PowerLine";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerLine_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerLine_g_tc_members[8]=
    {

        {
            (char *)"LINE_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LINE_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LINE_A",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_A, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LINE_B",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_B, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LINE_C",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_C, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LINE_N",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_N, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LINE_G",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_G, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LINE_MULTIPLE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LINE_MULTIPLE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerLine_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerLine", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            8, /* Number of members */
            tms_PowerLine_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerLine*/

    if (is_initialized) {
        return &tms_PowerLine_g_tc;
    }

    tms_PowerLine_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_PowerLine_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerLine_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_PowerLine_g_tc._data._sampleAccessInfo =
    tms_PowerLine_get_sample_access_info();
    tms_PowerLine_g_tc._data._typePlugin =
    tms_PowerLine_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerLine_g_tc;
}

#define TSeq tms_PowerLineSeq
#define T tms_PowerLine
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerLine_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerLine_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerLineSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerLineSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerLine_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerLine_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_PowerLine_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerLine_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerLine_g_sampleAccessInfo;
    }

    tms_PowerLine_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_PowerLine_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerLine_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerLine);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerLine_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerLine_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerLine_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerLine_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerLine_get_member_value_pointer;

    tms_PowerLine_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerLine_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerLine_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerLine_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerLine_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerLine_finalize_w_return,
        NULL
    };

    return &tms_PowerLine_g_typePlugin;
}
#endif

RTIBool tms_PowerLine_initialize(
    tms_PowerLine* sample) {
    *sample = LINE_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_PowerLine_initialize_ex(
    tms_PowerLine* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerLine_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerLine_initialize_w_params(
    tms_PowerLine* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = LINE_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_PowerLine_finalize_w_return(
    tms_PowerLine* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_PowerLine_finalize(
    tms_PowerLine* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_PowerLine_finalize_ex(
    tms_PowerLine* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerLine_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerLine_finalize_w_params(
    tms_PowerLine* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_PowerLine_finalize_optional_members(
    tms_PowerLine* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerLine_copy(
    tms_PowerLine* dst,
    const tms_PowerLine* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerLine' sequence class.
*/
#define T tms_PowerLine
#define TSeq tms_PowerLineSeq

#define T_initialize_w_params tms_PowerLine_initialize_w_params

#define T_finalize_w_params   tms_PowerLine_finalize_w_params
#define T_copy       tms_PowerLine_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadPolicyContinuityTYPENAME = "tms::LoadPolicyContinuity";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadPolicyContinuity_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadPolicyContinuity_g_tc_members[4]=
    {

        {
            (char *)"LPC_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPC_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPC_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPC_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPC_CONTINUOUS",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPC_CONTINUOUS, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"LPC_INTERRUPTED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            LPC_INTERRUPTED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadPolicyContinuity_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadPolicyContinuity", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_LoadPolicyContinuity_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadPolicyContinuity*/

    if (is_initialized) {
        return &tms_LoadPolicyContinuity_g_tc;
    }

    tms_LoadPolicyContinuity_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_LoadPolicyContinuity_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_LoadPolicyContinuity_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_LoadPolicyContinuity_g_tc._data._sampleAccessInfo =
    tms_LoadPolicyContinuity_get_sample_access_info();
    tms_LoadPolicyContinuity_g_tc._data._typePlugin =
    tms_LoadPolicyContinuity_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadPolicyContinuity_g_tc;
}

#define TSeq tms_LoadPolicyContinuitySeq
#define T tms_LoadPolicyContinuity
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadPolicyContinuity_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadPolicyContinuity_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadPolicyContinuitySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadPolicyContinuitySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadPolicyContinuity_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadPolicyContinuity_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_LoadPolicyContinuity_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadPolicyContinuity_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadPolicyContinuity_g_sampleAccessInfo;
    }

    tms_LoadPolicyContinuity_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_LoadPolicyContinuity_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadPolicyContinuity_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadPolicyContinuity);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadPolicyContinuity_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadPolicyContinuity_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadPolicyContinuity_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadPolicyContinuity_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadPolicyContinuity_get_member_value_pointer;

    tms_LoadPolicyContinuity_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadPolicyContinuity_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadPolicyContinuity_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadPolicyContinuity_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadPolicyContinuity_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadPolicyContinuity_finalize_w_return,
        NULL
    };

    return &tms_LoadPolicyContinuity_g_typePlugin;
}
#endif

RTIBool tms_LoadPolicyContinuity_initialize(
    tms_LoadPolicyContinuity* sample) {
    *sample = LPC_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_LoadPolicyContinuity_initialize_ex(
    tms_LoadPolicyContinuity* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadPolicyContinuity_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadPolicyContinuity_initialize_w_params(
    tms_LoadPolicyContinuity* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = LPC_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_LoadPolicyContinuity_finalize_w_return(
    tms_LoadPolicyContinuity* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_LoadPolicyContinuity_finalize(
    tms_LoadPolicyContinuity* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_LoadPolicyContinuity_finalize_ex(
    tms_LoadPolicyContinuity* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadPolicyContinuity_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadPolicyContinuity_finalize_w_params(
    tms_LoadPolicyContinuity* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_LoadPolicyContinuity_finalize_optional_members(
    tms_LoadPolicyContinuity* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadPolicyContinuity_copy(
    tms_LoadPolicyContinuity* dst,
    const tms_LoadPolicyContinuity* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadPolicyContinuity' sequence class.
*/
#define T tms_LoadPolicyContinuity
#define TSeq tms_LoadPolicyContinuitySeq

#define T_initialize_w_params tms_LoadPolicyContinuity_initialize_w_params

#define T_finalize_w_params   tms_LoadPolicyContinuity_finalize_w_params
#define T_copy       tms_LoadPolicyContinuity_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_PowerPortLoadPolicyReportTYPENAME = "tms::PowerPortLoadPolicyReport";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_PowerPortLoadPolicyReport_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_PowerPortLoadPolicyReport_g_tc_members[5]=
    {

        {
            (char *)"portNumber",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"type",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"line",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"continuity",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"time",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_PowerPortLoadPolicyReport_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::PowerPortLoadPolicyReport", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_PowerPortLoadPolicyReport_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_PowerPortLoadPolicyReport*/

    if (is_initialized) {
        return &tms_PowerPortLoadPolicyReport_g_tc;
    }

    tms_PowerPortLoadPolicyReport_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_PowerPortLoadPolicyReport_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_PowerPortNumber_get_typecode();
    tms_PowerPortLoadPolicyReport_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_LoadPolicy_get_typecode();
    tms_PowerPortLoadPolicyReport_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_PowerLine_get_typecode();
    tms_PowerPortLoadPolicyReport_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_LoadPolicyContinuity_get_typecode();
    tms_PowerPortLoadPolicyReport_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();

    /* Initialize the values for member annotations. */
    tms_PowerPortLoadPolicyReport_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortLoadPolicyReport_g_tc_members[0]._annotations._defaultValue._u.ulong_value = 0u;
    tms_PowerPortLoadPolicyReport_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortLoadPolicyReport_g_tc_members[0]._annotations._minValue._u.ulong_value = RTIXCdrUnsignedLong_MIN;
    tms_PowerPortLoadPolicyReport_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_ULONG;
    tms_PowerPortLoadPolicyReport_g_tc_members[0]._annotations._maxValue._u.ulong_value = RTIXCdrUnsignedLong_MAX;

    tms_PowerPortLoadPolicyReport_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortLoadPolicyReport_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortLoadPolicyReport_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortLoadPolicyReport_g_tc_members[2]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortLoadPolicyReport_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_PowerPortLoadPolicyReport_g_tc_members[3]._annotations._defaultValue._u.enumerated_value = 0;

    tms_PowerPortLoadPolicyReport_g_tc._data._sampleAccessInfo =
    tms_PowerPortLoadPolicyReport_get_sample_access_info();
    tms_PowerPortLoadPolicyReport_g_tc._data._typePlugin =
    tms_PowerPortLoadPolicyReport_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_PowerPortLoadPolicyReport_g_tc;
}

#define TSeq tms_PowerPortLoadPolicyReportSeq
#define T tms_PowerPortLoadPolicyReport
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_PowerPortLoadPolicyReport_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_PowerPortLoadPolicyReport_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_PowerPortLoadPolicyReportSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_PowerPortLoadPolicyReportSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_PowerPortLoadPolicyReport_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_PowerPortLoadPolicyReport_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_PowerPortLoadPolicyReport *sample;

    static RTIXCdrMemberAccessInfo tms_PowerPortLoadPolicyReport_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_PowerPortLoadPolicyReport_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_PowerPortLoadPolicyReport_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_PowerPortLoadPolicyReport);
    if (sample == NULL) {
        return NULL;
    }

    tms_PowerPortLoadPolicyReport_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->portNumber - (char *)sample);

    tms_PowerPortLoadPolicyReport_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->type - (char *)sample);

    tms_PowerPortLoadPolicyReport_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->line - (char *)sample);

    tms_PowerPortLoadPolicyReport_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->continuity - (char *)sample);

    tms_PowerPortLoadPolicyReport_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->time - (char *)sample);

    tms_PowerPortLoadPolicyReport_g_sampleAccessInfo.memberAccessInfos = 
    tms_PowerPortLoadPolicyReport_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_PowerPortLoadPolicyReport);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_PowerPortLoadPolicyReport_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_PowerPortLoadPolicyReport_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_PowerPortLoadPolicyReport_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_PowerPortLoadPolicyReport_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_PowerPortLoadPolicyReport_get_member_value_pointer;

    tms_PowerPortLoadPolicyReport_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_PowerPortLoadPolicyReport_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_PowerPortLoadPolicyReport_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_PowerPortLoadPolicyReport_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_PowerPortLoadPolicyReport_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_PowerPortLoadPolicyReport_finalize_w_return,
        NULL
    };

    return &tms_PowerPortLoadPolicyReport_g_typePlugin;
}
#endif

RTIBool tms_PowerPortLoadPolicyReport_initialize(
    tms_PowerPortLoadPolicyReport* sample) {
    return tms_PowerPortLoadPolicyReport_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_PowerPortLoadPolicyReport_initialize_ex(
    tms_PowerPortLoadPolicyReport* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_PowerPortLoadPolicyReport_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_PowerPortLoadPolicyReport_initialize_w_params(
    tms_PowerPortLoadPolicyReport* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->portNumber = 0u;

    sample->type = LP_UNINITIALIZED;
    sample->line = LINE_UNINITIALIZED;
    sample->continuity = LPC_UNINITIALIZED;
    if (!tms_ClockMonotonic_initialize_w_params(&sample->time,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_PowerPortLoadPolicyReport_finalize_w_return(
    tms_PowerPortLoadPolicyReport* sample)
{
    tms_PowerPortLoadPolicyReport_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_PowerPortLoadPolicyReport_finalize(
    tms_PowerPortLoadPolicyReport* sample)
{

    tms_PowerPortLoadPolicyReport_finalize_ex(sample,RTI_TRUE);
}

void tms_PowerPortLoadPolicyReport_finalize_ex(
    tms_PowerPortLoadPolicyReport* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_PowerPortLoadPolicyReport_finalize_w_params(
        sample,&deallocParams);
}

void tms_PowerPortLoadPolicyReport_finalize_w_params(
    tms_PowerPortLoadPolicyReport* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_LoadPolicy_finalize_w_params(&sample->type,deallocParams);

    tms_PowerLine_finalize_w_params(&sample->line,deallocParams);

    tms_LoadPolicyContinuity_finalize_w_params(&sample->continuity,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->time,deallocParams);

}

void tms_PowerPortLoadPolicyReport_finalize_optional_members(
    tms_PowerPortLoadPolicyReport* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_PowerPortLoadPolicyReport_copy(
    tms_PowerPortLoadPolicyReport* dst,
    const tms_PowerPortLoadPolicyReport* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyUnsignedLong (
            &dst->portNumber, &src->portNumber)) { 
            return RTI_FALSE;
        }
        if (!tms_LoadPolicy_copy(
            &dst->type,(const tms_LoadPolicy*)&src->type)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerLine_copy(
            &dst->line,(const tms_PowerLine*)&src->line)) {
            return RTI_FALSE;
        } 
        if (!tms_LoadPolicyContinuity_copy(
            &dst->continuity,(const tms_LoadPolicyContinuity*)&src->continuity)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->time,(const tms_ClockMonotonic*)&src->time)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_PowerPortLoadPolicyReport' sequence class.
*/
#define T tms_PowerPortLoadPolicyReport
#define TSeq tms_PowerPortLoadPolicyReportSeq

#define T_initialize_w_params tms_PowerPortLoadPolicyReport_initialize_w_params

#define T_finalize_w_params   tms_PowerPortLoadPolicyReport_finalize_w_params
#define T_copy       tms_PowerPortLoadPolicyReport_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DeviceLoadPolicyStatusTYPENAME = "tms::DeviceLoadPolicyStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DeviceLoadPolicyStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_DeviceLoadPolicyStatus_g_tc_ports_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_ports)),NULL);

    static DDS_TypeCode_Member tms_DeviceLoadPolicyStatus_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ports",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DeviceLoadPolicyStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DeviceLoadPolicyStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_DeviceLoadPolicyStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DeviceLoadPolicyStatus*/

    if (is_initialized) {
        return &tms_DeviceLoadPolicyStatus_g_tc;
    }

    tms_DeviceLoadPolicyStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DeviceLoadPolicyStatus_g_tc_ports_sequence._data._typeCode = (RTICdrTypeCode *)tms_PowerPortLoadPolicyReport_get_typecode();
    tms_DeviceLoadPolicyStatus_g_tc_ports_sequence._data._sampleAccessInfo = tms_PowerPortLoadPolicyReport_get_sample_seq_access_info();
    tms_DeviceLoadPolicyStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DeviceLoadPolicyStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_DeviceLoadPolicyStatus_g_tc_ports_sequence;

    /* Initialize the values for member annotations. */

    tms_DeviceLoadPolicyStatus_g_tc._data._sampleAccessInfo =
    tms_DeviceLoadPolicyStatus_get_sample_access_info();
    tms_DeviceLoadPolicyStatus_g_tc._data._typePlugin =
    tms_DeviceLoadPolicyStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DeviceLoadPolicyStatus_g_tc;
}

#define TSeq tms_DeviceLoadPolicyStatusSeq
#define T tms_DeviceLoadPolicyStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DeviceLoadPolicyStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DeviceLoadPolicyStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DeviceLoadPolicyStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DeviceLoadPolicyStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DeviceLoadPolicyStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DeviceLoadPolicyStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DeviceLoadPolicyStatus *sample;

    static RTIXCdrMemberAccessInfo tms_DeviceLoadPolicyStatus_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DeviceLoadPolicyStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DeviceLoadPolicyStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DeviceLoadPolicyStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_DeviceLoadPolicyStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DeviceLoadPolicyStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->ports - (char *)sample);

    tms_DeviceLoadPolicyStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_DeviceLoadPolicyStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DeviceLoadPolicyStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DeviceLoadPolicyStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DeviceLoadPolicyStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DeviceLoadPolicyStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DeviceLoadPolicyStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DeviceLoadPolicyStatus_get_member_value_pointer;

    tms_DeviceLoadPolicyStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DeviceLoadPolicyStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DeviceLoadPolicyStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DeviceLoadPolicyStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DeviceLoadPolicyStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DeviceLoadPolicyStatus_finalize_w_return,
        NULL
    };

    return &tms_DeviceLoadPolicyStatus_g_typePlugin;
}
#endif

RTIBool tms_DeviceLoadPolicyStatus_initialize(
    tms_DeviceLoadPolicyStatus* sample) {
    return tms_DeviceLoadPolicyStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DeviceLoadPolicyStatus_initialize_ex(
    tms_DeviceLoadPolicyStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DeviceLoadPolicyStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DeviceLoadPolicyStatus_initialize_w_params(
    tms_DeviceLoadPolicyStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (allocParams->allocate_memory) {
        if(!tms_PowerPortLoadPolicyReportSeq_initialize(&sample->ports )){
            return RTI_FALSE;
        };
        if(!tms_PowerPortLoadPolicyReportSeq_set_element_allocation_params(&sample->ports ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_PowerPortLoadPolicyReportSeq_set_absolute_maximum(&sample->ports , ((tms_MAXLEN_ports)))){
            return RTI_FALSE;
        }
        if (!tms_PowerPortLoadPolicyReportSeq_set_maximum(&sample->ports, ((tms_MAXLEN_ports)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_PowerPortLoadPolicyReportSeq_set_length(&sample->ports, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_DeviceLoadPolicyStatus_finalize_w_return(
    tms_DeviceLoadPolicyStatus* sample)
{
    tms_DeviceLoadPolicyStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DeviceLoadPolicyStatus_finalize(
    tms_DeviceLoadPolicyStatus* sample)
{

    tms_DeviceLoadPolicyStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_DeviceLoadPolicyStatus_finalize_ex(
    tms_DeviceLoadPolicyStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DeviceLoadPolicyStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_DeviceLoadPolicyStatus_finalize_w_params(
    tms_DeviceLoadPolicyStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    if(!tms_PowerPortLoadPolicyReportSeq_set_element_deallocation_params(
        &sample->ports,deallocParams)){
        return; 
    }
    if(!tms_PowerPortLoadPolicyReportSeq_finalize(&sample->ports)){
        return;
    }

}

void tms_DeviceLoadPolicyStatus_finalize_optional_members(
    tms_DeviceLoadPolicyStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DeviceLoadPolicyStatus_copy(
    tms_DeviceLoadPolicyStatus* dst,
    const tms_DeviceLoadPolicyStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_PowerPortLoadPolicyReportSeq_copy(&dst->ports ,
        &src->ports )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DeviceLoadPolicyStatus' sequence class.
*/
#define T tms_DeviceLoadPolicyStatus
#define TSeq tms_DeviceLoadPolicyStatusSeq

#define T_initialize_w_params tms_DeviceLoadPolicyStatus_initialize_w_params

#define T_finalize_w_params   tms_DeviceLoadPolicyStatus_finalize_w_params
#define T_copy       tms_DeviceLoadPolicyStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DevicePriorityTYPENAME = "tms::DevicePriority";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DevicePriority_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_DevicePriority_g_tc_members[2]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priority",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DevicePriority_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DevicePriority", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_DevicePriority_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DevicePriority*/

    if (is_initialized) {
        return &tms_DevicePriority_g_tc;
    }

    tms_DevicePriority_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DevicePriority_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DevicePriority_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PriorityValue_get_typecode();

    /* Initialize the values for member annotations. */

    tms_DevicePriority_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_DevicePriority_g_tc_members[1]._annotations._defaultValue._u.long_value = 0;
    tms_DevicePriority_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_DevicePriority_g_tc_members[1]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_DevicePriority_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_DevicePriority_g_tc_members[1]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_DevicePriority_g_tc._data._sampleAccessInfo =
    tms_DevicePriority_get_sample_access_info();
    tms_DevicePriority_g_tc._data._typePlugin =
    tms_DevicePriority_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DevicePriority_g_tc;
}

#define TSeq tms_DevicePrioritySeq
#define T tms_DevicePriority
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DevicePriority_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DevicePriority_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DevicePrioritySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DevicePrioritySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DevicePriority_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DevicePriority_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DevicePriority *sample;

    static RTIXCdrMemberAccessInfo tms_DevicePriority_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DevicePriority_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DevicePriority_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DevicePriority);
    if (sample == NULL) {
        return NULL;
    }

    tms_DevicePriority_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DevicePriority_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priority - (char *)sample);

    tms_DevicePriority_g_sampleAccessInfo.memberAccessInfos = 
    tms_DevicePriority_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DevicePriority);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DevicePriority_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DevicePriority_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DevicePriority_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DevicePriority_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DevicePriority_get_member_value_pointer;

    tms_DevicePriority_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DevicePriority_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DevicePriority_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DevicePriority_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DevicePriority_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DevicePriority_finalize_w_return,
        NULL
    };

    return &tms_DevicePriority_g_typePlugin;
}
#endif

RTIBool tms_DevicePriority_initialize(
    tms_DevicePriority* sample) {
    return tms_DevicePriority_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DevicePriority_initialize_ex(
    tms_DevicePriority* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DevicePriority_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DevicePriority_initialize_w_params(
    tms_DevicePriority* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->priority = 0;

    return RTI_TRUE;
}

RTIBool tms_DevicePriority_finalize_w_return(
    tms_DevicePriority* sample)
{
    tms_DevicePriority_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DevicePriority_finalize(
    tms_DevicePriority* sample)
{

    tms_DevicePriority_finalize_ex(sample,RTI_TRUE);
}

void tms_DevicePriority_finalize_ex(
    tms_DevicePriority* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DevicePriority_finalize_w_params(
        sample,&deallocParams);
}

void tms_DevicePriority_finalize_w_params(
    tms_DevicePriority* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_DevicePriority_finalize_optional_members(
    tms_DevicePriority* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DevicePriority_copy(
    tms_DevicePriority* dst,
    const tms_DevicePriority* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyLong (
            &dst->priority, &src->priority)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DevicePriority' sequence class.
*/
#define T tms_DevicePriority
#define TSeq tms_DevicePrioritySeq

#define T_initialize_w_params tms_DevicePriority_initialize_w_params

#define T_finalize_w_params   tms_DevicePriority_finalize_w_params
#define T_copy       tms_DevicePriority_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_NsnPriorityTYPENAME = "tms::NsnPriority";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_NsnPriority_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_NsnPriority_g_tc_members[2]=
    {

        {
            (char *)"nsn",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priority",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_NsnPriority_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::NsnPriority", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_NsnPriority_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_NsnPriority*/

    if (is_initialized) {
        return &tms_NsnPriority_g_tc;
    }

    tms_NsnPriority_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_NsnPriority_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_NatoStockNumber_get_typecode();
    tms_NsnPriority_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PriorityValue_get_typecode();

    /* Initialize the values for member annotations. */

    tms_NsnPriority_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_NsnPriority_g_tc_members[1]._annotations._defaultValue._u.long_value = 0;
    tms_NsnPriority_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_NsnPriority_g_tc_members[1]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_NsnPriority_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_NsnPriority_g_tc_members[1]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_NsnPriority_g_tc._data._sampleAccessInfo =
    tms_NsnPriority_get_sample_access_info();
    tms_NsnPriority_g_tc._data._typePlugin =
    tms_NsnPriority_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_NsnPriority_g_tc;
}

#define TSeq tms_NsnPrioritySeq
#define T tms_NsnPriority
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_NsnPriority_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_NsnPriority_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_NsnPrioritySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_NsnPrioritySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_NsnPriority_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_NsnPriority_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_NsnPriority *sample;

    static RTIXCdrMemberAccessInfo tms_NsnPriority_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_NsnPriority_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_NsnPriority_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_NsnPriority);
    if (sample == NULL) {
        return NULL;
    }

    tms_NsnPriority_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nsn - (char *)sample);

    tms_NsnPriority_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priority - (char *)sample);

    tms_NsnPriority_g_sampleAccessInfo.memberAccessInfos = 
    tms_NsnPriority_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_NsnPriority);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_NsnPriority_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_NsnPriority_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_NsnPriority_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_NsnPriority_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_NsnPriority_get_member_value_pointer;

    tms_NsnPriority_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_NsnPriority_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_NsnPriority_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_NsnPriority_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_NsnPriority_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_NsnPriority_finalize_w_return,
        NULL
    };

    return &tms_NsnPriority_g_typePlugin;
}
#endif

RTIBool tms_NsnPriority_initialize(
    tms_NsnPriority* sample) {
    return tms_NsnPriority_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_NsnPriority_initialize_ex(
    tms_NsnPriority* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_NsnPriority_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_NsnPriority_initialize_w_params(
    tms_NsnPriority* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_NatoStockNumber_initialize_w_params(&sample->nsn,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->priority = 0;

    return RTI_TRUE;
}

RTIBool tms_NsnPriority_finalize_w_return(
    tms_NsnPriority* sample)
{
    tms_NsnPriority_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_NsnPriority_finalize(
    tms_NsnPriority* sample)
{

    tms_NsnPriority_finalize_ex(sample,RTI_TRUE);
}

void tms_NsnPriority_finalize_ex(
    tms_NsnPriority* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_NsnPriority_finalize_w_params(
        sample,&deallocParams);
}

void tms_NsnPriority_finalize_w_params(
    tms_NsnPriority* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_NatoStockNumber_finalize_w_params(&sample->nsn,deallocParams);

}

void tms_NsnPriority_finalize_optional_members(
    tms_NsnPriority* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_NsnPriority_copy(
    tms_NsnPriority* dst,
    const tms_NsnPriority* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_NatoStockNumber_copy(
            &dst->nsn,(const tms_NatoStockNumber*)&src->nsn)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyLong (
            &dst->priority, &src->priority)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_NsnPriority' sequence class.
*/
#define T tms_NsnPriority
#define TSeq tms_NsnPrioritySeq

#define T_initialize_w_params tms_NsnPriority_initialize_w_params

#define T_finalize_w_params   tms_NsnPriority_finalize_w_params
#define T_copy       tms_NsnPriority_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_GtinPriorityTYPENAME = "tms::GtinPriority";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_GtinPriority_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_GtinPriority_g_tc_members[2]=
    {

        {
            (char *)"gtin",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"priority",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_GtinPriority_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::GtinPriority", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_GtinPriority_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_GtinPriority*/

    if (is_initialized) {
        return &tms_GtinPriority_g_tc;
    }

    tms_GtinPriority_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_GtinPriority_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_GlobalTradeItemNumber_get_typecode();
    tms_GtinPriority_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_PriorityValue_get_typecode();

    /* Initialize the values for member annotations. */

    tms_GtinPriority_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_GtinPriority_g_tc_members[1]._annotations._defaultValue._u.long_value = 0;
    tms_GtinPriority_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_GtinPriority_g_tc_members[1]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_GtinPriority_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_GtinPriority_g_tc_members[1]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_GtinPriority_g_tc._data._sampleAccessInfo =
    tms_GtinPriority_get_sample_access_info();
    tms_GtinPriority_g_tc._data._typePlugin =
    tms_GtinPriority_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_GtinPriority_g_tc;
}

#define TSeq tms_GtinPrioritySeq
#define T tms_GtinPriority
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_GtinPriority_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_GtinPriority_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_GtinPrioritySeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_GtinPrioritySeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_GtinPriority_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_GtinPriority_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_GtinPriority *sample;

    static RTIXCdrMemberAccessInfo tms_GtinPriority_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_GtinPriority_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_GtinPriority_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_GtinPriority);
    if (sample == NULL) {
        return NULL;
    }

    tms_GtinPriority_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->gtin - (char *)sample);

    tms_GtinPriority_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->priority - (char *)sample);

    tms_GtinPriority_g_sampleAccessInfo.memberAccessInfos = 
    tms_GtinPriority_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_GtinPriority);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_GtinPriority_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_GtinPriority_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_GtinPriority_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_GtinPriority_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_GtinPriority_get_member_value_pointer;

    tms_GtinPriority_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_GtinPriority_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_GtinPriority_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_GtinPriority_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_GtinPriority_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_GtinPriority_finalize_w_return,
        NULL
    };

    return &tms_GtinPriority_g_typePlugin;
}
#endif

RTIBool tms_GtinPriority_initialize(
    tms_GtinPriority* sample) {
    return tms_GtinPriority_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_GtinPriority_initialize_ex(
    tms_GtinPriority* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_GtinPriority_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_GtinPriority_initialize_w_params(
    tms_GtinPriority* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_GlobalTradeItemNumber_initialize_w_params(&sample->gtin,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->priority = 0;

    return RTI_TRUE;
}

RTIBool tms_GtinPriority_finalize_w_return(
    tms_GtinPriority* sample)
{
    tms_GtinPriority_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_GtinPriority_finalize(
    tms_GtinPriority* sample)
{

    tms_GtinPriority_finalize_ex(sample,RTI_TRUE);
}

void tms_GtinPriority_finalize_ex(
    tms_GtinPriority* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_GtinPriority_finalize_w_params(
        sample,&deallocParams);
}

void tms_GtinPriority_finalize_w_params(
    tms_GtinPriority* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_GlobalTradeItemNumber_finalize_w_params(&sample->gtin,deallocParams);

}

void tms_GtinPriority_finalize_optional_members(
    tms_GtinPriority* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_GtinPriority_copy(
    tms_GtinPriority* dst,
    const tms_GtinPriority* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_GlobalTradeItemNumber_copy(
            &dst->gtin,(const tms_GlobalTradeItemNumber*)&src->gtin)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyLong (
            &dst->priority, &src->priority)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_GtinPriority' sequence class.
*/
#define T tms_GtinPriority
#define TSeq tms_GtinPrioritySeq

#define T_initialize_w_params tms_GtinPriority_initialize_w_params

#define T_finalize_w_params   tms_GtinPriority_finalize_w_params
#define T_copy       tms_GtinPriority_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_McPriorityListTYPENAME = "tms::McPriorityList";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_McPriorityList_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_McPriorityList_g_tc_byIdentity_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_byIdentity)),NULL);
    static DDS_TypeCode tms_McPriorityList_g_tc_byNsn_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_byNsn)),NULL);
    static DDS_TypeCode tms_McPriorityList_g_tc_byGtin_sequence = DDS_INITIALIZE_SEQUENCE_TYPECODE(((tms_MAXLEN_byGtin)),NULL);

    static DDS_TypeCode_Member tms_McPriorityList_g_tc_members[3]=
    {

        {
            (char *)"byIdentity",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"byNsn",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"byGtin",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_McPriorityList_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::McPriorityList", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_McPriorityList_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_McPriorityList*/

    if (is_initialized) {
        return &tms_McPriorityList_g_tc;
    }

    tms_McPriorityList_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_McPriorityList_g_tc_byIdentity_sequence._data._typeCode = (RTICdrTypeCode *)tms_DevicePriority_get_typecode();
    tms_McPriorityList_g_tc_byIdentity_sequence._data._sampleAccessInfo = tms_DevicePriority_get_sample_seq_access_info();
    tms_McPriorityList_g_tc_byNsn_sequence._data._typeCode = (RTICdrTypeCode *)tms_NsnPriority_get_typecode();
    tms_McPriorityList_g_tc_byNsn_sequence._data._sampleAccessInfo = tms_NsnPriority_get_sample_seq_access_info();
    tms_McPriorityList_g_tc_byGtin_sequence._data._typeCode = (RTICdrTypeCode *)tms_GtinPriority_get_typecode();
    tms_McPriorityList_g_tc_byGtin_sequence._data._sampleAccessInfo = tms_GtinPriority_get_sample_seq_access_info();
    tms_McPriorityList_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)& tms_McPriorityList_g_tc_byIdentity_sequence;
    tms_McPriorityList_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)& tms_McPriorityList_g_tc_byNsn_sequence;
    tms_McPriorityList_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)& tms_McPriorityList_g_tc_byGtin_sequence;

    /* Initialize the values for member annotations. */

    tms_McPriorityList_g_tc._data._sampleAccessInfo =
    tms_McPriorityList_get_sample_access_info();
    tms_McPriorityList_g_tc._data._typePlugin =
    tms_McPriorityList_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_McPriorityList_g_tc;
}

#define TSeq tms_McPriorityListSeq
#define T tms_McPriorityList
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_McPriorityList_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_McPriorityList_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_McPriorityListSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_McPriorityListSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_McPriorityList_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_McPriorityList_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_McPriorityList *sample;

    static RTIXCdrMemberAccessInfo tms_McPriorityList_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_McPriorityList_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_McPriorityList_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_McPriorityList);
    if (sample == NULL) {
        return NULL;
    }

    tms_McPriorityList_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->byIdentity - (char *)sample);

    tms_McPriorityList_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->byNsn - (char *)sample);

    tms_McPriorityList_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->byGtin - (char *)sample);

    tms_McPriorityList_g_sampleAccessInfo.memberAccessInfos = 
    tms_McPriorityList_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_McPriorityList);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_McPriorityList_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_McPriorityList_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_McPriorityList_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_McPriorityList_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_McPriorityList_get_member_value_pointer;

    tms_McPriorityList_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_McPriorityList_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_McPriorityList_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_McPriorityList_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_McPriorityList_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_McPriorityList_finalize_w_return,
        NULL
    };

    return &tms_McPriorityList_g_typePlugin;
}
#endif

RTIBool tms_McPriorityList_initialize(
    tms_McPriorityList* sample) {
    return tms_McPriorityList_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_McPriorityList_initialize_ex(
    tms_McPriorityList* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_McPriorityList_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_McPriorityList_initialize_w_params(
    tms_McPriorityList* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    void* buffer = NULL;
    if (buffer) {} /* To avoid warnings */

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (allocParams->allocate_memory) {
        if(!tms_DevicePrioritySeq_initialize(&sample->byIdentity )){
            return RTI_FALSE;
        };
        if(!tms_DevicePrioritySeq_set_element_allocation_params(&sample->byIdentity ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_DevicePrioritySeq_set_absolute_maximum(&sample->byIdentity , ((tms_MAXLEN_byIdentity)))){
            return RTI_FALSE;
        }
        if (!tms_DevicePrioritySeq_set_maximum(&sample->byIdentity, ((tms_MAXLEN_byIdentity)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_DevicePrioritySeq_set_length(&sample->byIdentity, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_NsnPrioritySeq_initialize(&sample->byNsn )){
            return RTI_FALSE;
        };
        if(!tms_NsnPrioritySeq_set_element_allocation_params(&sample->byNsn ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_NsnPrioritySeq_set_absolute_maximum(&sample->byNsn , ((tms_MAXLEN_byNsn)))){
            return RTI_FALSE;
        }
        if (!tms_NsnPrioritySeq_set_maximum(&sample->byNsn, ((tms_MAXLEN_byNsn)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_NsnPrioritySeq_set_length(&sample->byNsn, 0)){
            return RTI_FALSE;
        }    
    }
    if (allocParams->allocate_memory) {
        if(!tms_GtinPrioritySeq_initialize(&sample->byGtin )){
            return RTI_FALSE;
        };
        if(!tms_GtinPrioritySeq_set_element_allocation_params(&sample->byGtin ,allocParams)){
            return RTI_FALSE;
        };
        if(!tms_GtinPrioritySeq_set_absolute_maximum(&sample->byGtin , ((tms_MAXLEN_byGtin)))){
            return RTI_FALSE;
        }
        if (!tms_GtinPrioritySeq_set_maximum(&sample->byGtin, ((tms_MAXLEN_byGtin)))) {
            return RTI_FALSE;
        }
    } else { 
        if(!tms_GtinPrioritySeq_set_length(&sample->byGtin, 0)){
            return RTI_FALSE;
        }    
    }
    return RTI_TRUE;
}

RTIBool tms_McPriorityList_finalize_w_return(
    tms_McPriorityList* sample)
{
    tms_McPriorityList_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_McPriorityList_finalize(
    tms_McPriorityList* sample)
{

    tms_McPriorityList_finalize_ex(sample,RTI_TRUE);
}

void tms_McPriorityList_finalize_ex(
    tms_McPriorityList* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_McPriorityList_finalize_w_params(
        sample,&deallocParams);
}

void tms_McPriorityList_finalize_w_params(
    tms_McPriorityList* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    if(!tms_DevicePrioritySeq_set_element_deallocation_params(
        &sample->byIdentity,deallocParams)){
        return; 
    }
    if(!tms_DevicePrioritySeq_finalize(&sample->byIdentity)){
        return;
    }

    if(!tms_NsnPrioritySeq_set_element_deallocation_params(
        &sample->byNsn,deallocParams)){
        return; 
    }
    if(!tms_NsnPrioritySeq_finalize(&sample->byNsn)){
        return;
    }

    if(!tms_GtinPrioritySeq_set_element_deallocation_params(
        &sample->byGtin,deallocParams)){
        return; 
    }
    if(!tms_GtinPrioritySeq_finalize(&sample->byGtin)){
        return;
    }

}

void tms_McPriorityList_finalize_optional_members(
    tms_McPriorityList* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_McPriorityList_copy(
    tms_McPriorityList* dst,
    const tms_McPriorityList* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_DevicePrioritySeq_copy(&dst->byIdentity ,
        &src->byIdentity )) {
            return RTI_FALSE;
        }
        if (!tms_NsnPrioritySeq_copy(&dst->byNsn ,
        &src->byNsn )) {
            return RTI_FALSE;
        }
        if (!tms_GtinPrioritySeq_copy(&dst->byGtin ,
        &src->byGtin )) {
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_McPriorityList' sequence class.
*/
#define T tms_McPriorityList
#define TSeq tms_McPriorityListSeq

#define T_initialize_w_params tms_McPriorityList_initialize_w_params

#define T_finalize_w_params   tms_McPriorityList_finalize_w_params
#define T_copy       tms_McPriorityList_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_McRedirectTYPENAME = "tms::McRedirect";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_McRedirect_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_McRedirect_g_tc_members[2]=
    {

        {
            (char *)"sourceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"targetId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_McRedirect_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::McRedirect", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_McRedirect_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_McRedirect*/

    if (is_initialized) {
        return &tms_McRedirect_g_tc;
    }

    tms_McRedirect_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_McRedirect_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_McRedirect_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();

    /* Initialize the values for member annotations. */

    tms_McRedirect_g_tc._data._sampleAccessInfo =
    tms_McRedirect_get_sample_access_info();
    tms_McRedirect_g_tc._data._typePlugin =
    tms_McRedirect_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_McRedirect_g_tc;
}

#define TSeq tms_McRedirectSeq
#define T tms_McRedirect
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_McRedirect_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_McRedirect_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_McRedirectSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_McRedirectSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_McRedirect_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_McRedirect_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_McRedirect *sample;

    static RTIXCdrMemberAccessInfo tms_McRedirect_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_McRedirect_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_McRedirect_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_McRedirect);
    if (sample == NULL) {
        return NULL;
    }

    tms_McRedirect_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->sourceId - (char *)sample);

    tms_McRedirect_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->targetId - (char *)sample);

    tms_McRedirect_g_sampleAccessInfo.memberAccessInfos = 
    tms_McRedirect_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_McRedirect);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_McRedirect_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_McRedirect_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_McRedirect_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_McRedirect_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_McRedirect_get_member_value_pointer;

    tms_McRedirect_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_McRedirect_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_McRedirect_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_McRedirect_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_McRedirect_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_McRedirect_finalize_w_return,
        NULL
    };

    return &tms_McRedirect_g_typePlugin;
}
#endif

RTIBool tms_McRedirect_initialize(
    tms_McRedirect* sample) {
    return tms_McRedirect_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_McRedirect_initialize_ex(
    tms_McRedirect* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_McRedirect_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_McRedirect_initialize_w_params(
    tms_McRedirect* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->sourceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->targetId,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_McRedirect_finalize_w_return(
    tms_McRedirect* sample)
{
    tms_McRedirect_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_McRedirect_finalize(
    tms_McRedirect* sample)
{

    tms_McRedirect_finalize_ex(sample,RTI_TRUE);
}

void tms_McRedirect_finalize_ex(
    tms_McRedirect* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_McRedirect_finalize_w_params(
        sample,&deallocParams);
}

void tms_McRedirect_finalize_w_params(
    tms_McRedirect* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->sourceId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->targetId,deallocParams);

}

void tms_McRedirect_finalize_optional_members(
    tms_McRedirect* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_McRedirect_copy(
    tms_McRedirect* dst,
    const tms_McRedirect* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->sourceId,(const tms_Fingerprint*)&src->sourceId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->targetId,(const tms_Fingerprint*)&src->targetId)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_McRedirect' sequence class.
*/
#define T tms_McRedirect
#define TSeq tms_McRedirectSeq

#define T_initialize_w_params tms_McRedirect_initialize_w_params

#define T_finalize_w_params   tms_McRedirect_finalize_w_params
#define T_copy       tms_McRedirect_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_EngineStateTYPENAME = "tms::EngineState";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_EngineState_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_EngineState_g_tc_members[5]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"oilPressure",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"coolantTemperature",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"speed",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"fuelLevel",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_EngineState_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::EngineState", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_EngineState_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_EngineState*/

    if (is_initialized) {
        return &tms_EngineState_g_tc;
    }

    tms_EngineState_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_EngineState_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_EngineState_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_EngineState_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_EngineState_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_EngineState_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_EngineState_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineState_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineState_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineState_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineState_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineState_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineState_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineState_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineState_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineState_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_EngineState_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_EngineState_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_EngineState_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_EngineState_g_tc._data._sampleAccessInfo =
    tms_EngineState_get_sample_access_info();
    tms_EngineState_g_tc._data._typePlugin =
    tms_EngineState_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_EngineState_g_tc;
}

#define TSeq tms_EngineStateSeq
#define T tms_EngineState
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_EngineState_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_EngineState_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_EngineStateSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_EngineStateSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_EngineState_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_EngineState_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_EngineState *sample;

    static RTIXCdrMemberAccessInfo tms_EngineState_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_EngineState_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_EngineState_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_EngineState);
    if (sample == NULL) {
        return NULL;
    }

    tms_EngineState_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_EngineState_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->oilPressure - (char *)sample);

    tms_EngineState_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->coolantTemperature - (char *)sample);

    tms_EngineState_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->speed - (char *)sample);

    tms_EngineState_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->fuelLevel - (char *)sample);

    tms_EngineState_g_sampleAccessInfo.memberAccessInfos = 
    tms_EngineState_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_EngineState);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_EngineState_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_EngineState_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_EngineState_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_EngineState_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_EngineState_get_member_value_pointer;

    tms_EngineState_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_EngineState_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_EngineState_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_EngineState_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_EngineState_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_EngineState_finalize_w_return,
        NULL
    };

    return &tms_EngineState_g_typePlugin;
}
#endif

RTIBool tms_EngineState_initialize(
    tms_EngineState* sample) {
    return tms_EngineState_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_EngineState_initialize_ex(
    tms_EngineState* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_EngineState_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_EngineState_initialize_w_params(
    tms_EngineState* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->oilPressure = 0.0f;

    sample->coolantTemperature = 0.0f;

    sample->speed = 0.0f;

    sample->fuelLevel = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_EngineState_finalize_w_return(
    tms_EngineState* sample)
{
    tms_EngineState_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_EngineState_finalize(
    tms_EngineState* sample)
{

    tms_EngineState_finalize_ex(sample,RTI_TRUE);
}

void tms_EngineState_finalize_ex(
    tms_EngineState* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_EngineState_finalize_w_params(
        sample,&deallocParams);
}

void tms_EngineState_finalize_w_params(
    tms_EngineState* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_EngineState_finalize_optional_members(
    tms_EngineState* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_EngineState_copy(
    tms_EngineState* dst,
    const tms_EngineState* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->oilPressure, &src->oilPressure)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->coolantTemperature, &src->coolantTemperature)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->speed, &src->speed)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->fuelLevel, &src->fuelLevel)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_EngineState' sequence class.
*/
#define T tms_EngineState
#define TSeq tms_EngineStateSeq

#define T_initialize_w_params tms_EngineState_initialize_w_params

#define T_finalize_w_params   tms_EngineState_finalize_w_params
#define T_copy       tms_EngineState_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_SourceStateTYPENAME = "tms::SourceState";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SourceState_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_SourceState_g_tc_members[5]=
    {

        {
            (char *)"SS_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SS_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SS_OFF",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SS_OFF, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SS_ON",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SS_ON, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SS_RUNNING",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SS_RUNNING, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"SS_SOURCING",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            SS_SOURCING, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_SourceState_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::SourceState", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_SourceState_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_SourceState*/

    if (is_initialized) {
        return &tms_SourceState_g_tc;
    }

    tms_SourceState_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_SourceState_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_SourceState_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_SourceState_g_tc._data._sampleAccessInfo =
    tms_SourceState_get_sample_access_info();
    tms_SourceState_g_tc._data._typePlugin =
    tms_SourceState_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SourceState_g_tc;
}

#define TSeq tms_SourceStateSeq
#define T tms_SourceState
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SourceState_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SourceState_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SourceStateSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SourceStateSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SourceState_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SourceState_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_SourceState_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SourceState_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SourceState_g_sampleAccessInfo;
    }

    tms_SourceState_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_SourceState_g_sampleAccessInfo.memberAccessInfos = 
    tms_SourceState_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SourceState);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SourceState_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SourceState_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SourceState_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SourceState_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SourceState_get_member_value_pointer;

    tms_SourceState_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SourceState_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SourceState_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SourceState_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SourceState_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SourceState_finalize_w_return,
        NULL
    };

    return &tms_SourceState_g_typePlugin;
}
#endif

RTIBool tms_SourceState_initialize(
    tms_SourceState* sample) {
    *sample = SS_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_SourceState_initialize_ex(
    tms_SourceState* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SourceState_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SourceState_initialize_w_params(
    tms_SourceState* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = SS_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_SourceState_finalize_w_return(
    tms_SourceState* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_SourceState_finalize(
    tms_SourceState* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_SourceState_finalize_ex(
    tms_SourceState* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SourceState_finalize_w_params(
        sample,&deallocParams);
}

void tms_SourceState_finalize_w_params(
    tms_SourceState* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_SourceState_finalize_optional_members(
    tms_SourceState* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SourceState_copy(
    tms_SourceState* dst,
    const tms_SourceState* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SourceState' sequence class.
*/
#define T tms_SourceState
#define TSeq tms_SourceStateSeq

#define T_initialize_w_params tms_SourceState_initialize_w_params

#define T_finalize_w_params   tms_SourceState_finalize_w_params
#define T_copy       tms_SourceState_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_SourceTransitionTYPENAME = "tms::SourceTransition";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SourceTransition_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_SourceTransition_g_tc_members[10]=
    {

        {
            (char *)"ST_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_NONE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_NONE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_POWER_UP",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_POWER_UP, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_POWER_DOWN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_POWER_DOWN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_START",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_START, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_STOP",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_STOP, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_CONNECT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_CONNECT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_DISCONNECT",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_DISCONNECT, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_JUMP_START",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_JUMP_START, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"ST_RAPID_STOP",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            ST_RAPID_STOP, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_SourceTransition_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::SourceTransition", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            10, /* Number of members */
            tms_SourceTransition_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_SourceTransition*/

    if (is_initialized) {
        return &tms_SourceTransition_g_tc;
    }

    tms_SourceTransition_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_SourceTransition_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_SourceTransition_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_SourceTransition_g_tc._data._sampleAccessInfo =
    tms_SourceTransition_get_sample_access_info();
    tms_SourceTransition_g_tc._data._typePlugin =
    tms_SourceTransition_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SourceTransition_g_tc;
}

#define TSeq tms_SourceTransitionSeq
#define T tms_SourceTransition
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SourceTransition_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SourceTransition_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SourceTransitionSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SourceTransitionSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SourceTransition_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SourceTransition_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_SourceTransition_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SourceTransition_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SourceTransition_g_sampleAccessInfo;
    }

    tms_SourceTransition_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_SourceTransition_g_sampleAccessInfo.memberAccessInfos = 
    tms_SourceTransition_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SourceTransition);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SourceTransition_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SourceTransition_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SourceTransition_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SourceTransition_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SourceTransition_get_member_value_pointer;

    tms_SourceTransition_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SourceTransition_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SourceTransition_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SourceTransition_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SourceTransition_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SourceTransition_finalize_w_return,
        NULL
    };

    return &tms_SourceTransition_g_typePlugin;
}
#endif

RTIBool tms_SourceTransition_initialize(
    tms_SourceTransition* sample) {
    *sample = ST_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_SourceTransition_initialize_ex(
    tms_SourceTransition* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SourceTransition_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SourceTransition_initialize_w_params(
    tms_SourceTransition* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = ST_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_SourceTransition_finalize_w_return(
    tms_SourceTransition* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_SourceTransition_finalize(
    tms_SourceTransition* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_SourceTransition_finalize_ex(
    tms_SourceTransition* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SourceTransition_finalize_w_params(
        sample,&deallocParams);
}

void tms_SourceTransition_finalize_w_params(
    tms_SourceTransition* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_SourceTransition_finalize_optional_members(
    tms_SourceTransition* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SourceTransition_copy(
    tms_SourceTransition* dst,
    const tms_SourceTransition* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SourceTransition' sequence class.
*/
#define T tms_SourceTransition
#define TSeq tms_SourceTransitionSeq

#define T_initialize_w_params tms_SourceTransition_initialize_w_params

#define T_finalize_w_params   tms_SourceTransition_finalize_w_params
#define T_copy       tms_SourceTransition_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_SourceTransitionStateTYPENAME = "tms::SourceTransitionState";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SourceTransitionState_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_SourceTransitionState_g_tc_members[6]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"presentState",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"futureState",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"elapsedTime",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"remainingTime",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"relatedRequestId",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_SourceTransitionState_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::SourceTransitionState", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_SourceTransitionState_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_SourceTransitionState*/

    if (is_initialized) {
        return &tms_SourceTransitionState_g_tc;
    }

    tms_SourceTransitionState_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_SourceTransitionState_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_SourceTransitionState_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_SourceState_get_typecode();
    tms_SourceTransitionState_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_SourceState_get_typecode();
    tms_SourceTransitionState_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_SourceTransitionState_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_SourceTransitionState_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();

    /* Initialize the values for member annotations. */

    tms_SourceTransitionState_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_SourceTransitionState_g_tc_members[1]._annotations._defaultValue._u.enumerated_value = 0;

    tms_SourceTransitionState_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_SourceTransitionState_g_tc_members[2]._annotations._defaultValue._u.enumerated_value = 0;

    tms_SourceTransitionState_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_SourceTransitionState_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_SourceTransitionState_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_SourceTransitionState_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_SourceTransitionState_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_SourceTransitionState_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_SourceTransitionState_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_SourceTransitionState_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_SourceTransitionState_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_SourceTransitionState_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_SourceTransitionState_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_SourceTransitionState_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_SourceTransitionState_g_tc._data._sampleAccessInfo =
    tms_SourceTransitionState_get_sample_access_info();
    tms_SourceTransitionState_g_tc._data._typePlugin =
    tms_SourceTransitionState_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SourceTransitionState_g_tc;
}

#define TSeq tms_SourceTransitionStateSeq
#define T tms_SourceTransitionState
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SourceTransitionState_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SourceTransitionState_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SourceTransitionStateSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SourceTransitionStateSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SourceTransitionState_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SourceTransitionState_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_SourceTransitionState *sample;

    static RTIXCdrMemberAccessInfo tms_SourceTransitionState_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SourceTransitionState_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SourceTransitionState_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_SourceTransitionState);
    if (sample == NULL) {
        return NULL;
    }

    tms_SourceTransitionState_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_SourceTransitionState_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->presentState - (char *)sample);

    tms_SourceTransitionState_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->futureState - (char *)sample);

    tms_SourceTransitionState_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->elapsedTime - (char *)sample);

    tms_SourceTransitionState_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->remainingTime - (char *)sample);

    tms_SourceTransitionState_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->relatedRequestId - (char *)sample);

    tms_SourceTransitionState_g_sampleAccessInfo.memberAccessInfos = 
    tms_SourceTransitionState_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SourceTransitionState);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SourceTransitionState_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SourceTransitionState_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SourceTransitionState_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SourceTransitionState_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SourceTransitionState_get_member_value_pointer;

    tms_SourceTransitionState_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SourceTransitionState_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SourceTransitionState_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SourceTransitionState_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SourceTransitionState_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SourceTransitionState_finalize_w_return,
        NULL
    };

    return &tms_SourceTransitionState_g_typePlugin;
}
#endif

RTIBool tms_SourceTransitionState_initialize(
    tms_SourceTransitionState* sample) {
    return tms_SourceTransitionState_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_SourceTransitionState_initialize_ex(
    tms_SourceTransitionState* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SourceTransitionState_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SourceTransitionState_initialize_w_params(
    tms_SourceTransitionState* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->presentState = SS_UNINITIALIZED;
    sample->futureState = SS_UNINITIALIZED;

    sample->elapsedTime = 0.0f;

    sample->remainingTime = 0.0f;

    if (!tms_SampleId_initialize_w_params(&sample->relatedRequestId,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_SourceTransitionState_finalize_w_return(
    tms_SourceTransitionState* sample)
{
    tms_SourceTransitionState_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_SourceTransitionState_finalize(
    tms_SourceTransitionState* sample)
{

    tms_SourceTransitionState_finalize_ex(sample,RTI_TRUE);
}

void tms_SourceTransitionState_finalize_ex(
    tms_SourceTransitionState* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SourceTransitionState_finalize_w_params(
        sample,&deallocParams);
}

void tms_SourceTransitionState_finalize_w_params(
    tms_SourceTransitionState* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_SourceState_finalize_w_params(&sample->presentState,deallocParams);

    tms_SourceState_finalize_w_params(&sample->futureState,deallocParams);

    tms_SampleId_finalize_w_params(&sample->relatedRequestId,deallocParams);

}

void tms_SourceTransitionState_finalize_optional_members(
    tms_SourceTransitionState* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SourceTransitionState_copy(
    tms_SourceTransitionState* dst,
    const tms_SourceTransitionState* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_SourceState_copy(
            &dst->presentState,(const tms_SourceState*)&src->presentState)) {
            return RTI_FALSE;
        } 
        if (!tms_SourceState_copy(
            &dst->futureState,(const tms_SourceState*)&src->futureState)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->elapsedTime, &src->elapsedTime)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->remainingTime, &src->remainingTime)) { 
            return RTI_FALSE;
        }
        if (!tms_SampleId_copy(
            &dst->relatedRequestId,(const tms_SampleId*)&src->relatedRequestId)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SourceTransitionState' sequence class.
*/
#define T tms_SourceTransitionState
#define TSeq tms_SourceTransitionStateSeq

#define T_initialize_w_params tms_SourceTransitionState_initialize_w_params

#define T_finalize_w_params   tms_SourceTransitionState_finalize_w_params
#define T_copy       tms_SourceTransitionState_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_SourceTransitionRequestTYPENAME = "tms::SourceTransitionRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SourceTransitionRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_SourceTransitionRequest_g_tc_members[4]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"desiredTransition",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_SourceTransitionRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::SourceTransitionRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_SourceTransitionRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_SourceTransitionRequest*/

    if (is_initialized) {
        return &tms_SourceTransitionRequest_g_tc;
    }

    tms_SourceTransitionRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_SourceTransitionRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_SourceTransitionRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_SourceTransitionRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_SourceTransitionRequest_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_SourceTransition_get_typecode();

    /* Initialize the values for member annotations. */

    tms_SourceTransitionRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_SourceTransitionRequest_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_SourceTransitionRequest_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_SourceTransitionRequest_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_SourceTransitionRequest_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_SourceTransitionRequest_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_SourceTransitionRequest_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_SourceTransitionRequest_g_tc_members[3]._annotations._defaultValue._u.enumerated_value = 0;

    tms_SourceTransitionRequest_g_tc._data._sampleAccessInfo =
    tms_SourceTransitionRequest_get_sample_access_info();
    tms_SourceTransitionRequest_g_tc._data._typePlugin =
    tms_SourceTransitionRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SourceTransitionRequest_g_tc;
}

#define TSeq tms_SourceTransitionRequestSeq
#define T tms_SourceTransitionRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SourceTransitionRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SourceTransitionRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SourceTransitionRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SourceTransitionRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SourceTransitionRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SourceTransitionRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_SourceTransitionRequest *sample;

    static RTIXCdrMemberAccessInfo tms_SourceTransitionRequest_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SourceTransitionRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SourceTransitionRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_SourceTransitionRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_SourceTransitionRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_SourceTransitionRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_SourceTransitionRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_SourceTransitionRequest_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->desiredTransition - (char *)sample);

    tms_SourceTransitionRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_SourceTransitionRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SourceTransitionRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SourceTransitionRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SourceTransitionRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SourceTransitionRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SourceTransitionRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SourceTransitionRequest_get_member_value_pointer;

    tms_SourceTransitionRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SourceTransitionRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SourceTransitionRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SourceTransitionRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SourceTransitionRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SourceTransitionRequest_finalize_w_return,
        NULL
    };

    return &tms_SourceTransitionRequest_g_typePlugin;
}
#endif

RTIBool tms_SourceTransitionRequest_initialize(
    tms_SourceTransitionRequest* sample) {
    return tms_SourceTransitionRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_SourceTransitionRequest_initialize_ex(
    tms_SourceTransitionRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SourceTransitionRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SourceTransitionRequest_initialize_w_params(
    tms_SourceTransitionRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    sample->desiredTransition = ST_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_SourceTransitionRequest_finalize_w_return(
    tms_SourceTransitionRequest* sample)
{
    tms_SourceTransitionRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_SourceTransitionRequest_finalize(
    tms_SourceTransitionRequest* sample)
{

    tms_SourceTransitionRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_SourceTransitionRequest_finalize_ex(
    tms_SourceTransitionRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SourceTransitionRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_SourceTransitionRequest_finalize_w_params(
    tms_SourceTransitionRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_SourceTransition_finalize_w_params(&sample->desiredTransition,deallocParams);

}

void tms_SourceTransitionRequest_finalize_optional_members(
    tms_SourceTransitionRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SourceTransitionRequest_copy(
    tms_SourceTransitionRequest* dst,
    const tms_SourceTransitionRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!tms_SourceTransition_copy(
            &dst->desiredTransition,(const tms_SourceTransition*)&src->desiredTransition)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SourceTransitionRequest' sequence class.
*/
#define T tms_SourceTransitionRequest
#define TSeq tms_SourceTransitionRequestSeq

#define T_initialize_w_params tms_SourceTransitionRequest_initialize_w_params

#define T_finalize_w_params   tms_SourceTransitionRequest_finalize_w_params
#define T_copy       tms_SourceTransitionRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_ControlCurveTYPENAME = "tms::ControlCurve";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_ControlCurve_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_ControlCurve_g_tc_members[3]=
    {

        {
            (char *)"minimum",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"nominal",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"maximum",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_ControlCurve_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::ControlCurve", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_ControlCurve_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_ControlCurve*/

    if (is_initialized) {
        return &tms_ControlCurve_g_tc;
    }

    tms_ControlCurve_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_ControlCurve_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Curve2D_get_typecode();
    tms_ControlCurve_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Curve2D_get_typecode();
    tms_ControlCurve_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_Curve2D_get_typecode();

    /* Initialize the values for member annotations. */

    tms_ControlCurve_g_tc._data._sampleAccessInfo =
    tms_ControlCurve_get_sample_access_info();
    tms_ControlCurve_g_tc._data._typePlugin =
    tms_ControlCurve_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_ControlCurve_g_tc;
}

#define TSeq tms_ControlCurveSeq
#define T tms_ControlCurve
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_ControlCurve_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_ControlCurve_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_ControlCurveSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_ControlCurveSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_ControlCurve_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_ControlCurve_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_ControlCurve *sample;

    static RTIXCdrMemberAccessInfo tms_ControlCurve_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_ControlCurve_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_ControlCurve_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_ControlCurve);
    if (sample == NULL) {
        return NULL;
    }

    tms_ControlCurve_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->minimum - (char *)sample);

    tms_ControlCurve_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->nominal - (char *)sample);

    tms_ControlCurve_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->maximum - (char *)sample);

    tms_ControlCurve_g_sampleAccessInfo.memberAccessInfos = 
    tms_ControlCurve_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_ControlCurve);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_ControlCurve_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_ControlCurve_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_ControlCurve_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_ControlCurve_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_ControlCurve_get_member_value_pointer;

    tms_ControlCurve_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_ControlCurve_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_ControlCurve_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_ControlCurve_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_ControlCurve_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_ControlCurve_finalize_w_return,
        NULL
    };

    return &tms_ControlCurve_g_typePlugin;
}
#endif

RTIBool tms_ControlCurve_initialize(
    tms_ControlCurve* sample) {
    return tms_ControlCurve_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_ControlCurve_initialize_ex(
    tms_ControlCurve* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_ControlCurve_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_ControlCurve_initialize_w_params(
    tms_ControlCurve* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Curve2D_initialize_w_params(&sample->minimum,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Curve2D_initialize_w_params(&sample->nominal,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Curve2D_initialize_w_params(&sample->maximum,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_ControlCurve_finalize_w_return(
    tms_ControlCurve* sample)
{
    tms_ControlCurve_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_ControlCurve_finalize(
    tms_ControlCurve* sample)
{

    tms_ControlCurve_finalize_ex(sample,RTI_TRUE);
}

void tms_ControlCurve_finalize_ex(
    tms_ControlCurve* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_ControlCurve_finalize_w_params(
        sample,&deallocParams);
}

void tms_ControlCurve_finalize_w_params(
    tms_ControlCurve* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Curve2D_finalize_w_params(&sample->minimum,deallocParams);

    tms_Curve2D_finalize_w_params(&sample->nominal,deallocParams);

    tms_Curve2D_finalize_w_params(&sample->maximum,deallocParams);

}

void tms_ControlCurve_finalize_optional_members(
    tms_ControlCurve* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_ControlCurve_copy(
    tms_ControlCurve* dst,
    const tms_ControlCurve* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Curve2D_copy(
            &dst->minimum,(const tms_Curve2D*)&src->minimum)) {
            return RTI_FALSE;
        } 
        if (!tms_Curve2D_copy(
            &dst->nominal,(const tms_Curve2D*)&src->nominal)) {
            return RTI_FALSE;
        } 
        if (!tms_Curve2D_copy(
            &dst->maximum,(const tms_Curve2D*)&src->maximum)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_ControlCurve' sequence class.
*/
#define T tms_ControlCurve
#define TSeq tms_ControlCurveSeq

#define T_initialize_w_params tms_ControlCurve_initialize_w_params

#define T_finalize_w_params   tms_ControlCurve_finalize_w_params
#define T_copy       tms_ControlCurve_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DLSConfigTYPENAME = "tms::DLSConfig";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DLSConfig_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_DLSConfig_g_tc_members[6]=
    {

        {
            (char *)"sendTopics",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"receiveTopics",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"gainReal",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"gainReactive",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"biasRealPu",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"biasReactivePu",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DLSConfig_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DLSConfig", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_DLSConfig_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DLSConfig*/

    if (is_initialized) {
        return &tms_DLSConfig_g_tc;
    }

    tms_DLSConfig_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DLSConfig_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_TopicList_get_typecode();
    tms_DLSConfig_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_TopicList_get_typecode();
    tms_DLSConfig_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_DLSConfig_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_DLSConfig_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_Curve2D_get_typecode();
    tms_DLSConfig_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_Curve2D_get_typecode();

    /* Initialize the values for member annotations. */

    tms_DLSConfig_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSConfig_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_DLSConfig_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSConfig_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_DLSConfig_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSConfig_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_DLSConfig_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSConfig_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_DLSConfig_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSConfig_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_DLSConfig_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSConfig_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_DLSConfig_g_tc._data._sampleAccessInfo =
    tms_DLSConfig_get_sample_access_info();
    tms_DLSConfig_g_tc._data._typePlugin =
    tms_DLSConfig_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DLSConfig_g_tc;
}

#define TSeq tms_DLSConfigSeq
#define T tms_DLSConfig
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DLSConfig_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DLSConfig_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DLSConfigSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DLSConfigSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DLSConfig_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DLSConfig_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DLSConfig *sample;

    static RTIXCdrMemberAccessInfo tms_DLSConfig_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DLSConfig_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DLSConfig_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DLSConfig);
    if (sample == NULL) {
        return NULL;
    }

    tms_DLSConfig_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->sendTopics - (char *)sample);

    tms_DLSConfig_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->receiveTopics - (char *)sample);

    tms_DLSConfig_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->gainReal - (char *)sample);

    tms_DLSConfig_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->gainReactive - (char *)sample);

    tms_DLSConfig_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->biasRealPu - (char *)sample);

    tms_DLSConfig_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->biasReactivePu - (char *)sample);

    tms_DLSConfig_g_sampleAccessInfo.memberAccessInfos = 
    tms_DLSConfig_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DLSConfig);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DLSConfig_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DLSConfig_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DLSConfig_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DLSConfig_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DLSConfig_get_member_value_pointer;

    tms_DLSConfig_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DLSConfig_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DLSConfig_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DLSConfig_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DLSConfig_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DLSConfig_finalize_w_return,
        NULL
    };

    return &tms_DLSConfig_g_typePlugin;
}
#endif

RTIBool tms_DLSConfig_initialize(
    tms_DLSConfig* sample) {
    return tms_DLSConfig_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DLSConfig_initialize_ex(
    tms_DLSConfig* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DLSConfig_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DLSConfig_initialize_w_params(
    tms_DLSConfig* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_TopicList_initialize_w_params(&sample->sendTopics,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_TopicList_initialize_w_params(&sample->receiveTopics,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->gainReal = 0.0f;

    sample->gainReactive = 0.0f;

    if (!tms_Curve2D_initialize_w_params(&sample->biasRealPu,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Curve2D_initialize_w_params(&sample->biasReactivePu,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_DLSConfig_finalize_w_return(
    tms_DLSConfig* sample)
{
    tms_DLSConfig_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DLSConfig_finalize(
    tms_DLSConfig* sample)
{

    tms_DLSConfig_finalize_ex(sample,RTI_TRUE);
}

void tms_DLSConfig_finalize_ex(
    tms_DLSConfig* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DLSConfig_finalize_w_params(
        sample,&deallocParams);
}

void tms_DLSConfig_finalize_w_params(
    tms_DLSConfig* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_TopicList_finalize_w_params(&sample->sendTopics,deallocParams);

    tms_TopicList_finalize_w_params(&sample->receiveTopics,deallocParams);

    tms_Curve2D_finalize_w_params(&sample->biasRealPu,deallocParams);

    tms_Curve2D_finalize_w_params(&sample->biasReactivePu,deallocParams);

}

void tms_DLSConfig_finalize_optional_members(
    tms_DLSConfig* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DLSConfig_copy(
    tms_DLSConfig* dst,
    const tms_DLSConfig* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_TopicList_copy(
            &dst->sendTopics,(const tms_TopicList*)&src->sendTopics)) {
            return RTI_FALSE;
        } 
        if (!tms_TopicList_copy(
            &dst->receiveTopics,(const tms_TopicList*)&src->receiveTopics)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->gainReal, &src->gainReal)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->gainReactive, &src->gainReactive)) { 
            return RTI_FALSE;
        }
        if (!tms_Curve2D_copy(
            &dst->biasRealPu,(const tms_Curve2D*)&src->biasRealPu)) {
            return RTI_FALSE;
        } 
        if (!tms_Curve2D_copy(
            &dst->biasReactivePu,(const tms_Curve2D*)&src->biasReactivePu)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DLSConfig' sequence class.
*/
#define T tms_DLSConfig
#define TSeq tms_DLSConfigSeq

#define T_initialize_w_params tms_DLSConfig_initialize_w_params

#define T_finalize_w_params   tms_DLSConfig_finalize_w_params
#define T_copy       tms_DLSConfig_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_DLSMeasurementTYPENAME = "tms::DLSMeasurement";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_DLSMeasurement_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_DLSMeasurement_g_tc_members[4]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"time",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realPu",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"reactivePu",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_DLSMeasurement_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::DLSMeasurement", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_DLSMeasurement_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_DLSMeasurement*/

    if (is_initialized) {
        return &tms_DLSMeasurement_g_tc;
    }

    tms_DLSMeasurement_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_DLSMeasurement_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_DLSMeasurement_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_DLSMeasurement_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_DLSMeasurement_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_DLSMeasurement_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSMeasurement_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_DLSMeasurement_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSMeasurement_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_DLSMeasurement_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSMeasurement_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_DLSMeasurement_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSMeasurement_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_DLSMeasurement_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSMeasurement_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_DLSMeasurement_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_DLSMeasurement_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_DLSMeasurement_g_tc._data._sampleAccessInfo =
    tms_DLSMeasurement_get_sample_access_info();
    tms_DLSMeasurement_g_tc._data._typePlugin =
    tms_DLSMeasurement_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_DLSMeasurement_g_tc;
}

#define TSeq tms_DLSMeasurementSeq
#define T tms_DLSMeasurement
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_DLSMeasurement_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_DLSMeasurement_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_DLSMeasurementSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_DLSMeasurementSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_DLSMeasurement_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_DLSMeasurement_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_DLSMeasurement *sample;

    static RTIXCdrMemberAccessInfo tms_DLSMeasurement_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_DLSMeasurement_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_DLSMeasurement_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_DLSMeasurement);
    if (sample == NULL) {
        return NULL;
    }

    tms_DLSMeasurement_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_DLSMeasurement_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->time - (char *)sample);

    tms_DLSMeasurement_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realPu - (char *)sample);

    tms_DLSMeasurement_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->reactivePu - (char *)sample);

    tms_DLSMeasurement_g_sampleAccessInfo.memberAccessInfos = 
    tms_DLSMeasurement_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_DLSMeasurement);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_DLSMeasurement_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_DLSMeasurement_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_DLSMeasurement_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_DLSMeasurement_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_DLSMeasurement_get_member_value_pointer;

    tms_DLSMeasurement_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_DLSMeasurement_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_DLSMeasurement_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_DLSMeasurement_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_DLSMeasurement_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_DLSMeasurement_finalize_w_return,
        NULL
    };

    return &tms_DLSMeasurement_g_typePlugin;
}
#endif

RTIBool tms_DLSMeasurement_initialize(
    tms_DLSMeasurement* sample) {
    return tms_DLSMeasurement_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_DLSMeasurement_initialize_ex(
    tms_DLSMeasurement* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_DLSMeasurement_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_DLSMeasurement_initialize_w_params(
    tms_DLSMeasurement* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockMonotonic_initialize_w_params(&sample->time,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->realPu = 0.0f;

    sample->reactivePu = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_DLSMeasurement_finalize_w_return(
    tms_DLSMeasurement* sample)
{
    tms_DLSMeasurement_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_DLSMeasurement_finalize(
    tms_DLSMeasurement* sample)
{

    tms_DLSMeasurement_finalize_ex(sample,RTI_TRUE);
}

void tms_DLSMeasurement_finalize_ex(
    tms_DLSMeasurement* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_DLSMeasurement_finalize_w_params(
        sample,&deallocParams);
}

void tms_DLSMeasurement_finalize_w_params(
    tms_DLSMeasurement* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->time,deallocParams);

}

void tms_DLSMeasurement_finalize_optional_members(
    tms_DLSMeasurement* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_DLSMeasurement_copy(
    tms_DLSMeasurement* dst,
    const tms_DLSMeasurement* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->time,(const tms_ClockMonotonic*)&src->time)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->realPu, &src->realPu)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->reactivePu, &src->reactivePu)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_DLSMeasurement' sequence class.
*/
#define T tms_DLSMeasurement
#define TSeq tms_DLSMeasurementSeq

#define T_initialize_w_params tms_DLSMeasurement_initialize_w_params

#define T_finalize_w_params   tms_DLSMeasurement_finalize_w_params
#define T_copy       tms_DLSMeasurement_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadSharingTYPENAME = "tms::LoadSharing";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadSharing_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadSharing_g_tc_members[3]=
    {

        {
            (char *)"frequencyPowerCurve",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"voltageReactiveCurve",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"dls",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadSharing_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadSharing", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_LoadSharing_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadSharing*/

    if (is_initialized) {
        return &tms_LoadSharing_g_tc;
    }

    tms_LoadSharing_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadSharing_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_ControlCurve_get_typecode();
    tms_LoadSharing_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ControlCurve_get_typecode();
    tms_LoadSharing_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_DLSConfig_get_typecode();

    /* Initialize the values for member annotations. */

    tms_LoadSharing_g_tc._data._sampleAccessInfo =
    tms_LoadSharing_get_sample_access_info();
    tms_LoadSharing_g_tc._data._typePlugin =
    tms_LoadSharing_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadSharing_g_tc;
}

#define TSeq tms_LoadSharingSeq
#define T tms_LoadSharing
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadSharing_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadSharing_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadSharingSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadSharingSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadSharing_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadSharing_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadSharing *sample;

    static RTIXCdrMemberAccessInfo tms_LoadSharing_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadSharing_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadSharing_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadSharing);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadSharing_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->frequencyPowerCurve - (char *)sample);

    tms_LoadSharing_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->voltageReactiveCurve - (char *)sample);

    tms_LoadSharing_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->dls - (char *)sample);

    tms_LoadSharing_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadSharing_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadSharing);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadSharing_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadSharing_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadSharing_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadSharing_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadSharing_get_member_value_pointer;

    tms_LoadSharing_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadSharing_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadSharing_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadSharing_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadSharing_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadSharing_finalize_w_return,
        NULL
    };

    return &tms_LoadSharing_g_typePlugin;
}
#endif

RTIBool tms_LoadSharing_initialize(
    tms_LoadSharing* sample) {
    return tms_LoadSharing_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadSharing_initialize_ex(
    tms_LoadSharing* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadSharing_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadSharing_initialize_w_params(
    tms_LoadSharing* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_ControlCurve_initialize_w_params(&sample->frequencyPowerCurve,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ControlCurve_initialize_w_params(&sample->voltageReactiveCurve,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_DLSConfig_initialize_w_params(&sample->dls,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_LoadSharing_finalize_w_return(
    tms_LoadSharing* sample)
{
    tms_LoadSharing_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadSharing_finalize(
    tms_LoadSharing* sample)
{

    tms_LoadSharing_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadSharing_finalize_ex(
    tms_LoadSharing* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadSharing_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadSharing_finalize_w_params(
    tms_LoadSharing* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_ControlCurve_finalize_w_params(&sample->frequencyPowerCurve,deallocParams);

    tms_ControlCurve_finalize_w_params(&sample->voltageReactiveCurve,deallocParams);

    tms_DLSConfig_finalize_w_params(&sample->dls,deallocParams);

}

void tms_LoadSharing_finalize_optional_members(
    tms_LoadSharing* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadSharing_copy(
    tms_LoadSharing* dst,
    const tms_LoadSharing* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_ControlCurve_copy(
            &dst->frequencyPowerCurve,(const tms_ControlCurve*)&src->frequencyPowerCurve)) {
            return RTI_FALSE;
        } 
        if (!tms_ControlCurve_copy(
            &dst->voltageReactiveCurve,(const tms_ControlCurve*)&src->voltageReactiveCurve)) {
            return RTI_FALSE;
        } 
        if (!tms_DLSConfig_copy(
            &dst->dls,(const tms_DLSConfig*)&src->dls)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadSharing' sequence class.
*/
#define T tms_LoadSharing
#define TSeq tms_LoadSharingSeq

#define T_initialize_w_params tms_LoadSharing_initialize_w_params

#define T_finalize_w_params   tms_LoadSharing_finalize_w_params
#define T_copy       tms_LoadSharing_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadSharingRequestTYPENAME = "tms::LoadSharingRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadSharingRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadSharingRequest_g_tc_members[4]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"parameters",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadSharingRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadSharingRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_LoadSharingRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadSharingRequest*/

    if (is_initialized) {
        return &tms_LoadSharingRequest_g_tc;
    }

    tms_LoadSharingRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadSharingRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_LoadSharingRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_LoadSharingRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_LoadSharingRequest_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_LoadSharing_get_typecode();

    /* Initialize the values for member annotations. */

    tms_LoadSharingRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadSharingRequest_g_tc_members[2]._annotations._defaultValue._u.ushort_value = 0;
    tms_LoadSharingRequest_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadSharingRequest_g_tc_members[2]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_LoadSharingRequest_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadSharingRequest_g_tc_members[2]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_LoadSharingRequest_g_tc._data._sampleAccessInfo =
    tms_LoadSharingRequest_get_sample_access_info();
    tms_LoadSharingRequest_g_tc._data._typePlugin =
    tms_LoadSharingRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadSharingRequest_g_tc;
}

#define TSeq tms_LoadSharingRequestSeq
#define T tms_LoadSharingRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadSharingRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadSharingRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadSharingRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadSharingRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadSharingRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadSharingRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadSharingRequest *sample;

    static RTIXCdrMemberAccessInfo tms_LoadSharingRequest_g_memberAccessInfos[4] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadSharingRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadSharingRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadSharingRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadSharingRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_LoadSharingRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_LoadSharingRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_LoadSharingRequest_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->parameters - (char *)sample);

    tms_LoadSharingRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadSharingRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadSharingRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadSharingRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadSharingRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadSharingRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadSharingRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadSharingRequest_get_member_value_pointer;

    tms_LoadSharingRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadSharingRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadSharingRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadSharingRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadSharingRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadSharingRequest_finalize_w_return,
        NULL
    };

    return &tms_LoadSharingRequest_g_typePlugin;
}
#endif

RTIBool tms_LoadSharingRequest_initialize(
    tms_LoadSharingRequest* sample) {
    return tms_LoadSharingRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadSharingRequest_initialize_ex(
    tms_LoadSharingRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadSharingRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadSharingRequest_initialize_w_params(
    tms_LoadSharingRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    if (!tms_LoadSharing_initialize_w_params(&sample->parameters,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_LoadSharingRequest_finalize_w_return(
    tms_LoadSharingRequest* sample)
{
    tms_LoadSharingRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadSharingRequest_finalize(
    tms_LoadSharingRequest* sample)
{

    tms_LoadSharingRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadSharingRequest_finalize_ex(
    tms_LoadSharingRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadSharingRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadSharingRequest_finalize_w_params(
    tms_LoadSharingRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_LoadSharing_finalize_w_params(&sample->parameters,deallocParams);

}

void tms_LoadSharingRequest_finalize_optional_members(
    tms_LoadSharingRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadSharingRequest_copy(
    tms_LoadSharingRequest* dst,
    const tms_LoadSharingRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!tms_LoadSharing_copy(
            &dst->parameters,(const tms_LoadSharing*)&src->parameters)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadSharingRequest' sequence class.
*/
#define T tms_LoadSharingRequest
#define TSeq tms_LoadSharingRequestSeq

#define T_initialize_w_params tms_LoadSharingRequest_initialize_w_params

#define T_finalize_w_params   tms_LoadSharingRequest_finalize_w_params
#define T_copy       tms_LoadSharingRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadSharingStatusTYPENAME = "tms::LoadSharingStatus";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadSharingStatus_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadSharingStatus_g_tc_members[3]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"config",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"parameters",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadSharingStatus_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadSharingStatus", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_LoadSharingStatus_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadSharingStatus*/

    if (is_initialized) {
        return &tms_LoadSharingStatus_g_tc;
    }

    tms_LoadSharingStatus_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadSharingStatus_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_LoadSharingStatus_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ConfigId_get_typecode();
    tms_LoadSharingStatus_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_LoadSharing_get_typecode();

    /* Initialize the values for member annotations. */

    tms_LoadSharingStatus_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadSharingStatus_g_tc_members[1]._annotations._defaultValue._u.ushort_value = 0;
    tms_LoadSharingStatus_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadSharingStatus_g_tc_members[1]._annotations._minValue._u.ushort_value = RTIXCdrUnsignedShort_MIN;
    tms_LoadSharingStatus_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_USHORT;
    tms_LoadSharingStatus_g_tc_members[1]._annotations._maxValue._u.ushort_value = RTIXCdrUnsignedShort_MAX;

    tms_LoadSharingStatus_g_tc._data._sampleAccessInfo =
    tms_LoadSharingStatus_get_sample_access_info();
    tms_LoadSharingStatus_g_tc._data._typePlugin =
    tms_LoadSharingStatus_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadSharingStatus_g_tc;
}

#define TSeq tms_LoadSharingStatusSeq
#define T tms_LoadSharingStatus
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadSharingStatus_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadSharingStatus_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadSharingStatusSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadSharingStatusSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadSharingStatus_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadSharingStatus_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadSharingStatus *sample;

    static RTIXCdrMemberAccessInfo tms_LoadSharingStatus_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadSharingStatus_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadSharingStatus_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadSharingStatus);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadSharingStatus_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_LoadSharingStatus_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->config - (char *)sample);

    tms_LoadSharingStatus_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->parameters - (char *)sample);

    tms_LoadSharingStatus_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadSharingStatus_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadSharingStatus);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadSharingStatus_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadSharingStatus_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadSharingStatus_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadSharingStatus_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadSharingStatus_get_member_value_pointer;

    tms_LoadSharingStatus_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadSharingStatus_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadSharingStatus_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadSharingStatus_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadSharingStatus_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadSharingStatus_finalize_w_return,
        NULL
    };

    return &tms_LoadSharingStatus_g_typePlugin;
}
#endif

RTIBool tms_LoadSharingStatus_initialize(
    tms_LoadSharingStatus* sample) {
    return tms_LoadSharingStatus_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadSharingStatus_initialize_ex(
    tms_LoadSharingStatus* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadSharingStatus_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadSharingStatus_initialize_w_params(
    tms_LoadSharingStatus* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->config = 0;

    if (!tms_LoadSharing_initialize_w_params(&sample->parameters,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_LoadSharingStatus_finalize_w_return(
    tms_LoadSharingStatus* sample)
{
    tms_LoadSharingStatus_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadSharingStatus_finalize(
    tms_LoadSharingStatus* sample)
{

    tms_LoadSharingStatus_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadSharingStatus_finalize_ex(
    tms_LoadSharingStatus* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadSharingStatus_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadSharingStatus_finalize_w_params(
    tms_LoadSharingStatus* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_LoadSharing_finalize_w_params(&sample->parameters,deallocParams);

}

void tms_LoadSharingStatus_finalize_optional_members(
    tms_LoadSharingStatus* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadSharingStatus_copy(
    tms_LoadSharingStatus* dst,
    const tms_LoadSharingStatus* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyUnsignedShort (
            &dst->config, &src->config)) { 
            return RTI_FALSE;
        }
        if (!tms_LoadSharing_copy(
            &dst->parameters,(const tms_LoadSharing*)&src->parameters)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadSharingStatus' sequence class.
*/
#define T tms_LoadSharingStatus
#define TSeq tms_LoadSharingStatusSeq

#define T_initialize_w_params tms_LoadSharingStatus_initialize_w_params

#define T_finalize_w_params   tms_LoadSharingStatus_finalize_w_params
#define T_copy       tms_LoadSharingStatus_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadEstimateTYPENAME = "tms::LoadEstimate";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadEstimate_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadEstimate_g_tc_members[10]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"centerFrequency",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realPower",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realCurrent",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realImpedance",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realFrequency",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"reactivePower",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"reactiveCurrent",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"reactiveImpedance",/* Member name */
            {
                8,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"reactiveFrequency",/* Member name */
            {
                9,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadEstimate_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadEstimate", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            10, /* Number of members */
            tms_LoadEstimate_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadEstimate*/

    if (is_initialized) {
        return &tms_LoadEstimate_g_tc;
    }

    tms_LoadEstimate_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadEstimate_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_LoadEstimate_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[8]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadEstimate_g_tc_members[9]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;

    /* Initialize the values for member annotations. */

    tms_LoadEstimate_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[5]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[5]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[5]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[5]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[5]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[6]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[6]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[6]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[6]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[6]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[7]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[7]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[7]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[7]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[7]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[8]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[8]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[8]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[8]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[8]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[8]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc_members[9]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[9]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadEstimate_g_tc_members[9]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[9]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadEstimate_g_tc_members[9]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadEstimate_g_tc_members[9]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadEstimate_g_tc._data._sampleAccessInfo =
    tms_LoadEstimate_get_sample_access_info();
    tms_LoadEstimate_g_tc._data._typePlugin =
    tms_LoadEstimate_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadEstimate_g_tc;
}

#define TSeq tms_LoadEstimateSeq
#define T tms_LoadEstimate
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadEstimate_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadEstimate_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadEstimateSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadEstimateSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadEstimate_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadEstimate_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadEstimate *sample;

    static RTIXCdrMemberAccessInfo tms_LoadEstimate_g_memberAccessInfos[10] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadEstimate_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadEstimate_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadEstimate);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadEstimate_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->centerFrequency - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realPower - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realCurrent - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realImpedance - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realFrequency - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->reactivePower - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->reactiveCurrent - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[8].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->reactiveImpedance - (char *)sample);

    tms_LoadEstimate_g_memberAccessInfos[9].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->reactiveFrequency - (char *)sample);

    tms_LoadEstimate_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadEstimate_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadEstimate);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadEstimate_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadEstimate_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadEstimate_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadEstimate_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadEstimate_get_member_value_pointer;

    tms_LoadEstimate_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadEstimate_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadEstimate_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadEstimate_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadEstimate_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadEstimate_finalize_w_return,
        NULL
    };

    return &tms_LoadEstimate_g_typePlugin;
}
#endif

RTIBool tms_LoadEstimate_initialize(
    tms_LoadEstimate* sample) {
    return tms_LoadEstimate_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadEstimate_initialize_ex(
    tms_LoadEstimate* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadEstimate_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadEstimate_initialize_w_params(
    tms_LoadEstimate* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->centerFrequency = 0.0f;

    sample->realPower = 0.0f;

    sample->realCurrent = 0.0f;

    sample->realImpedance = 0.0f;

    sample->realFrequency = 0.0f;

    sample->reactivePower = 0.0f;

    sample->reactiveCurrent = 0.0f;

    sample->reactiveImpedance = 0.0f;

    sample->reactiveFrequency = 0.0f;

    return RTI_TRUE;
}

RTIBool tms_LoadEstimate_finalize_w_return(
    tms_LoadEstimate* sample)
{
    tms_LoadEstimate_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadEstimate_finalize(
    tms_LoadEstimate* sample)
{

    tms_LoadEstimate_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadEstimate_finalize_ex(
    tms_LoadEstimate* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadEstimate_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadEstimate_finalize_w_params(
    tms_LoadEstimate* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

}

void tms_LoadEstimate_finalize_optional_members(
    tms_LoadEstimate* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadEstimate_copy(
    tms_LoadEstimate* dst,
    const tms_LoadEstimate* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->centerFrequency, &src->centerFrequency)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->realPower, &src->realPower)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->realCurrent, &src->realCurrent)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->realImpedance, &src->realImpedance)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->realFrequency, &src->realFrequency)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->reactivePower, &src->reactivePower)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->reactiveCurrent, &src->reactiveCurrent)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->reactiveImpedance, &src->reactiveImpedance)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->reactiveFrequency, &src->reactiveFrequency)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadEstimate' sequence class.
*/
#define T tms_LoadEstimate
#define TSeq tms_LoadEstimateSeq

#define T_initialize_w_params tms_LoadEstimate_initialize_w_params

#define T_finalize_w_params   tms_LoadEstimate_finalize_w_params
#define T_copy       tms_LoadEstimate_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadChangeTYPENAME = "tms::LoadChange";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadChange_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadChange_g_tc_members[9]=
    {

        {
            (char *)"initPowerMin",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"initPowerMax",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"transPowerMin",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"transPowerMax",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"transSlope",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"transDuration",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"finalPowerMin",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"finalPowerMax",/* Member name */
            {
                7,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"finalLoadEstimate",/* Member name */
            {
                8,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadChange_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadChange", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            9, /* Number of members */
            tms_LoadChange_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadChange*/

    if (is_initialized) {
        return &tms_LoadChange_g_tc;
    }

    tms_LoadChange_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadChange_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[7]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_LoadChange_g_tc_members[8]._representation._typeCode = (RTICdrTypeCode *)tms_LoadEstimate_get_typecode();

    /* Initialize the values for member annotations. */
    tms_LoadChange_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[0]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[0]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[0]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[0]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[0]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[3]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[3]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[3]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[3]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[3]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[4]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[4]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[4]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[4]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[4]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[5]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[5]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[5]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[5]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[5]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[6]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[6]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[6]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[6]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[6]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc_members[7]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[7]._annotations._defaultValue._u.float_value = 0.0f;
    tms_LoadChange_g_tc_members[7]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[7]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_LoadChange_g_tc_members[7]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_LoadChange_g_tc_members[7]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_LoadChange_g_tc._data._sampleAccessInfo =
    tms_LoadChange_get_sample_access_info();
    tms_LoadChange_g_tc._data._typePlugin =
    tms_LoadChange_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadChange_g_tc;
}

#define TSeq tms_LoadChangeSeq
#define T tms_LoadChange
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadChange_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadChange_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadChangeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadChangeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadChange_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadChange_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadChange *sample;

    static RTIXCdrMemberAccessInfo tms_LoadChange_g_memberAccessInfos[9] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadChange_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadChange_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadChange);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadChange_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->initPowerMin - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->initPowerMax - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->transPowerMin - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->transPowerMax - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->transSlope - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->transDuration - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->finalPowerMin - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[7].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->finalPowerMax - (char *)sample);

    tms_LoadChange_g_memberAccessInfos[8].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->finalLoadEstimate - (char *)sample);

    tms_LoadChange_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadChange_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadChange);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadChange_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadChange_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadChange_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadChange_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadChange_get_member_value_pointer;

    tms_LoadChange_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadChange_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadChange_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadChange_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadChange_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadChange_finalize_w_return,
        NULL
    };

    return &tms_LoadChange_g_typePlugin;
}
#endif

RTIBool tms_LoadChange_initialize(
    tms_LoadChange* sample) {
    return tms_LoadChange_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadChange_initialize_ex(
    tms_LoadChange* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadChange_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadChange_initialize_w_params(
    tms_LoadChange* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->initPowerMin = 0.0f;

    sample->initPowerMax = 0.0f;

    sample->transPowerMin = 0.0f;

    sample->transPowerMax = 0.0f;

    sample->transSlope = 0.0f;

    sample->transDuration = 0.0f;

    sample->finalPowerMin = 0.0f;

    sample->finalPowerMax = 0.0f;

    if (!tms_LoadEstimate_initialize_w_params(&sample->finalLoadEstimate,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_LoadChange_finalize_w_return(
    tms_LoadChange* sample)
{
    tms_LoadChange_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadChange_finalize(
    tms_LoadChange* sample)
{

    tms_LoadChange_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadChange_finalize_ex(
    tms_LoadChange* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadChange_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadChange_finalize_w_params(
    tms_LoadChange* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_LoadEstimate_finalize_w_params(&sample->finalLoadEstimate,deallocParams);

}

void tms_LoadChange_finalize_optional_members(
    tms_LoadChange* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadChange_copy(
    tms_LoadChange* dst,
    const tms_LoadChange* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!RTICdrType_copyFloat (
            &dst->initPowerMin, &src->initPowerMin)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->initPowerMax, &src->initPowerMax)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->transPowerMin, &src->transPowerMin)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->transPowerMax, &src->transPowerMax)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->transSlope, &src->transSlope)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->transDuration, &src->transDuration)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->finalPowerMin, &src->finalPowerMin)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->finalPowerMax, &src->finalPowerMax)) { 
            return RTI_FALSE;
        }
        if (!tms_LoadEstimate_copy(
            &dst->finalLoadEstimate,(const tms_LoadEstimate*)&src->finalLoadEstimate)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadChange' sequence class.
*/
#define T tms_LoadChange
#define TSeq tms_LoadChangeSeq

#define T_initialize_w_params tms_LoadChange_initialize_w_params

#define T_finalize_w_params   tms_LoadChange_finalize_w_params
#define T_copy       tms_LoadChange_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_LoadChangeRequestTYPENAME = "tms::LoadChangeRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_LoadChangeRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_LoadChangeRequest_g_tc_members[2]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"desiredTransition",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_LoadChangeRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::LoadChangeRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            2, /* Number of members */
            tms_LoadChangeRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_LoadChangeRequest*/

    if (is_initialized) {
        return &tms_LoadChangeRequest_g_tc;
    }

    tms_LoadChangeRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_LoadChangeRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_LoadChangeRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_LoadChange_get_typecode();

    /* Initialize the values for member annotations. */

    tms_LoadChangeRequest_g_tc._data._sampleAccessInfo =
    tms_LoadChangeRequest_get_sample_access_info();
    tms_LoadChangeRequest_g_tc._data._typePlugin =
    tms_LoadChangeRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_LoadChangeRequest_g_tc;
}

#define TSeq tms_LoadChangeRequestSeq
#define T tms_LoadChangeRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_LoadChangeRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_LoadChangeRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_LoadChangeRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_LoadChangeRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_LoadChangeRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_LoadChangeRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_LoadChangeRequest *sample;

    static RTIXCdrMemberAccessInfo tms_LoadChangeRequest_g_memberAccessInfos[2] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_LoadChangeRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_LoadChangeRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_LoadChangeRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_LoadChangeRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_LoadChangeRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->desiredTransition - (char *)sample);

    tms_LoadChangeRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_LoadChangeRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_LoadChangeRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_LoadChangeRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_LoadChangeRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_LoadChangeRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_LoadChangeRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_LoadChangeRequest_get_member_value_pointer;

    tms_LoadChangeRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_LoadChangeRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_LoadChangeRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_LoadChangeRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_LoadChangeRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_LoadChangeRequest_finalize_w_return,
        NULL
    };

    return &tms_LoadChangeRequest_g_typePlugin;
}
#endif

RTIBool tms_LoadChangeRequest_initialize(
    tms_LoadChangeRequest* sample) {
    return tms_LoadChangeRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_LoadChangeRequest_initialize_ex(
    tms_LoadChangeRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_LoadChangeRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_LoadChangeRequest_initialize_w_params(
    tms_LoadChangeRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_LoadChange_initialize_w_params(&sample->desiredTransition,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_LoadChangeRequest_finalize_w_return(
    tms_LoadChangeRequest* sample)
{
    tms_LoadChangeRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_LoadChangeRequest_finalize(
    tms_LoadChangeRequest* sample)
{

    tms_LoadChangeRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_LoadChangeRequest_finalize_ex(
    tms_LoadChangeRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_LoadChangeRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_LoadChangeRequest_finalize_w_params(
    tms_LoadChangeRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_LoadChange_finalize_w_params(&sample->desiredTransition,deallocParams);

}

void tms_LoadChangeRequest_finalize_optional_members(
    tms_LoadChangeRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_LoadChangeRequest_copy(
    tms_LoadChangeRequest* dst,
    const tms_LoadChangeRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_LoadChange_copy(
            &dst->desiredTransition,(const tms_LoadChange*)&src->desiredTransition)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_LoadChangeRequest' sequence class.
*/
#define T tms_LoadChangeRequest
#define TSeq tms_LoadChangeRequestSeq

#define T_initialize_w_params tms_LoadChangeRequest_initialize_w_params

#define T_finalize_w_params   tms_LoadChangeRequest_finalize_w_params
#define T_copy       tms_LoadChangeRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_SimulationCapabilitiesTYPENAME = "tms::SimulationCapabilities";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_SimulationCapabilities_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_SimulationCapabilities_g_tc_members[5]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"scaledTime",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"scaledTimeMax",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"steppedTime",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realStepDurationMin",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_SimulationCapabilities_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::SimulationCapabilities", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            5, /* Number of members */
            tms_SimulationCapabilities_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_SimulationCapabilities*/

    if (is_initialized) {
        return &tms_SimulationCapabilities_g_tc;
    }

    tms_SimulationCapabilities_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_SimulationCapabilities_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_SimulationCapabilities_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_SimulationCapabilities_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_SimulationCapabilities_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_boolean_w_new;
    tms_SimulationCapabilities_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();

    /* Initialize the values for member annotations. */

    tms_SimulationCapabilities_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_SimulationCapabilities_g_tc_members[1]._annotations._defaultValue._u.boolean_value = 0;

    tms_SimulationCapabilities_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_SimulationCapabilities_g_tc_members[2]._annotations._defaultValue._u.float_value = 0.0f;
    tms_SimulationCapabilities_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_SimulationCapabilities_g_tc_members[2]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_SimulationCapabilities_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_SimulationCapabilities_g_tc_members[2]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_SimulationCapabilities_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_BOOLEAN;
    tms_SimulationCapabilities_g_tc_members[3]._annotations._defaultValue._u.boolean_value = 0;

    tms_SimulationCapabilities_g_tc._data._sampleAccessInfo =
    tms_SimulationCapabilities_get_sample_access_info();
    tms_SimulationCapabilities_g_tc._data._typePlugin =
    tms_SimulationCapabilities_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_SimulationCapabilities_g_tc;
}

#define TSeq tms_SimulationCapabilitiesSeq
#define T tms_SimulationCapabilities
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_SimulationCapabilities_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_SimulationCapabilities_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_SimulationCapabilitiesSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_SimulationCapabilitiesSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_SimulationCapabilities_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_SimulationCapabilities_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_SimulationCapabilities *sample;

    static RTIXCdrMemberAccessInfo tms_SimulationCapabilities_g_memberAccessInfos[5] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_SimulationCapabilities_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_SimulationCapabilities_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_SimulationCapabilities);
    if (sample == NULL) {
        return NULL;
    }

    tms_SimulationCapabilities_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_SimulationCapabilities_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->scaledTime - (char *)sample);

    tms_SimulationCapabilities_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->scaledTimeMax - (char *)sample);

    tms_SimulationCapabilities_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->steppedTime - (char *)sample);

    tms_SimulationCapabilities_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realStepDurationMin - (char *)sample);

    tms_SimulationCapabilities_g_sampleAccessInfo.memberAccessInfos = 
    tms_SimulationCapabilities_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_SimulationCapabilities);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_SimulationCapabilities_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_SimulationCapabilities_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_SimulationCapabilities_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_SimulationCapabilities_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_SimulationCapabilities_get_member_value_pointer;

    tms_SimulationCapabilities_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_SimulationCapabilities_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_SimulationCapabilities_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_SimulationCapabilities_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_SimulationCapabilities_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_SimulationCapabilities_finalize_w_return,
        NULL
    };

    return &tms_SimulationCapabilities_g_typePlugin;
}
#endif

RTIBool tms_SimulationCapabilities_initialize(
    tms_SimulationCapabilities* sample) {
    return tms_SimulationCapabilities_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_SimulationCapabilities_initialize_ex(
    tms_SimulationCapabilities* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_SimulationCapabilities_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_SimulationCapabilities_initialize_w_params(
    tms_SimulationCapabilities* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->scaledTime = 0;

    sample->scaledTimeMax = 0.0f;

    sample->steppedTime = 0;

    if (!tms_ClockMonotonic_initialize_w_params(&sample->realStepDurationMin,
    allocParams)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}

RTIBool tms_SimulationCapabilities_finalize_w_return(
    tms_SimulationCapabilities* sample)
{
    tms_SimulationCapabilities_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_SimulationCapabilities_finalize(
    tms_SimulationCapabilities* sample)
{

    tms_SimulationCapabilities_finalize_ex(sample,RTI_TRUE);
}

void tms_SimulationCapabilities_finalize_ex(
    tms_SimulationCapabilities* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_SimulationCapabilities_finalize_w_params(
        sample,&deallocParams);
}

void tms_SimulationCapabilities_finalize_w_params(
    tms_SimulationCapabilities* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->realStepDurationMin,deallocParams);

}

void tms_SimulationCapabilities_finalize_optional_members(
    tms_SimulationCapabilities* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_SimulationCapabilities_copy(
    tms_SimulationCapabilities* dst,
    const tms_SimulationCapabilities* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyBoolean (
            &dst->scaledTime, &src->scaledTime)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyFloat (
            &dst->scaledTimeMax, &src->scaledTimeMax)) { 
            return RTI_FALSE;
        }
        if (!RTICdrType_copyBoolean (
            &dst->steppedTime, &src->steppedTime)) { 
            return RTI_FALSE;
        }
        if (!tms_ClockMonotonic_copy(
            &dst->realStepDurationMin,(const tms_ClockMonotonic*)&src->realStepDurationMin)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_SimulationCapabilities' sequence class.
*/
#define T tms_SimulationCapabilities
#define TSeq tms_SimulationCapabilitiesSeq

#define T_initialize_w_params tms_SimulationCapabilities_initialize_w_params

#define T_finalize_w_params   tms_SimulationCapabilities_finalize_w_params
#define T_copy       tms_SimulationCapabilities_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_TimeModeTYPENAME = "tms::TimeMode";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_TimeMode_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_TimeMode_g_tc_members[3]=
    {

        {
            (char *)"TM_REAL_TIME",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            TM_REAL_TIME, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"TM_SCALED_TIME",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            TM_SCALED_TIME, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"TM_STEPPED_TIME",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            TM_STEPPED_TIME, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_TimeMode_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::TimeMode", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_TimeMode_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_TimeMode*/

    if (is_initialized) {
        return &tms_TimeMode_g_tc;
    }

    tms_TimeMode_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_TimeMode_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_TimeMode_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_TimeMode_g_tc._data._sampleAccessInfo =
    tms_TimeMode_get_sample_access_info();
    tms_TimeMode_g_tc._data._typePlugin =
    tms_TimeMode_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_TimeMode_g_tc;
}

#define TSeq tms_TimeModeSeq
#define T tms_TimeMode
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_TimeMode_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_TimeMode_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_TimeModeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_TimeModeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_TimeMode_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_TimeMode_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_TimeMode_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_TimeMode_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_TimeMode_g_sampleAccessInfo;
    }

    tms_TimeMode_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_TimeMode_g_sampleAccessInfo.memberAccessInfos = 
    tms_TimeMode_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_TimeMode);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_TimeMode_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_TimeMode_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_TimeMode_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_TimeMode_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_TimeMode_get_member_value_pointer;

    tms_TimeMode_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_TimeMode_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_TimeMode_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_TimeMode_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_TimeMode_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_TimeMode_finalize_w_return,
        NULL
    };

    return &tms_TimeMode_g_typePlugin;
}
#endif

RTIBool tms_TimeMode_initialize(
    tms_TimeMode* sample) {
    *sample = TM_REAL_TIME;
    return RTI_TRUE;
}

RTIBool tms_TimeMode_initialize_ex(
    tms_TimeMode* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_TimeMode_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_TimeMode_initialize_w_params(
    tms_TimeMode* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = TM_REAL_TIME;
    return RTI_TRUE;
}

RTIBool tms_TimeMode_finalize_w_return(
    tms_TimeMode* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_TimeMode_finalize(
    tms_TimeMode* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_TimeMode_finalize_ex(
    tms_TimeMode* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_TimeMode_finalize_w_params(
        sample,&deallocParams);
}

void tms_TimeMode_finalize_w_params(
    tms_TimeMode* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_TimeMode_finalize_optional_members(
    tms_TimeMode* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_TimeMode_copy(
    tms_TimeMode* dst,
    const tms_TimeMode* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_TimeMode' sequence class.
*/
#define T tms_TimeMode
#define TSeq tms_TimeModeSeq

#define T_initialize_w_params tms_TimeMode_initialize_w_params

#define T_finalize_w_params   tms_TimeMode_finalize_w_params
#define T_copy       tms_TimeMode_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_TimeSchemeTYPENAME = "tms::TimeScheme";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_TimeScheme_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_TimeScheme_g_tc_members[7]=
    {

        {
            (char *)"mode",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"scale",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realBase",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"virtualBase",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"realStepDuration",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"virtualStepDuration",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"stepCount",/* Member name */
            {
                6,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_TimeScheme_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::TimeScheme", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            7, /* Number of members */
            tms_TimeScheme_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_TimeScheme*/

    if (is_initialized) {
        return &tms_TimeScheme_g_tc;
    }

    tms_TimeScheme_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_TimeScheme_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_TimeMode_get_typecode();
    tms_TimeScheme_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_float_w_new;
    tms_TimeScheme_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_ClockRealtime_get_typecode();
    tms_TimeScheme_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_TimeScheme_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_TimeScheme_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_TimeScheme_g_tc_members[6]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_long_w_new;

    /* Initialize the values for member annotations. */
    tms_TimeScheme_g_tc_members[0]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_TimeScheme_g_tc_members[0]._annotations._defaultValue._u.enumerated_value = 0;

    tms_TimeScheme_g_tc_members[1]._annotations._defaultValue._d = RTI_XCDR_TK_FLOAT;
    tms_TimeScheme_g_tc_members[1]._annotations._defaultValue._u.float_value = 0.0f;
    tms_TimeScheme_g_tc_members[1]._annotations._minValue._d = RTI_XCDR_TK_FLOAT;
    tms_TimeScheme_g_tc_members[1]._annotations._minValue._u.float_value = RTIXCdrFloat_MIN;
    tms_TimeScheme_g_tc_members[1]._annotations._maxValue._d = RTI_XCDR_TK_FLOAT;
    tms_TimeScheme_g_tc_members[1]._annotations._maxValue._u.float_value = RTIXCdrFloat_MAX;

    tms_TimeScheme_g_tc_members[6]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_TimeScheme_g_tc_members[6]._annotations._defaultValue._u.long_value = 0;
    tms_TimeScheme_g_tc_members[6]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_TimeScheme_g_tc_members[6]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_TimeScheme_g_tc_members[6]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_TimeScheme_g_tc_members[6]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_TimeScheme_g_tc._data._sampleAccessInfo =
    tms_TimeScheme_get_sample_access_info();
    tms_TimeScheme_g_tc._data._typePlugin =
    tms_TimeScheme_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_TimeScheme_g_tc;
}

#define TSeq tms_TimeSchemeSeq
#define T tms_TimeScheme
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_TimeScheme_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_TimeScheme_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_TimeSchemeSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_TimeSchemeSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_TimeScheme_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_TimeScheme_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_TimeScheme *sample;

    static RTIXCdrMemberAccessInfo tms_TimeScheme_g_memberAccessInfos[7] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_TimeScheme_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_TimeScheme_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_TimeScheme);
    if (sample == NULL) {
        return NULL;
    }

    tms_TimeScheme_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->mode - (char *)sample);

    tms_TimeScheme_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->scale - (char *)sample);

    tms_TimeScheme_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realBase - (char *)sample);

    tms_TimeScheme_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->virtualBase - (char *)sample);

    tms_TimeScheme_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->realStepDuration - (char *)sample);

    tms_TimeScheme_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->virtualStepDuration - (char *)sample);

    tms_TimeScheme_g_memberAccessInfos[6].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->stepCount - (char *)sample);

    tms_TimeScheme_g_sampleAccessInfo.memberAccessInfos = 
    tms_TimeScheme_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_TimeScheme);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_TimeScheme_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_TimeScheme_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_TimeScheme_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_TimeScheme_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_TimeScheme_get_member_value_pointer;

    tms_TimeScheme_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_TimeScheme_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_TimeScheme_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_TimeScheme_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_TimeScheme_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_TimeScheme_finalize_w_return,
        NULL
    };

    return &tms_TimeScheme_g_typePlugin;
}
#endif

RTIBool tms_TimeScheme_initialize(
    tms_TimeScheme* sample) {
    return tms_TimeScheme_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_TimeScheme_initialize_ex(
    tms_TimeScheme* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_TimeScheme_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_TimeScheme_initialize_w_params(
    tms_TimeScheme* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    sample->mode = TM_REAL_TIME;

    sample->scale = 0.0f;

    if (!tms_ClockRealtime_initialize_w_params(&sample->realBase,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockMonotonic_initialize_w_params(&sample->virtualBase,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockMonotonic_initialize_w_params(&sample->realStepDuration,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockMonotonic_initialize_w_params(&sample->virtualStepDuration,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->stepCount = 0;

    return RTI_TRUE;
}

RTIBool tms_TimeScheme_finalize_w_return(
    tms_TimeScheme* sample)
{
    tms_TimeScheme_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_TimeScheme_finalize(
    tms_TimeScheme* sample)
{

    tms_TimeScheme_finalize_ex(sample,RTI_TRUE);
}

void tms_TimeScheme_finalize_ex(
    tms_TimeScheme* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_TimeScheme_finalize_w_params(
        sample,&deallocParams);
}

void tms_TimeScheme_finalize_w_params(
    tms_TimeScheme* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_TimeMode_finalize_w_params(&sample->mode,deallocParams);

    tms_ClockRealtime_finalize_w_params(&sample->realBase,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->virtualBase,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->realStepDuration,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->virtualStepDuration,deallocParams);

}

void tms_TimeScheme_finalize_optional_members(
    tms_TimeScheme* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_TimeScheme_copy(
    tms_TimeScheme* dst,
    const tms_TimeScheme* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_TimeMode_copy(
            &dst->mode,(const tms_TimeMode*)&src->mode)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyFloat (
            &dst->scale, &src->scale)) { 
            return RTI_FALSE;
        }
        if (!tms_ClockRealtime_copy(
            &dst->realBase,(const tms_ClockRealtime*)&src->realBase)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->virtualBase,(const tms_ClockMonotonic*)&src->virtualBase)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->realStepDuration,(const tms_ClockMonotonic*)&src->realStepDuration)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->virtualStepDuration,(const tms_ClockMonotonic*)&src->virtualStepDuration)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyLong (
            &dst->stepCount, &src->stepCount)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_TimeScheme' sequence class.
*/
#define T tms_TimeScheme
#define TSeq tms_TimeSchemeSeq

#define T_initialize_w_params tms_TimeScheme_initialize_w_params

#define T_finalize_w_params   tms_TimeScheme_finalize_w_params
#define T_copy       tms_TimeScheme_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_TimeAdvanceTYPENAME = "tms::TimeAdvance";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_TimeAdvance_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_TimeAdvance_g_tc_members[3]=
    {

        {
            (char *)"deviceId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"virtualTime",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"stepCount",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_TimeAdvance_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::TimeAdvance", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_TimeAdvance_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_TimeAdvance*/

    if (is_initialized) {
        return &tms_TimeAdvance_g_tc;
    }

    tms_TimeAdvance_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_TimeAdvance_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_TimeAdvance_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_ClockMonotonic_get_typecode();
    tms_TimeAdvance_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)&DDS_g_tc_long_w_new;

    /* Initialize the values for member annotations. */

    tms_TimeAdvance_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_LONG;
    tms_TimeAdvance_g_tc_members[2]._annotations._defaultValue._u.long_value = 0;
    tms_TimeAdvance_g_tc_members[2]._annotations._minValue._d = RTI_XCDR_TK_LONG;
    tms_TimeAdvance_g_tc_members[2]._annotations._minValue._u.long_value = RTIXCdrLong_MIN;
    tms_TimeAdvance_g_tc_members[2]._annotations._maxValue._d = RTI_XCDR_TK_LONG;
    tms_TimeAdvance_g_tc_members[2]._annotations._maxValue._u.long_value = RTIXCdrLong_MAX;

    tms_TimeAdvance_g_tc._data._sampleAccessInfo =
    tms_TimeAdvance_get_sample_access_info();
    tms_TimeAdvance_g_tc._data._typePlugin =
    tms_TimeAdvance_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_TimeAdvance_g_tc;
}

#define TSeq tms_TimeAdvanceSeq
#define T tms_TimeAdvance
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_TimeAdvance_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_TimeAdvance_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_TimeAdvanceSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_TimeAdvanceSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_TimeAdvance_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_TimeAdvance_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_TimeAdvance *sample;

    static RTIXCdrMemberAccessInfo tms_TimeAdvance_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_TimeAdvance_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_TimeAdvance_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_TimeAdvance);
    if (sample == NULL) {
        return NULL;
    }

    tms_TimeAdvance_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_TimeAdvance_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->virtualTime - (char *)sample);

    tms_TimeAdvance_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->stepCount - (char *)sample);

    tms_TimeAdvance_g_sampleAccessInfo.memberAccessInfos = 
    tms_TimeAdvance_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_TimeAdvance);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_TimeAdvance_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_TimeAdvance_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_TimeAdvance_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_TimeAdvance_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_TimeAdvance_get_member_value_pointer;

    tms_TimeAdvance_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_TimeAdvance_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_TimeAdvance_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_TimeAdvance_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_TimeAdvance_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_TimeAdvance_finalize_w_return,
        NULL
    };

    return &tms_TimeAdvance_g_typePlugin;
}
#endif

RTIBool tms_TimeAdvance_initialize(
    tms_TimeAdvance* sample) {
    return tms_TimeAdvance_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_TimeAdvance_initialize_ex(
    tms_TimeAdvance* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_TimeAdvance_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_TimeAdvance_initialize_w_params(
    tms_TimeAdvance* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_ClockMonotonic_initialize_w_params(&sample->virtualTime,
    allocParams)) {
        return RTI_FALSE;
    }

    sample->stepCount = 0;

    return RTI_TRUE;
}

RTIBool tms_TimeAdvance_finalize_w_return(
    tms_TimeAdvance* sample)
{
    tms_TimeAdvance_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_TimeAdvance_finalize(
    tms_TimeAdvance* sample)
{

    tms_TimeAdvance_finalize_ex(sample,RTI_TRUE);
}

void tms_TimeAdvance_finalize_ex(
    tms_TimeAdvance* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_TimeAdvance_finalize_w_params(
        sample,&deallocParams);
}

void tms_TimeAdvance_finalize_w_params(
    tms_TimeAdvance* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_ClockMonotonic_finalize_w_params(&sample->virtualTime,deallocParams);

}

void tms_TimeAdvance_finalize_optional_members(
    tms_TimeAdvance* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_TimeAdvance_copy(
    tms_TimeAdvance* dst,
    const tms_TimeAdvance* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_ClockMonotonic_copy(
            &dst->virtualTime,(const tms_ClockMonotonic*)&src->virtualTime)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyLong (
            &dst->stepCount, &src->stepCount)) { 
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_TimeAdvance' sequence class.
*/
#define T tms_TimeAdvance
#define TSeq tms_TimeAdvanceSeq

#define T_initialize_w_params tms_TimeAdvance_initialize_w_params

#define T_finalize_w_params   tms_TimeAdvance_finalize_w_params
#define T_copy       tms_TimeAdvance_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_MicrogridMembershipTYPENAME = "tms::MicrogridMembership";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_MicrogridMembership_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_MicrogridMembership_g_tc_members[3]=
    {

        {
            (char *)"MM_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            MM_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"MM_JOIN",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            MM_JOIN, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"MM_LEAVE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            MM_LEAVE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_MicrogridMembership_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::MicrogridMembership", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_MicrogridMembership_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_MicrogridMembership*/

    if (is_initialized) {
        return &tms_MicrogridMembership_g_tc;
    }

    tms_MicrogridMembership_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_MicrogridMembership_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_MicrogridMembership_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_MicrogridMembership_g_tc._data._sampleAccessInfo =
    tms_MicrogridMembership_get_sample_access_info();
    tms_MicrogridMembership_g_tc._data._typePlugin =
    tms_MicrogridMembership_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_MicrogridMembership_g_tc;
}

#define TSeq tms_MicrogridMembershipSeq
#define T tms_MicrogridMembership
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_MicrogridMembership_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_MicrogridMembership_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_MicrogridMembershipSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_MicrogridMembershipSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_MicrogridMembership_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_MicrogridMembership_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_MicrogridMembership_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_MicrogridMembership_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembership_g_sampleAccessInfo;
    }

    tms_MicrogridMembership_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_MicrogridMembership_g_sampleAccessInfo.memberAccessInfos = 
    tms_MicrogridMembership_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_MicrogridMembership);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_MicrogridMembership_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_MicrogridMembership_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_MicrogridMembership_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_MicrogridMembership_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_MicrogridMembership_get_member_value_pointer;

    tms_MicrogridMembership_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembership_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_MicrogridMembership_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_MicrogridMembership_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_MicrogridMembership_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_MicrogridMembership_finalize_w_return,
        NULL
    };

    return &tms_MicrogridMembership_g_typePlugin;
}
#endif

RTIBool tms_MicrogridMembership_initialize(
    tms_MicrogridMembership* sample) {
    *sample = MM_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_MicrogridMembership_initialize_ex(
    tms_MicrogridMembership* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_MicrogridMembership_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_MicrogridMembership_initialize_w_params(
    tms_MicrogridMembership* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = MM_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_MicrogridMembership_finalize_w_return(
    tms_MicrogridMembership* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_MicrogridMembership_finalize(
    tms_MicrogridMembership* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_MicrogridMembership_finalize_ex(
    tms_MicrogridMembership* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_MicrogridMembership_finalize_w_params(
        sample,&deallocParams);
}

void tms_MicrogridMembership_finalize_w_params(
    tms_MicrogridMembership* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_MicrogridMembership_finalize_optional_members(
    tms_MicrogridMembership* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_MicrogridMembership_copy(
    tms_MicrogridMembership* dst,
    const tms_MicrogridMembership* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_MicrogridMembership' sequence class.
*/
#define T tms_MicrogridMembership
#define TSeq tms_MicrogridMembershipSeq

#define T_initialize_w_params tms_MicrogridMembership_initialize_w_params

#define T_finalize_w_params   tms_MicrogridMembership_finalize_w_params
#define T_copy       tms_MicrogridMembership_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_MicrogridMembershipRequestTYPENAME = "tms::MicrogridMembershipRequest";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_MicrogridMembershipRequest_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_MicrogridMembershipRequest_g_tc_members[3]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"membership",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_MicrogridMembershipRequest_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::MicrogridMembershipRequest", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            3, /* Number of members */
            tms_MicrogridMembershipRequest_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_MicrogridMembershipRequest*/

    if (is_initialized) {
        return &tms_MicrogridMembershipRequest_g_tc;
    }

    tms_MicrogridMembershipRequest_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_MicrogridMembershipRequest_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_MicrogridMembershipRequest_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_MicrogridMembershipRequest_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_MicrogridMembership_get_typecode();

    /* Initialize the values for member annotations. */

    tms_MicrogridMembershipRequest_g_tc_members[2]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_MicrogridMembershipRequest_g_tc_members[2]._annotations._defaultValue._u.enumerated_value = 0;

    tms_MicrogridMembershipRequest_g_tc._data._sampleAccessInfo =
    tms_MicrogridMembershipRequest_get_sample_access_info();
    tms_MicrogridMembershipRequest_g_tc._data._typePlugin =
    tms_MicrogridMembershipRequest_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_MicrogridMembershipRequest_g_tc;
}

#define TSeq tms_MicrogridMembershipRequestSeq
#define T tms_MicrogridMembershipRequest
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_MicrogridMembershipRequest_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_MicrogridMembershipRequest_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_MicrogridMembershipRequestSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_MicrogridMembershipRequestSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_MicrogridMembershipRequest_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_MicrogridMembershipRequest_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_MicrogridMembershipRequest *sample;

    static RTIXCdrMemberAccessInfo tms_MicrogridMembershipRequest_g_memberAccessInfos[3] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_MicrogridMembershipRequest_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembershipRequest_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_MicrogridMembershipRequest);
    if (sample == NULL) {
        return NULL;
    }

    tms_MicrogridMembershipRequest_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_MicrogridMembershipRequest_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_MicrogridMembershipRequest_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->membership - (char *)sample);

    tms_MicrogridMembershipRequest_g_sampleAccessInfo.memberAccessInfos = 
    tms_MicrogridMembershipRequest_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_MicrogridMembershipRequest);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_MicrogridMembershipRequest_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_MicrogridMembershipRequest_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_MicrogridMembershipRequest_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_MicrogridMembershipRequest_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_MicrogridMembershipRequest_get_member_value_pointer;

    tms_MicrogridMembershipRequest_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembershipRequest_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_MicrogridMembershipRequest_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_MicrogridMembershipRequest_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_MicrogridMembershipRequest_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_MicrogridMembershipRequest_finalize_w_return,
        NULL
    };

    return &tms_MicrogridMembershipRequest_g_typePlugin;
}
#endif

RTIBool tms_MicrogridMembershipRequest_initialize(
    tms_MicrogridMembershipRequest* sample) {
    return tms_MicrogridMembershipRequest_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_MicrogridMembershipRequest_initialize_ex(
    tms_MicrogridMembershipRequest* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_MicrogridMembershipRequest_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_MicrogridMembershipRequest_initialize_w_params(
    tms_MicrogridMembershipRequest* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->membership = MM_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_MicrogridMembershipRequest_finalize_w_return(
    tms_MicrogridMembershipRequest* sample)
{
    tms_MicrogridMembershipRequest_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_MicrogridMembershipRequest_finalize(
    tms_MicrogridMembershipRequest* sample)
{

    tms_MicrogridMembershipRequest_finalize_ex(sample,RTI_TRUE);
}

void tms_MicrogridMembershipRequest_finalize_ex(
    tms_MicrogridMembershipRequest* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_MicrogridMembershipRequest_finalize_w_params(
        sample,&deallocParams);
}

void tms_MicrogridMembershipRequest_finalize_w_params(
    tms_MicrogridMembershipRequest* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_MicrogridMembership_finalize_w_params(&sample->membership,deallocParams);

}

void tms_MicrogridMembershipRequest_finalize_optional_members(
    tms_MicrogridMembershipRequest* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_MicrogridMembershipRequest_copy(
    tms_MicrogridMembershipRequest* dst,
    const tms_MicrogridMembershipRequest* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_MicrogridMembership_copy(
            &dst->membership,(const tms_MicrogridMembership*)&src->membership)) {
            return RTI_FALSE;
        } 

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_MicrogridMembershipRequest' sequence class.
*/
#define T tms_MicrogridMembershipRequest
#define TSeq tms_MicrogridMembershipRequestSeq

#define T_initialize_w_params tms_MicrogridMembershipRequest_initialize_w_params

#define T_finalize_w_params   tms_MicrogridMembershipRequest_finalize_w_params
#define T_copy       tms_MicrogridMembershipRequest_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_MicrogridMembershipResultTYPENAME = "tms::MicrogridMembershipResult";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_MicrogridMembershipResult_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode_Member tms_MicrogridMembershipResult_g_tc_members[4]=
    {

        {
            (char *)"MMR_UNINITIALIZED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            MMR_UNINITIALIZED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"MMR_REPLACED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            MMR_REPLACED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"MMR_COMPLETE",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            MMR_COMPLETE, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"MMR_BLOCKED",/* Member name */
            {
                0, /* Ignored */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            MMR_BLOCKED, 
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PRIVATE_MEMBER,/* Member visibility */ 

            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_MicrogridMembershipResult_g_tc =
    {{
            DDS_TK_ENUM, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::MicrogridMembershipResult", /* Name */
            NULL,     /* Base class type code is assigned later */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            4, /* Number of members */
            tms_MicrogridMembershipResult_g_tc_members, /* Members */
            DDS_VM_NONE, /* Type Modifier */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_MicrogridMembershipResult*/

    if (is_initialized) {
        return &tms_MicrogridMembershipResult_g_tc;
    }

    tms_MicrogridMembershipResult_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    /* Initialize the values for annotations. */
    tms_MicrogridMembershipResult_g_tc._data._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_MicrogridMembershipResult_g_tc._data._annotations._defaultValue._u.long_value = 0;

    tms_MicrogridMembershipResult_g_tc._data._sampleAccessInfo =
    tms_MicrogridMembershipResult_get_sample_access_info();
    tms_MicrogridMembershipResult_g_tc._data._typePlugin =
    tms_MicrogridMembershipResult_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_MicrogridMembershipResult_g_tc;
}

#define TSeq tms_MicrogridMembershipResultSeq
#define T tms_MicrogridMembershipResult
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_MicrogridMembershipResult_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_MicrogridMembershipResult_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_MicrogridMembershipResultSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_MicrogridMembershipResultSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_MicrogridMembershipResult_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_MicrogridMembershipResult_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    static RTIXCdrMemberAccessInfo tms_MicrogridMembershipResult_g_memberAccessInfos[1] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_MicrogridMembershipResult_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembershipResult_g_sampleAccessInfo;
    }

    tms_MicrogridMembershipResult_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 0;

    tms_MicrogridMembershipResult_g_sampleAccessInfo.memberAccessInfos = 
    tms_MicrogridMembershipResult_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_MicrogridMembershipResult);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_MicrogridMembershipResult_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_MicrogridMembershipResult_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_MicrogridMembershipResult_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_MicrogridMembershipResult_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_MicrogridMembershipResult_get_member_value_pointer;

    tms_MicrogridMembershipResult_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembershipResult_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_MicrogridMembershipResult_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_MicrogridMembershipResult_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_MicrogridMembershipResult_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_MicrogridMembershipResult_finalize_w_return,
        NULL
    };

    return &tms_MicrogridMembershipResult_g_typePlugin;
}
#endif

RTIBool tms_MicrogridMembershipResult_initialize(
    tms_MicrogridMembershipResult* sample) {
    *sample = MMR_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_MicrogridMembershipResult_initialize_ex(
    tms_MicrogridMembershipResult* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_MicrogridMembershipResult_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_MicrogridMembershipResult_initialize_w_params(
    tms_MicrogridMembershipResult* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }
    *sample = MMR_UNINITIALIZED;
    return RTI_TRUE;
}

RTIBool tms_MicrogridMembershipResult_finalize_w_return(
    tms_MicrogridMembershipResult* sample)
{
    if (sample) {} /* To avoid warnings */

    return RTI_TRUE;
}

void tms_MicrogridMembershipResult_finalize(
    tms_MicrogridMembershipResult* sample)
{

    if (sample==NULL) {
        return;
    }
}

void tms_MicrogridMembershipResult_finalize_ex(
    tms_MicrogridMembershipResult* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_MicrogridMembershipResult_finalize_w_params(
        sample,&deallocParams);
}

void tms_MicrogridMembershipResult_finalize_w_params(
    tms_MicrogridMembershipResult* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

}

void tms_MicrogridMembershipResult_finalize_optional_members(
    tms_MicrogridMembershipResult* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_MicrogridMembershipResult_copy(
    tms_MicrogridMembershipResult* dst,
    const tms_MicrogridMembershipResult* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        return RTICdrType_copyEnum((RTICdrEnum *)dst, (RTICdrEnum *)src);

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_MicrogridMembershipResult' sequence class.
*/
#define T tms_MicrogridMembershipResult
#define TSeq tms_MicrogridMembershipResultSeq

#define T_initialize_w_params tms_MicrogridMembershipResult_initialize_w_params

#define T_finalize_w_params   tms_MicrogridMembershipResult_finalize_w_params
#define T_copy       tms_MicrogridMembershipResult_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

/* ========================================================================= */
const char *tms_MicrogridMembershipApprovalTYPENAME = "tms::MicrogridMembershipApproval";

#ifndef NDDS_STANDALONE_TYPE
DDS_TypeCode* tms_MicrogridMembershipApproval_get_typecode()
{
    static RTIBool is_initialized = RTI_FALSE;

    static DDS_TypeCode tms_MicrogridMembershipApproval_g_tc_hint_string = DDS_INITIALIZE_STRING_TYPECODE(((tms_MAXLEN_hint)));

    static DDS_TypeCode_Member tms_MicrogridMembershipApproval_g_tc_members[6]=
    {

        {
            (char *)"requestId",/* Member name */
            {
                0,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_KEY_MEMBER , /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"relatedRequestId",/* Member name */
            {
                1,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"deviceId",/* Member name */
            {
                2,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"membership",/* Member name */
            {
                3,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"result",/* Member name */
            {
                4,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }, 
        {
            (char *)"hint",/* Member name */
            {
                5,/* Representation ID */
                DDS_BOOLEAN_FALSE,/* Is a pointer? */
                -1, /* Bitfield bits */
                NULL/* Member type code is assigned later */
            },
            0, /* Ignored */
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            RTI_CDR_REQUIRED_MEMBER, /* Is a key? */
            DDS_PUBLIC_MEMBER,/* Member visibility */
            1,
            NULL, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER
        }
    };

    static DDS_TypeCode tms_MicrogridMembershipApproval_g_tc =
    {{
            DDS_TK_STRUCT, /* Kind */
            DDS_BOOLEAN_FALSE, /* Ignored */
            -1, /*Ignored*/
            (char *)"tms::MicrogridMembershipApproval", /* Name */
            NULL, /* Ignored */      
            0, /* Ignored */
            0, /* Ignored */
            NULL, /* Ignored */
            6, /* Number of members */
            tms_MicrogridMembershipApproval_g_tc_members, /* Members */
            DDS_VM_NONE, /* Ignored */
            RTICdrTypeCodeAnnotations_INITIALIZER,
            DDS_BOOLEAN_TRUE, /* _isCopyable */
            NULL, /* _sampleAccessInfo: assigned later */
            NULL /* _typePlugin: assigned later */
        }}; /* Type code for tms_MicrogridMembershipApproval*/

    if (is_initialized) {
        return &tms_MicrogridMembershipApproval_g_tc;
    }

    tms_MicrogridMembershipApproval_g_tc._data._annotations._allowedDataRepresentationMask = 5;

    tms_MicrogridMembershipApproval_g_tc_members[0]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_MicrogridMembershipApproval_g_tc_members[1]._representation._typeCode = (RTICdrTypeCode *)tms_SampleId_get_typecode();
    tms_MicrogridMembershipApproval_g_tc_members[2]._representation._typeCode = (RTICdrTypeCode *)tms_Fingerprint_get_typecode();
    tms_MicrogridMembershipApproval_g_tc_members[3]._representation._typeCode = (RTICdrTypeCode *)tms_MicrogridMembership_get_typecode();
    tms_MicrogridMembershipApproval_g_tc_members[4]._representation._typeCode = (RTICdrTypeCode *)tms_MicrogridMembershipResult_get_typecode();
    tms_MicrogridMembershipApproval_g_tc_members[5]._representation._typeCode = (RTICdrTypeCode *)&tms_MicrogridMembershipApproval_g_tc_hint_string;

    /* Initialize the values for member annotations. */

    tms_MicrogridMembershipApproval_g_tc_members[3]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_MicrogridMembershipApproval_g_tc_members[3]._annotations._defaultValue._u.enumerated_value = 0;

    tms_MicrogridMembershipApproval_g_tc_members[4]._annotations._defaultValue._d = RTI_XCDR_TK_ENUM;
    tms_MicrogridMembershipApproval_g_tc_members[4]._annotations._defaultValue._u.enumerated_value = 0;

    tms_MicrogridMembershipApproval_g_tc_members[5]._annotations._defaultValue._d = RTI_XCDR_TK_STRING;
    tms_MicrogridMembershipApproval_g_tc_members[5]._annotations._defaultValue._u.string_value = (DDS_Char *) "";

    tms_MicrogridMembershipApproval_g_tc._data._sampleAccessInfo =
    tms_MicrogridMembershipApproval_get_sample_access_info();
    tms_MicrogridMembershipApproval_g_tc._data._typePlugin =
    tms_MicrogridMembershipApproval_get_type_plugin_info();    

    is_initialized = RTI_TRUE;

    return &tms_MicrogridMembershipApproval_g_tc;
}

#define TSeq tms_MicrogridMembershipApprovalSeq
#define T tms_MicrogridMembershipApproval
#include "dds_cpp/generic/dds_cpp_data_TInterpreterSupport.gen"
#undef T
#undef TSeq

RTIXCdrSampleAccessInfo *tms_MicrogridMembershipApproval_get_sample_seq_access_info()
{
    static RTIXCdrSampleAccessInfo tms_MicrogridMembershipApproval_g_seqSampleAccessInfo = {
        RTI_XCDR_TYPE_BINDING_CPP, \
        {sizeof(tms_MicrogridMembershipApprovalSeq),0,0,0}, \
        RTI_XCDR_FALSE, \
        DDS_Sequence_get_member_value_pointer, \
        tms_MicrogridMembershipApprovalSeq_set_member_element_count, \
        NULL, \
        NULL, \
        NULL \
    };

    return &tms_MicrogridMembershipApproval_g_seqSampleAccessInfo;
}

RTIXCdrSampleAccessInfo *tms_MicrogridMembershipApproval_get_sample_access_info()
{
    static RTIBool is_initialized = RTI_FALSE;

    tms_MicrogridMembershipApproval *sample;

    static RTIXCdrMemberAccessInfo tms_MicrogridMembershipApproval_g_memberAccessInfos[6] =
    {RTIXCdrMemberAccessInfo_INITIALIZER};

    static RTIXCdrSampleAccessInfo tms_MicrogridMembershipApproval_g_sampleAccessInfo = 
    RTIXCdrSampleAccessInfo_INITIALIZER;

    if (is_initialized) {
        return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembershipApproval_g_sampleAccessInfo;
    }

    RTIXCdrHeap_allocateStruct(
        &sample, 
        tms_MicrogridMembershipApproval);
    if (sample == NULL) {
        return NULL;
    }

    tms_MicrogridMembershipApproval_g_memberAccessInfos[0].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->requestId - (char *)sample);

    tms_MicrogridMembershipApproval_g_memberAccessInfos[1].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->relatedRequestId - (char *)sample);

    tms_MicrogridMembershipApproval_g_memberAccessInfos[2].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->deviceId - (char *)sample);

    tms_MicrogridMembershipApproval_g_memberAccessInfos[3].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->membership - (char *)sample);

    tms_MicrogridMembershipApproval_g_memberAccessInfos[4].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->result - (char *)sample);

    tms_MicrogridMembershipApproval_g_memberAccessInfos[5].bindingMemberValueOffset[0] = 
    (RTIXCdrUnsignedLong) ((char *)&sample->hint - (char *)sample);

    tms_MicrogridMembershipApproval_g_sampleAccessInfo.memberAccessInfos = 
    tms_MicrogridMembershipApproval_g_memberAccessInfos;

    {
        size_t candidateTypeSize = sizeof(tms_MicrogridMembershipApproval);

        if (candidateTypeSize > RTIXCdrUnsignedLong_MAX) {
            tms_MicrogridMembershipApproval_g_sampleAccessInfo.typeSize[0] =
            RTIXCdrUnsignedLong_MAX;
        } else {
            tms_MicrogridMembershipApproval_g_sampleAccessInfo.typeSize[0] =
            (RTIXCdrUnsignedLong) candidateTypeSize;
        }
    }

    tms_MicrogridMembershipApproval_g_sampleAccessInfo.useGetMemberValueOnlyWithRef =
    RTI_XCDR_TRUE;

    tms_MicrogridMembershipApproval_g_sampleAccessInfo.getMemberValuePointerFcn = 
    tms_MicrogridMembershipApproval_get_member_value_pointer;

    tms_MicrogridMembershipApproval_g_sampleAccessInfo.languageBinding = 
    RTI_XCDR_TYPE_BINDING_CPP ;

    RTIXCdrHeap_freeStruct(sample);
    is_initialized = RTI_TRUE;
    return (RTIXCdrSampleAccessInfo*) &tms_MicrogridMembershipApproval_g_sampleAccessInfo;
}

RTIXCdrTypePlugin *tms_MicrogridMembershipApproval_get_type_plugin_info()
{
    static RTIXCdrTypePlugin tms_MicrogridMembershipApproval_g_typePlugin = 
    {
        NULL, /* serialize */
        NULL, /* serialize_key */
        NULL, /* deserialize_sample */
        NULL, /* deserialize_key_sample */
        NULL, /* skip */
        NULL, /* get_serialized_sample_size */
        NULL, /* get_serialized_sample_max_size_ex */
        NULL, /* get_serialized_key_max_size_ex */
        NULL, /* get_serialized_sample_min_size */
        NULL, /* serialized_sample_to_key */
        (RTIXCdrTypePluginInitializeSampleFunction) 
        tms_MicrogridMembershipApproval_initialize_ex,
        NULL,
        (RTIXCdrTypePluginFinalizeSampleFunction)
        tms_MicrogridMembershipApproval_finalize_w_return,
        NULL
    };

    return &tms_MicrogridMembershipApproval_g_typePlugin;
}
#endif

RTIBool tms_MicrogridMembershipApproval_initialize(
    tms_MicrogridMembershipApproval* sample) {
    return tms_MicrogridMembershipApproval_initialize_ex(sample,RTI_TRUE,RTI_TRUE);
}

RTIBool tms_MicrogridMembershipApproval_initialize_ex(
    tms_MicrogridMembershipApproval* sample,RTIBool allocatePointers, RTIBool allocateMemory)
{

    struct DDS_TypeAllocationParams_t allocParams =
    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;

    allocParams.allocate_pointers =  (DDS_Boolean)allocatePointers;
    allocParams.allocate_memory = (DDS_Boolean)allocateMemory;

    return tms_MicrogridMembershipApproval_initialize_w_params(
        sample,&allocParams);

}

RTIBool tms_MicrogridMembershipApproval_initialize_w_params(
    tms_MicrogridMembershipApproval* sample, const struct DDS_TypeAllocationParams_t * allocParams)
{

    if (sample == NULL) {
        return RTI_FALSE;
    }
    if (allocParams == NULL) {
        return RTI_FALSE;
    }

    if (!tms_SampleId_initialize_w_params(&sample->requestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_SampleId_initialize_w_params(&sample->relatedRequestId,
    allocParams)) {
        return RTI_FALSE;
    }
    if (!tms_Fingerprint_initialize_w_params(&sample->deviceId,
    allocParams)) {
        return RTI_FALSE;
    }
    sample->membership = MM_UNINITIALIZED;
    sample->result = MMR_UNINITIALIZED;

    if (allocParams->allocate_memory) {
        sample->hint = DDS_String_alloc(((tms_MAXLEN_hint)));
        RTICdrType_copyStringEx(
            &sample->hint,
            "",
            ((tms_MAXLEN_hint)),
            RTI_FALSE);
        if (sample->hint == NULL) {
            return RTI_FALSE;
        }
    } else {
        if (sample->hint != NULL) {
            RTICdrType_copyStringEx(
                &sample->hint,
                "",
                ((tms_MAXLEN_hint)),
                RTI_FALSE);
            if (sample->hint == NULL) {
                return RTI_FALSE;
            }
        }
    }

    return RTI_TRUE;
}

RTIBool tms_MicrogridMembershipApproval_finalize_w_return(
    tms_MicrogridMembershipApproval* sample)
{
    tms_MicrogridMembershipApproval_finalize_ex(sample, RTI_TRUE);

    return RTI_TRUE;
}

void tms_MicrogridMembershipApproval_finalize(
    tms_MicrogridMembershipApproval* sample)
{

    tms_MicrogridMembershipApproval_finalize_ex(sample,RTI_TRUE);
}

void tms_MicrogridMembershipApproval_finalize_ex(
    tms_MicrogridMembershipApproval* sample,RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParams =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;

    if (sample==NULL) {
        return;
    } 

    deallocParams.delete_pointers = (DDS_Boolean)deletePointers;

    tms_MicrogridMembershipApproval_finalize_w_params(
        sample,&deallocParams);
}

void tms_MicrogridMembershipApproval_finalize_w_params(
    tms_MicrogridMembershipApproval* sample,const struct DDS_TypeDeallocationParams_t * deallocParams)
{

    if (sample==NULL) {
        return;
    }

    if (deallocParams == NULL) {
        return;
    }

    tms_SampleId_finalize_w_params(&sample->requestId,deallocParams);

    tms_SampleId_finalize_w_params(&sample->relatedRequestId,deallocParams);

    tms_Fingerprint_finalize_w_params(&sample->deviceId,deallocParams);

    tms_MicrogridMembership_finalize_w_params(&sample->membership,deallocParams);

    tms_MicrogridMembershipResult_finalize_w_params(&sample->result,deallocParams);

    if (sample->hint != NULL) {
        DDS_String_free(sample->hint);
        sample->hint=NULL;

    }
}

void tms_MicrogridMembershipApproval_finalize_optional_members(
    tms_MicrogridMembershipApproval* sample, RTIBool deletePointers)
{
    struct DDS_TypeDeallocationParams_t deallocParamsTmp =
    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
    struct DDS_TypeDeallocationParams_t * deallocParams =
    &deallocParamsTmp;

    if (sample==NULL) {
        return;
    } 
    if (deallocParams) {} /* To avoid warnings */

    deallocParamsTmp.delete_pointers = (DDS_Boolean)deletePointers;
    deallocParamsTmp.delete_optional_members = DDS_BOOLEAN_TRUE;

}

RTIBool tms_MicrogridMembershipApproval_copy(
    tms_MicrogridMembershipApproval* dst,
    const tms_MicrogridMembershipApproval* src)
{
    try {

        if (dst == NULL || src == NULL) {
            return RTI_FALSE;
        }

        if (!tms_SampleId_copy(
            &dst->requestId,(const tms_SampleId*)&src->requestId)) {
            return RTI_FALSE;
        } 
        if (!tms_SampleId_copy(
            &dst->relatedRequestId,(const tms_SampleId*)&src->relatedRequestId)) {
            return RTI_FALSE;
        } 
        if (!tms_Fingerprint_copy(
            &dst->deviceId,(const tms_Fingerprint*)&src->deviceId)) {
            return RTI_FALSE;
        } 
        if (!tms_MicrogridMembership_copy(
            &dst->membership,(const tms_MicrogridMembership*)&src->membership)) {
            return RTI_FALSE;
        } 
        if (!tms_MicrogridMembershipResult_copy(
            &dst->result,(const tms_MicrogridMembershipResult*)&src->result)) {
            return RTI_FALSE;
        } 
        if (!RTICdrType_copyStringEx (
            &dst->hint, src->hint, 
            ((tms_MAXLEN_hint)) + 1, RTI_FALSE)){
            return RTI_FALSE;
        }

        return RTI_TRUE;

    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
}

/**
* <<IMPLEMENTATION>>
*
* Defines:  TSeq, T
*
* Configure and implement 'tms_MicrogridMembershipApproval' sequence class.
*/
#define T tms_MicrogridMembershipApproval
#define TSeq tms_MicrogridMembershipApprovalSeq

#define T_initialize_w_params tms_MicrogridMembershipApproval_initialize_w_params

#define T_finalize_w_params   tms_MicrogridMembershipApproval_finalize_w_params
#define T_copy       tms_MicrogridMembershipApproval_copy

#ifndef NDDS_STANDALONE_TYPE
#include "dds_c/generic/dds_c_sequence_TSeq.gen"
#include "dds_cpp/generic/dds_cpp_sequence_TSeq.gen"
#else
#include "dds_c_sequence_TSeq.gen"
#include "dds_cpp_sequence_TSeq.gen"
#endif

#undef T_copy
#undef T_finalize_w_params

#undef T_initialize_w_params

#undef TSeq
#undef T

#ifndef NDDS_STANDALONE_TYPE
namespace rti { 
    namespace xcdr {
        const RTIXCdrTypeCode * type_code<tms_Point2D>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_Point2D_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_Curve2D>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_Curve2D_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ClockMonotonic>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ClockMonotonic_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ClockRealtime>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ClockRealtime_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ClockStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ClockStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_SampleId>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_SampleId_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ReplyStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ReplyStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_RequestResponse>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_RequestResponse_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ParameterMetadata>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ParameterMetadata_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ParameterValue>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ParameterValue_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DeviceParameterRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DeviceParameterRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DeviceParameterStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DeviceParameterStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DistributionInfo>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DistributionInfo_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadInfo>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadInfo_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_EngineStateThresholds>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_EngineStateThresholds_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_SourceInfo>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_SourceInfo_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ProductInfo>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ProductInfo_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_Heartbeat>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_Heartbeat_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DiagnosticTroubleCode>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DiagnosticTroubleCode_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ActiveDiagnosticMessages>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ActiveDiagnosticMessages_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_StandardConfigMaster>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_StandardConfigMaster_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_CopyConfigRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_CopyConfigRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ReserveConfigRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ReserveConfigRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ReserveConfigReply>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ReserveConfigReply_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ReleaseConfigRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ReleaseConfigRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ConfigReservation>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ConfigReservation_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ConfigReservationList>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ConfigReservationList_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_GetConfigContentsRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_GetConfigContentsRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_AuthorizationToEnergizeRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_AuthorizationToEnergizeRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_AuthorizationToEnergizeResponse>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_AuthorizationToEnergizeResponse_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_AuthorizationToEnergizeOutcome>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_AuthorizationToEnergizeOutcome_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerPortId>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerPortId_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerConnectionId>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerConnectionId_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerPortType>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerPortType_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerSwitchStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerSwitchStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerSwitchCommand>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerSwitchCommand_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerPortStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerPortStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerConnection>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerConnection_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DevicePowerPortTypes>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DevicePowerPortTypes_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DevicePowerPortStatuses>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DevicePowerPortStatuses_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerConnectionList>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerConnectionList_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_GroundingType>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_GroundingType_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DeviceGroundingType>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DeviceGroundingType_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_GroundingStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_GroundingStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DeviceGroundingStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DeviceGroundingStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_GroundingCommand>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_GroundingCommand_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerMeasurementLine>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerMeasurementLine_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerMeasurementWye>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerMeasurementWye_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerPortMeasurement>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerPortMeasurement_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DevicePowerMeasurements>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DevicePowerMeasurements_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_FingerprintNickname>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_FingerprintNickname_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ChangeNicknameRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ChangeNicknameRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DeviceIcon>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DeviceIcon_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_Duration>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_Duration_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_MicrogridIntent>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_MicrogridIntent_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_OverCurrentDisconnect>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_OverCurrentDisconnect_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_OverEnergyDisconnect>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_OverEnergyDisconnect_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_UnderFrequencyDisconnect>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_UnderFrequencyDisconnect_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LocalPowerPortPriorityAssignment>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LocalPowerPortPriorityAssignment_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerPortLoadPolicy>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerPortLoadPolicy_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_BusbarLoadPolicy>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_BusbarLoadPolicy_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DeviceIntent>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DeviceIntent_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerPortIntent>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerPortIntent_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_OperatorIntent>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_OperatorIntent_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_OperatorIntentRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_OperatorIntentRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_OperatorIntentState>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_OperatorIntentState_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadPolicyRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadPolicyRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_PowerPortLoadPolicyReport>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_PowerPortLoadPolicyReport_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DeviceLoadPolicyStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DeviceLoadPolicyStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DevicePriority>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DevicePriority_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_NsnPriority>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_NsnPriority_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_GtinPriority>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_GtinPriority_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_McPriorityList>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_McPriorityList_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_McRedirect>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_McRedirect_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_EngineState>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_EngineState_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_SourceTransitionState>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_SourceTransitionState_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_SourceTransitionRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_SourceTransitionRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_ControlCurve>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_ControlCurve_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DLSConfig>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DLSConfig_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_DLSMeasurement>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_DLSMeasurement_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadSharing>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadSharing_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadSharingRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadSharingRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadSharingStatus>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadSharingStatus_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadEstimate>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadEstimate_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadChange>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadChange_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_LoadChangeRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_LoadChangeRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_SimulationCapabilities>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_SimulationCapabilities_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_TimeScheme>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_TimeScheme_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_TimeAdvance>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_TimeAdvance_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_MicrogridMembershipRequest>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_MicrogridMembershipRequest_get_typecode();
        }

        const RTIXCdrTypeCode * type_code<tms_MicrogridMembershipApproval>::get() 
        {
            return (const RTIXCdrTypeCode *) tms_MicrogridMembershipApproval_get_typecode();
        }

    } 
}
#endif
