/* DDS vendor key support

   PrismTech: #pragma keylist, use command line "idlpp -D OSPL_IDLPP ..." to activate
   RTI: @key in comment
   Twin Oaks: DDS_KEY macro
*/
/*
#ifdef DDS_IDL
#define DDS_KEY __dds_key
#else
#define DDS_KEY
#endif
*/
/*
 * Original generated from the 20170208 release of the standard.
 */
/*
 ****************************************************************************
 * Change History:
 * 2/14/2017: Added DDS Keys
 * 2/17/2017: Added missing OperatorIntentRequest and OperatorIntentState
 * 2/22/2017: Removed LoadEstimate fields to avoid C++ conflict with QT
 * 2/28/2017: Added DeviceRole enumeration and bit mask to ProductInfo
 * 3/7/2017:  Added Topic names as constants
 * 3/23/2017: Added Fingerprint deviceId to EngineState
 * 3/30/2017: Update enum SourceState and SourceTransition to follow naming convention
 * 4/03/2017: Added Get_CONFIG_<command>_RESPONSE topics
 * 4/03/2017: Sorted topic names
 * 4/28/2017: Added deviceId to OperatorIntentState 
 * 6/19/2017: Added new SecondaryControlCapabilities topic name 
 * 7/21/2017: 1) Renamed 's' to seconds and 'ns' to nanoSeconds in 
 *               ClockMonotonic and ClockRealTime.
 *            2) Renamed 'time' to 'timeMeasured' in 
 *               DevicePowerMeasurements and DLSMeasurement 
 * 9/21/2017: Added new LoadSharingStatus Topic and related LoadSharingStatus data type.
 * 8/02/2019: 1) New MicrogridMembership, MicrogridMembershipRequest
                 and MicrogridMembershipApproval data type.
              2) Added softwareVersion and platformId to ProductInfo
              3) Added new CONFIG_EMERGENCY device configuration ID
              4) Added new connector types to PowerConnectorType
              5) Added PHASE_DC to PowerConnectorPhases
              6) Redefined PowerSwitchControl AUTO and REMOTE
              7) Added support for Grounding Circuits.   See GroundingDesignType,
                 GroundingType, DeviceGroundingType, GroundFaultDetection,
                 GroundingStatus, DeviceGroundingStatus, and GroundingCommand
              8) Added new Heart-beat data type.
              9) Added new Conversion DeviceRole.
 * 9/24/2019: 1) Replaced MAX_PORTS with MAX_GROUNDS in the DeviceGoundingType
              2) Renamed attribute names that matched data types to avoid possible
                 IDL compiler errors.  Includes the following types
                  MicrogridIntent, DeviceIntent, OperatorIntent, and LoadEstimate
              3) Renamed MicrogridMembershipResult WARNING to BLOCKED.
 ****************************************************************************
 */ 
module tms {

const unsigned long MINLEN_TopicName = 1;
const unsigned long MAXLEN_TopicName = 64;
typedef string<MAXLEN_TopicName> TopicName;

const unsigned long MINLEN_TopicList = 0;
const unsigned long MAXLEN_TopicList = 8;
typedef sequence<TopicName,MAXLEN_TopicList> TopicList;

struct Point2D {

    /** Horizontal coordinate. */
    float x;

    /** Vertical coordinate. */
    float y;
}; // struct Point2D

const unsigned long MINLEN_points = 0;
const unsigned long MAXLEN_points = 21;
struct Curve2D {

    /** Vertices on the curve. */
    sequence<Point2D,MAXLEN_points> points;
}; // struct Curve2D

const unsigned long MINLEN_PublicKey = 1;
const unsigned long MAXLEN_PublicKey = 32*1024;
typedef sequence<octet,MAXLEN_PublicKey> PublicKey;

const unsigned long LEN_Fingerprint = 32;
typedef octet Fingerprint[LEN_Fingerprint];

/** Value reserved to mean ``no such device / invalid device''. */
const string FINGERPRINT_INVALID = "00000000000000000000000000000000";

const unsigned long MINLEN_Signature = 1;
const unsigned long MAXLEN_Signature = 9999;
typedef sequence<octet,MAXLEN_Signature> Signature;

struct ClockMonotonic {

    /** integer portion of the timestamp */
    unsigned long seconds;

    /** fractional portion of the timestamp */
    unsigned long nanoseconds;
}; // struct ClockMonotonic

struct ClockRealtime {

    /** Epoch */
    unsigned short epoch;

    /** integer portion of the timestamp */
    unsigned long seconds;

    /** fractional portion of the timestamp */
    unsigned long nanoseconds;
}; // struct ClockRealtime

enum ClockMonotonicPersistenceType {
    CMPT_UNKNOWN, // Fault detection indicates that initialization may be inconsistent.
    CMPT_RESET, // Clock initializes to 0.
    CMPT_ACCUMULATE, // Clock initializes to a value stored shortly before shutdown. This is effectively an aggregate runtime meter.
    CMPT_OTHER // Another clock initialization scheme is used.
}; // enum ClockMonotonicPersistenceType

struct ClockStatus {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Measured monotonic time, sampled simultaneously with realtime. */
    ClockMonotonic monotonic;

    /** Indicate whether the monotonic clock initializes to 0 or accumulates operating time across restarts. */
    ClockMonotonicPersistenceType monotonicPersistence;

    /** Measured real time, sampled simultaneously with monotonic. */
    ClockRealtime realtime;

    /** Source of the realtime clock, as enumerated for timeSource in IEEE-1588-2008 Table 7. */
    octet realtimeSource;

    /** Last time the realtime clock was updated by the source. */
    ClockRealtime realtimeSetTime;
}; // struct ClockStatus
#ifdef OSPL_IDLPP
#pragma keylist ClockStatus deviceId
#endif

/** Direct connection to a calibrated atomic clock */
const octet CLOCK_ATOMIC = 0x10;

/** Satellite-based system */
const octet CLOCK_GPS = 0x20;
/** Terrestrial radio system */
const octet CLOCK_RADIO = 0x30;

/** PTP, IEEE-1588 */
const octet CLOCK_PTP = 0x40;

/** NTP, RFC 5905 or SNTP, RFC 4330 */
const octet CLOCK_NTP = 0X50;

/** User input */
const octet CLOCK_HAND = 0X60;

/** Other source */
const octet CLOCK_OTHER = 0X90;

/** Arbitrary or unknown epoch */
const octet CLOCK_INTERNAL = 0XA0;

struct SampleId {

    /** Identity of the device that sent this message. */
    Fingerprint deviceId;

    /** A number that is unique to each SampleId sent by this device. It commonly starts at 0 and increments for each generated SampleId, but such behavior is not required. For example, a pseudo-random sequence may be used to avoid leaking information about how many identities have been generated. */
    unsigned long long sequenceNumber;
}; // struct SampleId

const unsigned long MINLEN_reason = 0;
const unsigned long MAXLEN_reason = 32;
struct ReplyStatus {

    /** Indicator of success or failure. Intended to support automatic handling. Values from 100 to 599 are as defined in the IETF RFCs. Values outside that range are reserved for future versions of this standard. Selected values are defined as constants. */
    unsigned long code;

    /** Short textual description of the status code intended for human operators. */
    string<MAXLEN_reason> reason;
}; // struct ReplyStatus

/** The request has succeeded. */
const unsigned long REPLY_OK = 200;

/** Some value in the request was invalid. */
const unsigned long REPLY_BAD_REQUEST = 400;

const unsigned long REPLY_METHOD_NOT_ALLOWED = 405;

const unsigned long REPLY_CONFLICT = 409;

const unsigned long REPLY_GONE = 410;

const unsigned long REPLY_PRECONDITION_FAILED = 412;

const unsigned long REPLY_REQUEST_ENTITY_TOO_LARGE = 413;

const unsigned long REPLY_INTERNAL_SERVER_ERROR = 500;

const unsigned long REPLY_NOT_IMPLEMENTED = 501;

const unsigned long REPLY_SERVICE_UNAVAILABLE = 503;

/** Request is valid, and authorization is required before processing. */
const unsigned long REPLY_PENDING_AUTHORIZATION = 600;

struct RequestResponse {

    /** Copy of the corresponding requestId. */
    @key SampleId relatedRequestId; //@key

    /** Indication of success or failure. */
    ReplyStatus status;
}; // struct RequestResponse
#ifdef OSPL_IDLPP
#pragma keylist RequestResponse relatedRequestId
#endif

/** Maximum length of parameter name string. */
const unsigned long MAXLEN_PARAMETER_NAME = 32;

/** Maximum length of parameter units string. */
const unsigned long MAXLEN_PARAMETER_UNITS = 16;

/** Maximum number of parameters that a device may contain. */
const unsigned long MAX_PARAMETERS = 128;

const unsigned long MINLEN_name = 0;
const unsigned long MAXLEN_name = MAXLEN_PARAMETER_NAME;
const unsigned long MINLEN_units = 0;
const unsigned long MAXLEN_units = MAXLEN_PARAMETER_UNITS;
struct ParameterMetadata {

    /** Name of this parameter. */
    string<MAXLEN_name> name;

    /** Units of measure. (V, A, Hz, V/Hz, ...) */
    string<MAXLEN_units> units;

    /** Recommended lower bound. Lower values may cause poor performance or excessive wear. Set to -\infty  if no limit. */
    float nominalMinValue;

    /** Recommended upper bound. Higher values may cause poor performance or excessive wear. Set to +\infty  if no limit. */
    float nominalMaxValue;

    /** Absolute lower bound. Lower values will be rejected. Set to -\infty  if no limit. */
    float hardMinValue;

    /** Absolute upper bound. Higher values will be rejected. Set to +\infty  if no limit. */
    float hardMaxValue;

    /** Smallest change \ge 0 that may have an effect. Set to 0 if no limit. */
    float resolution;
}; // struct ParameterMetadata

struct ParameterValue {

    /** Name of this parameter. */
    string<MAXLEN_name> name;

    /** Value of this parameter, with units according to ParameterMetadata. */
    float value;
}; // struct ParameterValue

typedef unsigned short ConfigId;

const unsigned long MINLEN_parameters = 0;
const unsigned long MAXLEN_parameters = MAX_PARAMETERS;
struct DeviceParameterRequest {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Device that should execute this command */
    Fingerprint deviceId;

    /** Configuration that this command belongs to. */
    ConfigId config;

    /** Selected parameter values to update (may be partial or full list). */
    sequence<ParameterValue,MAXLEN_parameters> parameters;
}; // struct DeviceParameterRequest
#ifdef OSPL_IDLPP
#pragma keylist DeviceParameterRequest requestId
#endif

struct DeviceParameterStatus {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Configuration that these values belong to. */
    ConfigId config;

    /** A full list of the parameters available on this device. */
    sequence<ParameterValue,MAXLEN_parameters> parameters;
}; // struct DeviceParameterStatus
#ifdef OSPL_IDLPP
#pragma keylist DeviceParameterStatus deviceId
#endif

enum DeviceRole {
    ROLE_MICROGRID_CONTROLLER, // Tactical microgrid controller
    ROLE_TIME_CONTROLLER, // Time controller
    ROLE_SOURCE, // Source
    ROLE_LOAD, // Load
    ROLE_STORAGE, // Storage
    ROLE_DISTRIBUTION, // Distribution
    ROLE_MICROGRID_SYSTEM_MANAGER, // Microgrid system manager
    ROLE_CONVERSION // Conversion
}; // enum DeviceRole

const unsigned long LEN_NatoStockNumber = 13;
typedef char NatoStockNumber[LEN_NatoStockNumber];

const unsigned long LEN_GlobalTradeItemNumber = 14;
typedef char GlobalTradeItemNumber[LEN_GlobalTradeItemNumber];

struct DistributionInfo {

    /** True indicates this device implements Section sec:LoadPolicies. */
    boolean supportsLoadPolicy;

    /** True indicates this device implements Section sec:ManualBlackStart. */
    boolean supportsAuthorizationToEnergize;
}; // struct DistributionInfo

struct LoadInfo {

    /** A full list of the load parameters available on this device. */
    sequence<ParameterMetadata,MAXLEN_parameters> parameters;

    /** True when LoadChangeRequest is supported. */
    boolean supportsLoadChange;

    /** Minimum step size for a LoadChangeRequest. Set to NaN\ if not supported. */
    float loadChangeThreshold; // [W]

    /** Minimum step size for a LoadEstimate update. */
    float loadEstimateDeadband; // [W]

    /** True when Section sec:LoadPolicies is supported. */
    boolean supportsLoadPolicy;
}; // struct LoadInfo

struct EngineStateThresholds {

    /** Indicates consumption, a leak, or risk of failure. */
    float lowOilPressure; // [Pa]

    /** Indicates risk of failure. */
    float highOilPressure; // [Pa]

    /** Indicates low efficiency. Engine should ``warm up'' above this temperature within a few minutes of operation. */
    float lowCoolantTemperature; // [C]

    /** Indicates risk of failure. */
    float highCoolantTemperature; // [C]
}; // struct EngineStateThresholds

const unsigned long MINLEN_engine = 0;
const unsigned long MAXLEN_engine = 1;
struct SourceInfo {

    /** A full list of the source parameters available on this device. */
    sequence<ParameterMetadata,MAXLEN_parameters> parameters;

    /** True indicates this device supports f_P and v_Q curves having a nonzero (droop) slope. */
    boolean supportsDroopCurve;

    /** True indicates this device supports f_P and v_Q curves having multiple line segments. */
    boolean supportsNonlinearCurve;

    /** True indicates this device supports DLSConfig and DLSMeasurement. */
    boolean supportsDigitalLoadShare;

    /** True indicates this device implements Section sec:ManualBlackStart. */
    boolean supportsAuthorizationToEnergize;

    /** Nominal operating ranges for engine-based sources. */
    sequence<EngineStateThresholds,MAXLEN_engine> engine;
}; // struct SourceInfo

const unsigned long MINLEN_manufacturerName = 0;
const unsigned long MAXLEN_manufacturerName = 64;
const unsigned long MINLEN_modelName = 0;
const unsigned long MAXLEN_modelName = 32;
const unsigned long MINLEN_modelNumber = 0;
const unsigned long MAXLEN_modelNumber = 32;
const unsigned long MINLEN_serialNumber = 0;
const unsigned long MAXLEN_serialNumber = 32;
const unsigned long MINLEN_softwareVersion = 0;
const unsigned long MAXLEN_softwareVersion = 20;
const unsigned long MINLEN_distribution = 0;
const unsigned long MAXLEN_distribution = 1;
const unsigned long MINLEN_load = 0;
const unsigned long MAXLEN_load = 1;
const unsigned long MINLEN_source = 0;
const unsigned long MAXLEN_source = 1;
struct ProductInfo {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** TMS role implemented by this device. */
    DeviceRole role;

    /** Supply type of this device. */
    NatoStockNumber nsn;

    /** Product type of this device. */
    GlobalTradeItemNumber gtin;

    /** Name of the device manufacturer. Optional. */
    string<MAXLEN_manufacturerName> manufacturerName;

    /** Name of the device model. Optional. */
    string<MAXLEN_modelName> modelName;

    /** Manufacturer number for the device model. Optional. */
    string<MAXLEN_modelNumber> modelNumber;

    /** Unique production number for a specific device. Large enough to contain a variety of formats, including the GS1 serial number (AI 21). Optional. */
    string<MAXLEN_serialNumber> serialNumber;

    /** Rated real power of a source or storage device. Set to 0 for other device roles. */
    float sourcePower; // [W]

    /** Rated reactive power of a source or storage device. Set to 0 for other device roles. */
    float sourceVar; // [var]

    /** Rated power of a load, or power that can be absorbed by storage. Set to 0 for other device roles. */
    float loadPower; // [W]

    /** Rated capacity of a storage device. Set to 0 for other device roles. */
    float storageEnergy; // [J]

    /** Rated bus capacity of a distribution device. Set to 0 for other device roles. */
    float distributionCurrent; // [A]

    /** Report the maximum number of temporary device configurations that can be reserved at one time. */
    unsigned short configTmpCount;

    /** Indicate whether the device has a realtime clock and will publish ClockStatus. */
    boolean hasRealtimeClock;

    /** Application software version identifier. Optional. */
    string<MAXLEN_softwareVersion> softwareVersion;

    /** A platform is a group of TMS devices that are assembled into a larger physical package. Platforms may integrate multiple device roles. Set to FINGERPRINT_INVALID if this device is not permanently mounted on a platform. */
    Fingerprint platformId;

    /** Additional information required from distribution devices. */
    sequence<DistributionInfo,MAXLEN_distribution> distribution;

    /** Additional information required from load devices. */
    sequence<LoadInfo,MAXLEN_load> load;

    /** Additional information required from source or storage devices. */
    sequence<SourceInfo,MAXLEN_source> source;
}; // struct ProductInfo
#ifdef OSPL_IDLPP
#pragma keylist ProductInfo deviceId
#endif

struct Heartbeat {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** A counter that starts at 0 and increments by 1 for each new heartbeat. Confirms availability of the application software. */
    unsigned long sequenceNumber;
}; // struct Heartbeat
#ifdef OSPL_IDLPP
#pragma keylist Heartbeat deviceId
#endif

typedef unsigned long SuspectParameterNumber;

typedef octet FailureModeIndicator;

/** Data valid but above normal operational range, most severe level */
const octet FMI_HIGH_MOST_SEVERE = 0;

/** Data valid but below normal operational range, most severe level */
const octet FMI_LOW_MOST_SEVERE = 1;

/** Data valid but above normal operational range, least severe level */
const octet FMI_HIGH_LEAST_SEVERE = 15;

/** Data valid but above normal operational range, moderately severe level */
const octet FMI_HIGH_MODERATELY_SEVERE = 16;

/** Data valid but below normal operational range, least severe level */
const octet FMI_LOW_LEAST_SEVERE = 17;

/** Data valid but below normal operational range, moderately severe level */
const octet FMI_LOW_MODERATELY_SEVERE = 18;

enum DtcSeverity {
    SEV_0_NOT_SPECIFIED, // [PROPOSAL] Undefined severity. Never transmitted in this version of the standard.
    SEV_1_CLEAR, // [PROPOSAL] DTC has cleared. Never transmitted in this version of the standard.
    SEV_2_INFORMATIVE, // Informational only. No performance impact is expected.
    SEV_3_PREVENTATIVE, // Preventative maintenance has been scheduled.
    SEV_4_DEGRADED, // Poor configuration or operation resulting in degraded performance, including reduced efficiency and increased emissions.
    SEV_5_WARNING, // Increased wear and premature failure likely.
    SEV_6_MINOR, // The device may be failing to meet operating performance criteria. The DTC may represent cause or effect.
    SEV_7_MAJOR, // This condition may cause protection logic to enter a controlled shutdown sequence. A corrective action may be required before the device can be restarted.
    SEV_8_CRITICAL, // A loss of essential functionality has been detected. Routine maintenance or repair may be required.
    SEV_9_FATAL, // A loss of essential functionality has been detected. Permanent damage may have occurred.
    SEV_10_HUMAN_SAFETY // Potential user safety risk
}; // enum DtcSeverity

const unsigned long MINLEN_hint = 0;
const unsigned long MAXLEN_hint = 32;
struct DiagnosticTroubleCode {

    /** Parameter representing this DTC */
    SuspectParameterNumber suspectParameter;

    /** Type of fault for this parameter */
    FailureModeIndicator failureMode;

    /** Number of times this DTC was raised. This field increments on a state change from inactive to active. In order to increment, the cleared state must be sensed. The count must not increment simply due to restarts. The count should be stored in non-volatile memory in order to preserve it over power cycles. The count saturates at 4294967294 (2^{32}-2). The value 4294967295 (2^{32}-1) indicates that the count is not available. */
    unsigned long occurrenceCount;

    /** Timestamp when this DTC was raised or activated. */
    ClockMonotonic timeRaised;

    /** Expected impact of the DTC on grid operation. Intended to support automatic handling of parameters that are unknown to the receiving system. */
    DtcSeverity severity;

    /** Short, human-readable text description of the DTC. This should summarize to the operator what the issue is (e.g. ``oil pressure'' or ``low oil pressure''). Intended to support human operators for parameters that are unknown to the receiving system. */
    string<MAXLEN_hint> hint;
}; // struct DiagnosticTroubleCode

const unsigned long MINLEN_codes = 0;
const unsigned long MAXLEN_codes = 64;
struct ActiveDiagnosticMessages {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Active trouble codes. A given suspect parameter can only appear once in this sequence. */
    sequence<DiagnosticTroubleCode,MAXLEN_codes> codes;

    /** Count of trouble codes that were truncated from the codes because the maximum sequence length was exceeded. A count of 0 indicates that all active trouble codes are listed. */
    unsigned long overflow;
}; // struct ActiveDiagnosticMessages
#ifdef OSPL_IDLPP
#pragma keylist ActiveDiagnosticMessages deviceId
#endif

/** Invalid index. May represent ``no configuration''. Access attempts will trigger an error. */
const unsigned short CONFIG_INVALID = 0;

/** Built-in defaults. Read-only. May be programmed by the vendor, through a local interface, or through some other mechanism outside the data model. Only used for initializing other configurations. */
const unsigned short CONFIG_DEFAULTS = 1;

/** Previous contents of CONFIG_ACTIVE, saved when it is overwritten by CopyConfigRequest or an internal event trigger. */
const unsigned short CONFIG_OLD_ACTIVE = 99;

/** Settings for immediate use. Use this for all commands. */
const unsigned short CONFIG_ACTIVE = 100;

/** Settings for use after device restart. */
const unsigned short CONFIG_RESTART = 101;

/** Settings for use after communications loss timeout. */
const unsigned short CONFIG_NO_COMM = 102;

/** Settings for use in emergency operating mode. */
const unsigned short CONFIG_EMERGENCY = 103;

/** Validate settings without modifying the state of the target device. If the settings are supported and all parameters are within acceptable bounds, then REPLY_OK is returned, otherwise the appropriate error status is returned. */
const unsigned short CONFIG_CHECK_SETTING = 200;

/** This index modifies all temporary configurations belonging to the sending MC. If the requesting MC does not have any reserved temporary configurations, then REPLY_GONE is returned. */
const unsigned short CONFIG_TMP_ALL = 999;

/** First index reserved for temporary configurations. */
const unsigned short CONFIG_TMP_MIN = 1000;

/** Last index reserved for temporary configurations. */
const unsigned short CONFIG_TMP_MAX = 1999;

struct StandardConfigMaster {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** The :MC that currently controls this device. */
    Fingerprint masterId;
}; // struct StandardConfigMaster
#ifdef OSPL_IDLPP
#pragma keylist StandardConfigMaster deviceId
#endif

struct CopyConfigRequest {

    /** Unique request identifier, including the identity of the :MC making the request. */
    @key SampleId requestId; //@key

    /** Identity of the device that should service the request. */
    Fingerprint deviceId;

    /** Configuration index to copy values from. */
    ConfigId source;

    /** Configuration index to overwrite with the source values. */
    ConfigId target;
}; // struct CopyConfigRequest
#ifdef OSPL_IDLPP
#pragma keylist CopyConfigRequest requestId
#endif

struct ReserveConfigRequest {

    /** Unique request identifier, including the identity of the :MC making the request. */
    @key SampleId requestId; //@key

    /** Identity of the device that should service the request. */
    Fingerprint deviceId;

    /** If set, then enable buffer stealing. */
    boolean forceRelease;

    /** Configuration index to copy values from. */
    ConfigId source;
}; // struct ReserveConfigRequest
#ifdef OSPL_IDLPP
#pragma keylist ReserveConfigRequest requestId
#endif

struct ReserveConfigReply {

    /** Copy of the corresponding requestId. */
    @key SampleId relatedRequestId; //@key

    /** Indication of success (REPLY_OK) or failure (usually REPLY_SERVICE_UNAVAILABLE). */
    ReplyStatus status;

    /** If successful, index of the allocated temporary configuration, a number between CONFIG_TMP_MIN and CONFIG_TMP_MAX inclusive. Otherwise CONFIG_INVALID. */
    ConfigId tmp;

    /** If tmp was released, then this is the losing :MC's identity. Otherwise all 0s. */
    Fingerprint releaseId;
}; // struct ReserveConfigReply
#ifdef OSPL_IDLPP
#pragma keylist ReserveConfigReply relatedRequestId
#endif

struct ReleaseConfigRequest {

    /** Unique request identifier, including the identity of the :MC making the request. */
    @key SampleId requestId; //@key

    /** Identity of the device that should service the request. */
    Fingerprint deviceId;

    /** Configuration index to be released. */
    ConfigId tmp;
}; // struct ReleaseConfigRequest
#ifdef OSPL_IDLPP
#pragma keylist ReleaseConfigRequest requestId
#endif

struct ConfigReservation {

    /** Configuration that has been reserved. */
    ConfigId config;

    /** Device that this configuration is reserved for. */
    Fingerprint deviceId;
}; // struct ConfigReservation

const unsigned long MINLEN_configs = 0;
const unsigned long MAXLEN_configs = 1000;
struct ConfigReservationList {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** A list of all reserved configurations. */
    sequence<ConfigReservation,MAXLEN_configs> configs;
}; // struct ConfigReservationList
#ifdef OSPL_IDLPP
#pragma keylist ConfigReservationList deviceId
#endif

struct GetConfigContentsRequest {

    /** Unique request identifier, including the identity of the :MC making the request. */
    @key SampleId requestId; //@key

    /** Identity of the device that should service the request. */
    Fingerprint deviceId;

    /** Configuration index to be sent. */
    ConfigId config;
}; // struct GetConfigContentsRequest
#ifdef OSPL_IDLPP
#pragma keylist GetConfigContentsRequest requestId
#endif

typedef unsigned long PowerPortNumber;

/** Maximum number of power ports that a device may contain. */
const unsigned long MAX_PORTS = 20;

/** Number to use for a single-port device with no listed number. */
const unsigned long ONLY_PORT = 0;

const unsigned long MINLEN_ports = 0;
const unsigned long MAXLEN_ports = MAX_PORTS;
struct AuthorizationToEnergizeRequest {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Copy of the requestId from the command that requires authorization. */
    SampleId commandId;

    /** Copy of the deviceId from the command that requires authorization. */
    Fingerprint deviceId;

    /** All ports that would be energized by executing this command. */
    sequence<PowerPortNumber,MAXLEN_ports> ports;
}; // struct AuthorizationToEnergizeRequest
#ifdef OSPL_IDLPP
#pragma keylist AuthorizationToEnergizeRequest requestId
#endif

struct AuthorizationToEnergizeResponse {

    /** Copy of the corresponding AuthorizationToEnergizeRequest.requestId. */
    @key SampleId relatedRequestId; //@key

    /** Copy of the requestId from the command that requires authorization. */
    SampleId commandId;

    /** Copy of the deviceId from the command that requires authorization. */
    Fingerprint deviceId;

    /** Copy of the AuthorizationToEnergizeRequest.ports. */
    sequence<PowerPortNumber,MAXLEN_ports> ports;

    /** True if the command is authorized to proceed. */
    boolean accept;

    /** True if the command must not be executed. */
    boolean deny;

    /** Identity of the user that provided this response. */
    Fingerprint userId;

    /** Time when the user provided this response. */
    ClockRealtime authorizationTime;
}; // struct AuthorizationToEnergizeResponse
#ifdef OSPL_IDLPP
#pragma keylist AuthorizationToEnergizeResponse relatedRequestId
#endif

struct AuthorizationToEnergizeOutcome {

    /** Copy of the corresponding AuthorizationToEnergizeRequest.requestId. */
    @key SampleId relatedRequestId; //@key

    /** Copy of the requestId from the corresponding command. */
    SampleId commandId;

    /** Device that processed this authorization. Must match the corresponding command and request. */
    Fingerprint deviceId;

    /** True if the authorization was accepted, the command will be executed, and both relatedRequestId and commandId are valid. */
    boolean accepted;

    /**  True confirms that an authorization request was received. False indicates a response due to authorization timeout, and therefore relatedRequestId is invalid.  */
    boolean authReceived;

    /**  True confirms that commandId matched a pending command. False indicates the command was invalid, never received, timed out, or otherwise not pending execution.  */
    boolean authCommand;

    /** True confirms that the authorization deviceId, portNumber, and continuity matched the command. */
    boolean authLocation;

    /** True confirms that the userId was accepted. */
    boolean authUser;

    /** True confirms that the authorizationTime was accepted. */
    boolean authTime;

    /** Local monotonic clock when the acceptance decision was made. */
    ClockMonotonic authMonotonic;

    /** Local realtime clock when the acceptance decision was made. */
    ClockRealtime authRealtime;
}; // struct AuthorizationToEnergizeOutcome
#ifdef OSPL_IDLPP
#pragma keylist AuthorizationToEnergizeOutcome relatedRequestId
#endif

struct PowerPortId {

    /** Device containing the port */
    Fingerprint deviceId;

    /** Number shown on the device exterior to represent this port */
    PowerPortNumber portNumber;
}; // struct PowerPortId

struct PowerConnectionId {

    /** One end of the connection */
    PowerPortId portA;

    /** The other end of the connection */
    PowerPortId portB;
}; // struct PowerConnectionId

enum CableSenseType {
    CST_NONE, // Cable sense is not available.
    CST_CONNECTOR, // A continuity circuit is built in to the connectors.
    CST_MEASUREMENT, // Voltage and current monitoring can establish the presence of a cable.
    CST_CONNECTOR_MEASUREMENT // Both connector and measurement support are available.
}; // enum CableSenseType

enum CableSenseStatus {
    CS_UNKNOWN, // Cable presence is neither confirmed nor denied through active detection. Cable sense is not available, either due to device design or failure.
    CS_DISCONNECTED, // Sensing indicates that no cable is not connected. CST_MEASUREMENT devices must use CS_UNKNOWN instead of this value.
    CS_CONNECTED // Sensing indicates that a cable is connected.
}; // enum CableSenseStatus

enum PowerConnectorType {
    CONNECTOR_TERMINAL_BLOCK, //  
    CONNECTOR_MILSTD, // Generic MIL spec connector. MIL-STD-1651, MIL-DTL-22992, and MIL-DTL-53126, as used by PDISE.
    CONNECTOR_NEMA5, // For convenience ports, etc.
    CONNECTOR_CAMLOCK, // As used by MEPDIS-R.
    CONNECTOR_POWERLOCK, // ITT VEAM PowerLock
    CONNECTOR_IEC60309, // As used by MEPDIS-R.
    CONNECTOR_J1772, // Electric vehicle charging cable.
    CONNECTOR_POWERLOK, // Amphenol PowerLok
    CONNECTOR_MILSTD1651, // MIL-STD-1651
    CONNECTOR_MILDTL22992, // MIL-DTL-22992
    CONNECTOR_MILDTL53126, // MIL-DTL-53126
    CONNECTOR_OTHER // Other connector type, not listed elsewhere.
}; // enum PowerConnectorType

enum PowerConnectorPolarity {
    POLARITY_PIN, // This connector contains pins to insert in sockets.
    POLARITY_SOCKET, // This connector contains sockets to receive pins. Includes terminal blocks.
    POLARITY_UNIVERSAL // This connector is symmetric.
}; // enum PowerConnectorPolarity

enum PowerConnectorPhases {
    PHASE_SINGLE, // Single-phase circuit
    PHASE_SPLIT, // Split-phase circuit
    PHASE_3WYE, // 3-phase circuit, wye configuration
    PHASE_3DELTA, // 3-phase circuit, delta configuration
    PHASE_DC // DC circuit
}; // enum PowerConnectorPhases

enum PowerSwitchControl {
    PSC_NONE, // No switch
    PSC_MANUAL, // Manually operated switch
    PSC_AUTO, // Manually or automatically (internal protection) operated switch
    PSC_REMOTE // Manually, automatically, or remotely (external message) operated switch
}; // enum PowerSwitchControl

enum PowerSwitchProtection {
    PSP_NONE, // No breaker
    PSP_BREAKER, // Overload protection
    PSP_GFI, // Ground fault interruption
    PSP_BREAKER_GFI // Both overload and ground fault protection
}; // enum PowerSwitchProtection

struct PowerPortType {

    /** Number shown on the device exterior to represent this port */
    PowerPortNumber portNumber;

    /** Type of connector built in to the port */
    PowerConnectorType standard;

    /** Polarity of the connector built in to the port. */
    PowerConnectorPolarity polarity;

    /** Rating for peak continuous current */
    float ratedAmperage; // [A]

    /** Rating for nominal service voltage */
    float nominalVoltage; // [V]

    /** Type of circuit supported by this connector */
    PowerConnectorPhases phases;

    /** Ability to detect whether this connector has been mated */
    CableSenseType cableSense;

    /** Ability to open or close the circuit at this connector */
    PowerSwitchControl switchControl;

    /** Ability to provide circuit protection */
    PowerSwitchProtection protection;

    /** Ability to detect synchronization before closing */
    boolean synchronizer;
}; // struct PowerPortType

enum CircuitContinuity {
    CC_UNKNOWN, // No information is available, either due to design or malfunction.
    CC_OPEN, // Electrical or mechanical sensors indicate that continuity has been broken.
    CC_CLOSED, // Electrical or mechanical sensors indicate that continuity has been established.
    CC_INCONSISTENT // Electrical or mechanical sensors indicate that continuity has been established on some phases and broken on other phases.
}; // enum CircuitContinuity

enum PowerSwitchReason {
    PSR_UNKNOWN, // No information is available, either due to design or malfunction.
    PSR_MANUAL, // Sensors indicate manual operation.
    PSR_COMMAND, // The switch transitioned due to a (remote) command.
    PSR_PROTECTION, // The switch transitioned due to local protection function.
    PSR_FAILURE, // The transition appears to be due to an internal failure, unrelated to another reason.
    PSR_LOAD_POLICY // The switch opened due to a load policy setting. See DeviceLoadPolicyStatus.
}; // enum PowerSwitchReason

struct PowerSwitchStatus {

    /** Indicate circuit continuity through the switch. May be measured from the switch position or from electrical continuity. Continuity is unknown for manual switches with no monitoring capability. Continuity may be inconsistent for multi-phase switches. */
    CircuitContinuity continuity;

    /** Indicate that the switch has failed to respond to attempted transitions and may be stuck in its current state. Not set if a lock or other protection prevents a transition. */
    boolean transitionFault;

    /** Indicate that a protective lock is preventing transitions from the current state. */
    boolean transitionLock;

    /** Type of event that caused the circuit to enter its present state */
    PowerSwitchReason lastTransition;

    /** Device or user that caused the transition to occur. */
    Fingerprint lastTransitionActor;
}; // struct PowerSwitchStatus

enum DesiredCircuitContinuity {
    DCC_OPEN, // Transition to CC_OPEN.
    DCC_CLOSED, // Transition to CC_CLOSED. Predicated on AuthorizationToEnergizeRequest.
    DCC_SYNC_CLOSED, // Transition to CC_CLOSED when synchronization is achieved. May close to a dead circuit, predicated on AuthorizationToEnergizeRequest. May act as DCC_CLOSED_INTERNAL when the internal circuit is dead.
    DCC_CLOSED_INTERNAL, // Transition to CC_CLOSED. One side of the switch must be a circuit enclosed inside a device with protective guards.
    DCC_NO_CHANGE // No transition. May be used instead of DCC_CLOSED in non-active settings groups.
}; // enum DesiredCircuitContinuity

struct PowerSwitchCommand {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Device that should execute this command */
    Fingerprint deviceId;

    /** Configuration that this command belongs to. */
    ConfigId config;

    /** Port containing the switch that should change state. This is a key field for storing multiple commands in a configuration. */
    PowerPortNumber portNumber;

    /** Desired continuity through the switch */
    DesiredCircuitContinuity continuity;

    /** Minimum synchronization RMS voltage */
    float minV; // [V]

    /** Maximum synchronization RMS voltage */
    float maxV; // [V]

    /** Minimum synchronization frequency */
    float minF; // [Hz]

    /** Maximum synchronization frequency */
    float maxF; // [Hz]

    /** Maximum phase misalignment (absolute value) */
    float maxPhase; // [rad]
}; // struct PowerSwitchCommand
#ifdef OSPL_IDLPP
#pragma keylist PowerSwitchCommand requestId
#endif

const unsigned long MINLEN_cableId = 0;
const unsigned long MAXLEN_cableId = 1;
const unsigned long MINLEN_connection = 0;
const unsigned long MAXLEN_connection = 1;
const unsigned long MINLEN_switchStatus = 0;
const unsigned long MAXLEN_switchStatus = 1;
struct PowerPortStatus {

    /** Number shown on the device exterior to represent this port */
    PowerPortNumber portNumber;

    /** Indicates whether a power cable is plugged in. */
    CableSenseStatus cableStatus;

    /** Indicates that a smart cable is attached. This value is set when a smart cable is connected and cleared when it is disconnected. */
    sequence<Fingerprint,MAXLEN_cableId> cableId;

    /** Indicates that this port is connected to a remote port. */
    sequence<PowerPortId,MAXLEN_connection> connection;

    /** Indicates the state of a switch associated with this port. Must be empty when PowerPortType.switch is NONE; otherwise it must be full. */
    sequence<PowerSwitchStatus,MAXLEN_switchStatus> switchStatus;
}; // struct PowerPortStatus

enum PowerConnectionDetectionType {
    PCDT_OPERATOR, // Operator entry
    PCDT_CABLE_ID, // Identification embedded in a smart cable
    PCDT_PROBE, // Active probe signal sent down the line
    PCDT_CORRELATION, // Correlation of power measurements was used
    PCDT_HISTORY // Device reset or other event has lost continuous monitoring of the connection. This connection was detected before the event and has neither been confirmed nor denied since.
}; // enum PowerConnectionDetectionType

struct PowerConnection {

    /** Connection described by this object */
    PowerConnectionId connectionId;

    /** Technique used to detect this connection */
    PowerConnectionDetectionType detectionType;

    /** Device or user that detected this connection */
    Fingerprint detectionSource;

    /** Confidence in the link detection. -100=confident the link does not exist, 0=no opinion, 100=confident the link exists */
    float detectionConfidence;
}; // struct PowerConnection

const unsigned long MINLEN_ports_one = 1;
struct DevicePowerPortTypes {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Information on each power port. */
    sequence<PowerPortType,MAXLEN_ports> ports;
}; // struct DevicePowerPortTypes
#ifdef OSPL_IDLPP
#pragma keylist DevicePowerPortTypes deviceId
#endif

struct DevicePowerPortStatuses {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Information on each power port. */
    sequence<PowerPortStatus,MAXLEN_ports> ports;
}; // struct DevicePowerPortStatuses
#ifdef OSPL_IDLPP
#pragma keylist DevicePowerPortStatuses deviceId
#endif

const unsigned long MINLEN_connections = 0;
const unsigned long MAXLEN_connections = 200;
struct PowerConnectionList {

    /** The reporting device or user */
    @key Fingerprint deviceId; //@key

    /** List of power connections being reported by this device or user */
    sequence<PowerConnection,MAXLEN_connections> connections;
}; // struct PowerConnectionList
#ifdef OSPL_IDLPP
#pragma keylist PowerConnectionList deviceId
#endif

typedef unsigned long GroundingCircuitNumber;

/** Maximum number of grounding circuits that a device may contain. */
const unsigned long MAX_GROUNDS = 20;

enum GroundingDesignType {
    GROUNDING_INVALID, // Invalid value.
    GROUNDING_UNGROUNDED, // No grounding.
    GROUNDING_SOLID, // Solidly grounded.
    GROUNDING_HIGH_RESISTANCE, // High-resistance grounded system. Generally designed for 1-10 A ground fault current.
    GROUNDING_LOW_RESISTANCE, // Low-resistance grounded system. Generally designed to limit equipment damage.
    GROUNDING_REACTANCE // Reactance grounded system. Generally limits ground fault current to rated line current.
}; // enum GroundingDesignType

const unsigned long MINLEN_protectedPorts = 1;
const unsigned long MAXLEN_protectedPorts = MAX_PORTS;
struct GroundingType {

    /** Number used to represent this circuit. */
    GroundingCircuitNumber groundNumber;

    /** Type of grounding provided by this circuit. */
    GroundingDesignType type;

    /** List of ports protected by this circuit. */
    sequence<PowerPortNumber,MAXLEN_protectedPorts> protectedPorts;

    /** Indicates whether this circuit is fixed or can be disconnected. */
    PowerSwitchControl controlType;

    /** Indicates whether this circuit can be pulsed for locating ground faults. */
    PowerSwitchControl pulseType;
}; // struct GroundingType

const unsigned long MINLEN_grounds = 0;
const unsigned long MAXLEN_grounds = MAX_GROUNDS;
struct DeviceGroundingType {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Information on each grounding circuit. */
    sequence<GroundingType,MAXLEN_grounds> grounds;
}; // struct DeviceGroundingType
#ifdef OSPL_IDLPP
#pragma keylist DeviceGroundingType deviceId
#endif

enum GroundFaultDetection {
    GFD_INVALID, // Invalid value.
    GFD_NONE, // No ground fault detected.
    GFD_ANY, // Ground fault detected. Multiple lines detected or specific line unknown.
    GFD_A, // Ground fault detected on phase A.
    GFD_B, // Ground fault detected on phase B.
    GFD_C, // Ground fault detected on phase C.
    GFD_DCPOS, // Ground fault detected on DC+.
    GFD_DCNEG // Ground fault detected on DC-.
}; // enum GroundFaultDetection

const unsigned long MINLEN_control = 0;
const unsigned long MAXLEN_control = 1;
const unsigned long MINLEN_pulse = 0;
const unsigned long MAXLEN_pulse = 1;
struct GroundingStatus {

    /** Number used to represent this circuit. */
    GroundingCircuitNumber groundNumber;

    /** Status of the grounding control switch. */
    sequence<PowerSwitchStatus,MAXLEN_control> control;

    /** Status of the grounding pulse switch. */
    sequence<PowerSwitchStatus,MAXLEN_pulse> pulse;

    /** Status of the ground fault detector. GFD_INVALID if no detector. */
    GroundFaultDetection faultDetection;
}; // struct GroundingStatus

struct DeviceGroundingStatus {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Information on each ground circuit. */
    sequence<GroundingStatus,MAXLEN_grounds> grounds;
}; // struct DeviceGroundingStatus
#ifdef OSPL_IDLPP
#pragma keylist DeviceGroundingStatus deviceId
#endif

struct GroundingCommand {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Device that should execute this command */
    Fingerprint deviceId;

    /** Configuration that this command belongs to. */
    ConfigId config;

    /** Grounding circuit containing the switch that should change state. */
    GroundingCircuitNumber groundNumber;

    /** Desired continuity through the grounding control switch. */
    DesiredCircuitContinuity control;

    /** Desired continuity through the grounding pulse switch. */
    DesiredCircuitContinuity pulse;
}; // struct GroundingCommand
#ifdef OSPL_IDLPP
#pragma keylist GroundingCommand requestId
#endif

struct PowerMeasurementLine {

    /** RMS voltage between this phase and the neutral line. For the neutral line, this measurement is taken to the protective chassis ground. */
    float v; // [V]

    /** RMS current through this line. */
    float i; // [A]

    /** Power factor angle (phase offset) between the voltage and current. The sign convention for this measurement is illustrated in Figure fig:pf-angle. Valid range is +/-180^\circ . */
    float phi; // [degrees]

    /** Active RMS power through this line. */
    float p; // [W]

    /** Reactive RMS power through this line. */
    float q; // [var]

    /** Dominant line frequency over the past 200ms. */
    float f; // [Hz]

    /** Total harmonic distortion in the voltage over the past 200ms, measured according to IEEE 519 / IEC 61000-3-2. Reported as a percentage of the fundamental component. */
    float vThd; // [percent]

    /** Total harmonic distortion in the current over the past 200ms, measured according to IEEE 519 / IEC 61000-3-2. Reported as a percentage of the fundamental component. */
    float iThd; // [percent]
}; // struct PowerMeasurementLine

struct PowerMeasurementWye {

    /** Measured values for phase A to neutral. */
    PowerMeasurementLine A;

    /** Measured values for phase B to neutral. */
    PowerMeasurementLine B;

    /** Measured values for phase C to neutral. */
    PowerMeasurementLine C;

    /** Measured values for neutral to ground. */
    PowerMeasurementLine N;

    /** Measured phase difference between the voltages from phase A to phase B. The sign convention is illustrated in Figure fig:phase-angle. */
    float phaseAtoB; // [degrees]

    /** Measured phase difference between the voltages from phase A to phase C. The sign convention is illustrated in Figure fig:phase-angle. */
    float phaseAtoC; // [degrees]
}; // struct PowerMeasurementWye

struct PowerPortMeasurement {

    /** Port being measured */
    PowerPortNumber portNumber;

    /** Power measurement for this port */
    PowerMeasurementWye measurement;
}; // struct PowerPortMeasurement

struct DevicePowerMeasurements {

    /** The device described by this structure */
    @key Fingerprint deviceId; //@key

    /** Time of these measurements */
    ClockMonotonic timeMeasured;

    /** Measurements for all ports on this device */
    sequence<PowerPortMeasurement,MAXLEN_ports> ports;
}; // struct DevicePowerMeasurements
#ifdef OSPL_IDLPP
#pragma keylist DevicePowerMeasurements deviceId
#endif

const unsigned long MINLEN_NicknameString = 0;
const unsigned long MAXLEN_NicknameString = 32;
typedef string<MAXLEN_NicknameString> NicknameString;

struct FingerprintNickname {

    /** The Fingerprint described by this structure. */
    @key Fingerprint id; //@key

    /** Nickname given to this Fingerprint. */
    NicknameString nickname;
}; // struct FingerprintNickname
#ifdef OSPL_IDLPP
#pragma keylist FingerprintNickname id
#endif

struct ChangeNicknameRequest {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Fingerprint that should store a new nickname. */
    Fingerprint id;

    /** New nickname to be used for this Fingerprint. */
    NicknameString nickname;
}; // struct ChangeNicknameRequest
#ifdef OSPL_IDLPP
#pragma keylist ChangeNicknameRequest requestId
#endif

const unsigned long MINLEN_mimeType = 1;
const unsigned long MAXLEN_mimeType = 32;
const unsigned long MINLEN_data = 1;
const unsigned long MAXLEN_data = 32*1024;
struct DeviceIcon {

    /** Supply type of this device. */
    NatoStockNumber nsn;

    /** Product type of this device. */
    GlobalTradeItemNumber gtin;

    /**  Type of the image format. See the <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">IANA Media Type list</a>. Example: ``image/png''  */
    string<MAXLEN_mimeType> mimeType;

    /** Contents of the image. */
    sequence<octet,MAXLEN_data> data;
}; // struct DeviceIcon

enum OperatingMode {
    OPM_NORMAL, // Normal operating mode.
    OPM_EMERGENCY // Emergency operating mode.
}; // enum OperatingMode

typedef long PriorityValue;

/** Force a device off or a power port to be open */
const long INTENT_PRIORITY_NEVER_OPERATE = -1;

/** Force a device on/Sourcing or a power port to be closed */
const long INTENT_PRIORITY_ALWAYS_OPERATE = 0;

/** The highest relative priority for a device or power port */
const long INTENT_PRIORITY_HIGHEST = 1;

/** The lowest relative priority for a device or power port */
const long INTENT_PRIORITY_LOWEST = 1000;

const unsigned long MINLEN_Guid = 0;
const unsigned long MAXLEN_Guid = 32;
typedef string<MAXLEN_Guid> Guid;

struct Duration {

    /** Time in seconds. */
    unsigned long long second;

    /** Time in nanoseconds. */
    unsigned long long nanosecond;
}; // struct Duration

struct MicrogridIntent {

    /** Overall operating mode for the microgrid. */
    OperatingMode operatingMode;

    /** Percent of used capacity that triggers the MC to add additional power source to the microgrid. Percent in the range 0 - 100 */
    unsigned long increaseCapacityThreshold;

    /** Percent of used capacity that triggers the MC to remove a power source from the microgrid. Percent in the range 0 - 100 and must be less than increaseCapacityThreshold */
    unsigned long decreaseCapacityThreshold;

    /** The time duration the decreaseCapacityThreshold must be met before the MC removes a power source from the microgrid. This duration prevents power sources from being added and removed in rapid succession. */
    Duration decreaseCapacityDuration;

    /** The device priority above which the MC is authorized to trigger load curtailment. A value of INTENT_PRIORITY_LOWEST disables load curtailment. */
    PriorityValue priorityLoadCurtailmentAllowed;

    /** The power port priority above which the MC is authorized to trigger circuit curtailment. A value of INTENT_PRIORITY_LOWEST disables circuit load shedding. */
    PriorityValue priorityCircuitSheddingAllowed;
}; // struct MicrogridIntent

struct OverCurrentDisconnect {

    /** Maximum current threshold for the phase A line. Value must be \ge 0 or NaN. */
    float currentA; // [A]

    /** Maximum current threshold for the phase B line. Value must be \ge 0 or NaN. */
    float currentB; // [A]

    /** Maximum current threshold for the phase C line. Value must be \ge 0 or NaN. */
    float currentC; // [A]

    /** Maximum current threshold for the neutral line. Value must be \ge 0 or NaN. */
    float currentN; // [A]

    /** Time to wait before disconnect */
    Duration delay;
}; // struct OverCurrentDisconnect

struct OverEnergyDisconnect {

    /**  Amount of energy that is presently available for use. The energy balance is calculated by the :MC at the time of transmission and replaces local balance estimates. Due to external considerations, it may not reflect actual usage and the refillRate.  */
    float balance; // [J]

    /**  Amount of energy that can be saved for future use.  */
    float maxBalance; // [J]

    /**  The maximum power allotted to this device on a continuous basis. A value of 0 means the device may only consume the present balance. A value of +\infty  means that this device is unconstrained. May be credited continuously, hourly, daily, or at some other interval specified by acquisition requirements.  */
    float refillRate; // [W]
}; // struct OverEnergyDisconnect

struct UnderFrequencyDisconnect {

    /** Minimum frequency threshold. */
    float frequency; // [Hz]

    /** Time to wait before disconnect. */
    Duration delay;

    /** Target amount of load to shed. */
    float objective; // [W]
}; // struct UnderFrequencyDisconnect

enum LocalPowerPortPriority {
    LPPP_UNINITIALIZED, // Uninitialized value.
    LPPP_NONE, // Ports in this group should not be considered for automatic disconnect.
    LPPP_OFF, // Ports in this group should always be off (open). They should be opened before automatic disconnect thresholds are considered.
    LPPP_LOW, // First group to be considered for automatic disconnect.
    LPPP_MEDIUM, // Second group to be considered for automatic disconnect.
    LPPP_HIGH, // Last group to be considered for automatic disconnect.
    LPPP_ON // Ports in this group should always be on (closed). They should not be considered for automatic disconnect.
}; // enum LocalPowerPortPriority

struct LocalPowerPortPriorityAssignment {

    /** Number shown on the device exterior to represent this port. */
    PowerPortNumber portNumber;

    /** Local priority assigned to this port. */
    LocalPowerPortPriority priority;
}; // struct LocalPowerPortPriorityAssignment

struct PowerPortLoadPolicy {

    /** Number shown on the device exterior to represent this port */
    PowerPortNumber portNumber;

    /** Short-term over-current policy */
    OverCurrentDisconnect inrushCurrent;

    /** Long-term over-current policy */
    OverCurrentDisconnect steadyCurrent;

    /** Short-term under-frequency policy */
    UnderFrequencyDisconnect inrushFrequency;

    /** Long-term under-frequency policy */
    UnderFrequencyDisconnect steadyFrequency;

    /** Energy allocation policy */
    OverEnergyDisconnect energy;
}; // struct PowerPortLoadPolicy

struct BusbarLoadPolicy {

    /** Short-term over-current policy */
    OverCurrentDisconnect inrushCurrent;

    /** Highest port priority eligible for automatic disconnect */
    LocalPowerPortPriority inrushCurrentPriority;

    /** Long-term over-current policy */
    OverCurrentDisconnect steadyCurrent;

    /** Highest port priority eligible for automatic disconnect */
    LocalPowerPortPriority steadyCurrentPriority;

    /** Short-term under-frequency policy */
    UnderFrequencyDisconnect inrushFrequency;

    /** Highest port priority eligible for automatic disconnect */
    LocalPowerPortPriority inrushFrequencyPriority;

    /** Long-term under-frequency policy */
    UnderFrequencyDisconnect steadyFrequency;

    /** Highest port priority eligible for automatic disconnect */
    LocalPowerPortPriority steadyFrequencyPriority;

    /** Energy allocation policy */
    OverEnergyDisconnect energy;

    /** Highest port priority eligible for automatic disconnect */
    LocalPowerPortPriority energyPriority;
}; // struct BusbarLoadPolicy

const unsigned long MINLEN_busbarPolicy = 0;
const unsigned long MAXLEN_busbarPolicy = 1;
struct DeviceIntent {

    /** The device described by this structure. */
    Fingerprint deviceId;

    /** The device Battle Short state. */
    boolean battleShort;

    /** The relative priority of the device described by the stucture to other devices in the OperatorIntent. */
    PriorityValue priority;

    /** Load policy that applies to the internal busbar. */
    sequence<BusbarLoadPolicy,MAXLEN_busbarPolicy> busbarPolicy;

    /** Prevent too much load from being disconnected at once. */
    float rateLimit; // [W/s]
}; // struct DeviceIntent

const unsigned long MINLEN_portPolicy = 0;
const unsigned long MAXLEN_portPolicy = 1;
struct PowerPortIntent {

    /** The device described by this structure. */
    Fingerprint deviceId;

    /** Number shown on the device exterior to represent this port */
    PowerPortNumber portNumber;

    /** The relative priority of the device power port described by the stucture to other device power ports in the OperatorIntent. */
    PriorityValue priority;

    /** Load policy that applies to individiual load port. */
    sequence<PowerPortLoadPolicy,MAXLEN_portPolicy> portPolicy;

    /** Local priority for use by the busbarPolicy. */
    LocalPowerPortPriority localPriority;
}; // struct PowerPortIntent

enum OperatorIntentType {
    OIT_DEFAULT_INTENT, // The MC defined default operator intent.
    OIT_OPERATOR_DEFINED // An MSM activated operator defined intent.
}; // enum OperatorIntentType

const unsigned long MINLEN_devices = 0;
const unsigned long MAXLEN_devices = 100;
const unsigned long MINLEN_powerPorts = 0;
const unsigned long MAXLEN_powerPorts = 4000;
struct OperatorIntent {

    /** The device that defined this structure. */
    Fingerprint originator;

    /** The intent type. */
    OperatorIntentType intentType;

    /** The microgrid level directives. */
    MicrogridIntent microgrid;

    /** The device level directives. */
    sequence<DeviceIntent,MAXLEN_devices> devices;

    /** The power port level directives. */
    sequence<PowerPortIntent,MAXLEN_powerPorts> powerPorts;
}; // struct OperatorIntent

struct OperatorIntentRequest {

    /** The device sending this request. */
    @key SampleId requestId; //@key

    /** The OperatorIntent to activite. */
    OperatorIntent desiredOperatorIntent;
}; // struct OperatorIntentRequest
#ifdef OSPL_IDLPP
#pragma keylist OperatorIntentRequest requestId
#endif

struct OperatorIntentState {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** The complete active OperatorIntent. */
    OperatorIntent activeOperatorIntent;
}; // struct OperatorIntentState
#ifdef OSPL_IDLPP
#pragma keylist OperatorIntentState deviceId
#endif

const unsigned long MINLEN_portPriorities = 0;
const unsigned long MAXLEN_portPriorities = MAX_PORTS;
const unsigned long MINLEN_portPolicies = 0;
const unsigned long MAXLEN_portPolicies = MAX_PORTS;
struct LoadPolicyRequest {

    /** Identity of this request. */
    @key SampleId requestId; //@key

    /** Device that should execute this command */
    Fingerprint deviceId;

    /** Configuration that this command belongs to. */
    ConfigId config;

    /** A full list of the local ports and their associated priorities. */
    sequence<LocalPowerPortPriorityAssignment,MAXLEN_portPriorities> portPriorities;

    /** Load policies that apply to individiual load ports. Only ports with local policies are specified. */
    sequence<PowerPortLoadPolicy,MAXLEN_portPolicies> portPolicies;

    /** Load policy that applies to the internal busbar. */
    sequence<BusbarLoadPolicy,MAXLEN_busbarPolicy> busbarPolicy;

    /** Prevent too much load from being disconnected at once. */
    float rateLimit; // [W/s]
}; // struct LoadPolicyRequest
#ifdef OSPL_IDLPP
#pragma keylist LoadPolicyRequest requestId
#endif

enum LoadPolicy {
    LP_UNINITIALIZED, // Uninitialized value.
    LP_NONE, // No applicable load policy. May indicate no load policy triggered or switch reclosed.
    LP_OVER_CURRENT, // Over current load policy.
    LP_OVER_ENERGY, // Over energy load policy.
    LP_UNDER_FREQUENCY // Under frequency load policy.
}; // enum LoadPolicy

enum PowerLine {
    LINE_UNINITIALIZED, // Uninitialized value.
    LINE_NONE, // No applicable line.
    LINE_A, // First phase line.
    LINE_B, // Second phase line.
    LINE_C, // Third phase line.
    LINE_N, // Neutral line.
    LINE_G, // Ground line.
    LINE_MULTIPLE // Multiple lines.
}; // enum PowerLine

enum LoadPolicyContinuity {
    LPC_UNINITIALIZED, // Unintialized value.
    LPC_NONE, // No applicable load policy event.
    LPC_CONTINUOUS, // Threshold trigger was continuous.
    LPC_INTERRUPTED // Threshold trigger was interrupted briefly.
}; // enum LoadPolicyContinuity

struct PowerPortLoadPolicyReport {

    /** Number shown on the device exterior to represent this port. */
    PowerPortNumber portNumber;

    /** Type of load policy that triggered. */
    LoadPolicy type;

    /** For over-current, indicate which line triggered. For other policies, set to LINE_MULTIPLE. */
    PowerLine line;

    /** For over-current or under-frequency, indicate the event continuity. For over-energy, set to LPC_UNINITIALIZED. */
    LoadPolicyContinuity continuity;

    /** Time the policy opened the switch. */
    ClockMonotonic time;
}; // struct PowerPortLoadPolicyReport

struct DeviceLoadPolicyStatus {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Load policy status for each port on this device. */
    sequence<PowerPortLoadPolicyReport,MAXLEN_ports> ports;
}; // struct DeviceLoadPolicyStatus
#ifdef OSPL_IDLPP
#pragma keylist DeviceLoadPolicyStatus deviceId
#endif

struct DevicePriority {

    /** The device described by this structure. */
    Fingerprint deviceId;

    /** The priority assigned to this device. */
    PriorityValue priority;
}; // struct DevicePriority

struct NsnPriority {

    /** The device type to match. */
    NatoStockNumber nsn;

    /** The priority assigned to this device type. */
    PriorityValue priority;
}; // struct NsnPriority

struct GtinPriority {

    /** The device type to match. */
    GlobalTradeItemNumber gtin;

    /** The priority assigned to this device type. */
    PriorityValue priority;
}; // struct GtinPriority

const unsigned long MINLEN_byIdentity = 0;
const unsigned long MAXLEN_byIdentity = 100;
const unsigned long MINLEN_byNsn = 0;
const unsigned long MAXLEN_byNsn = 100;
const unsigned long MINLEN_byGtin = 0;
const unsigned long MAXLEN_byGtin = 100;
struct McPriorityList {

    /** Priorities for specific devices. */
    sequence<DevicePriority,MAXLEN_byIdentity> byIdentity;

    /** Priorities for matching NSNs. */
    sequence<NsnPriority,MAXLEN_byNsn> byNsn;

    /** Priorities for matching GTINs. */
    sequence<GtinPriority,MAXLEN_byGtin> byGtin;
}; // struct McPriorityList

struct McRedirect {

    /** The device delegating control. */
    Fingerprint sourceId;

    /** The device receiving control. */
    Fingerprint targetId;
}; // struct McRedirect

struct EngineState {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    float oilPressure; // [Pa]

    float coolantTemperature; // [C]

    float speed; // [rad/s]

    /** [PROVISIONAL] */
    float fuelLevel; // [0-100\%]
}; // struct EngineState
#ifdef OSPL_IDLPP
#pragma keylist EngineState deviceId
#endif

enum SourceState {
    SS_UNINITIALIZED, // Uninitialized value.
    SS_OFF, // <em>Off</em> state.
    SS_ON, // <em>On</em> state.
    SS_RUNNING, // <em>Running</em> state.
    SS_SOURCING // <em>Sourcing</em> state.
}; // enum SourceState

enum SourceTransition {
    ST_UNINITIALIZED, // Uninitialized value.
    ST_NONE, // No transition (stay in present state).
    ST_POWER_UP, // Transition from OFF to ON.
    ST_POWER_DOWN, // Transition from ON to OFF.
    ST_START, // Transition from ON to RUNNING.
    ST_STOP, // Transition from RUNNING to ON.
    ST_CONNECT, // Transition from RUNNING to SOURCING.
    ST_DISCONNECT, // Transition from SOURCING to RUNNING.
    ST_JUMP_START, // Transition from ON to SOURCING.
    ST_RAPID_STOP // Transition from SOURCING to ON.
}; // enum SourceTransition

struct SourceTransitionState {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Present location in the state transition model. */
    SourceState presentState;

    /** State that the device is transitioning to, or presentState if no transition. */
    SourceState futureState;

    /** How long the device has been in the present state or transition.  */
    float elapsedTime; // [s]

    /** Estimates when the present transition will complete. It is zero (0.0) when the device is not in transition.  */
    float remainingTime; // [s]

    /** Copy of the most recent SourceTransitionRequest.requestId. */
    SampleId relatedRequestId;
}; // struct SourceTransitionState
#ifdef OSPL_IDLPP
#pragma keylist SourceTransitionState deviceId
#endif

struct SourceTransitionRequest {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Device that should execute this command */
    Fingerprint deviceId;

    /** Configuration that this command belongs to. */
    ConfigId config;

    /** Transition the device should complete. */
    SourceTransition desiredTransition;
}; // struct SourceTransitionRequest
#ifdef OSPL_IDLPP
#pragma keylist SourceTransitionRequest requestId
#endif

struct ControlCurve {

    /** Minimum acceptable value of y. Devices should operate above this curve. */
    Curve2D minimum;

    /** Nominal value of y. Used as the setpoint for PID controls. */
    Curve2D nominal;

    /** Maximum acceptable value of y. Devices should operate below this curve. */
    Curve2D maximum;
}; // struct ControlCurve

struct DLSConfig {

    /** List of topics for receiving DLSMeasurement data. If empty, then do not receive any data. */
    TopicList sendTopics;

    /** List of topics for sending DLSMeasurement data. If empty, then do not send any data. */
    TopicList receiveTopics;

    /** Gain on the real-power sharing signal. Setting this to 0 makes f_{LS}\equiv 0. */
    float gainReal; // [0-1]

    /** Gain on the reactive power sharing signal. Setting this to 0 makes v_{LS}\equiv 0. */
    float gainReactive; // [0-1]

    /** Bias to the real power sharing. If empty, the bias is 0. */
    Curve2D biasRealPu; // [p.u. W, p.u. W]

    /** Bias to the reactive power sharing. If empty, the bias is 0. */
    Curve2D biasReactivePu; // [p.u. var, p.u. var]
}; // struct DLSConfig

struct DLSMeasurement {

    /** The device reporting these values. */
    @key Fingerprint deviceId; //@key

    /** Local measurement time. May be used to detect jitter or data loss. */
    ClockMonotonic time;

    /** Percent unit real load power. */
    float realPu; // [p.u. W]

    /** Percent unit reactive load power. */
    float reactivePu; // [p.u. var]
}; // struct DLSMeasurement
#ifdef OSPL_IDLPP
#pragma keylist DLSMeasurement deviceId
#endif

struct LoadSharing {

    /** Real power to frequency relationship curve, f_P. */
    ControlCurve frequencyPowerCurve; // [W, Hz]

    /** Reactive power to voltage relationship curve, v_Q. */
    ControlCurve voltageReactiveCurve; // [var, V]

    /** Digital load sharing configuration. */
    DLSConfig dls;
}; // struct LoadSharing

struct LoadSharingRequest {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Device that should execute this command */
    Fingerprint deviceId;

    /** Configuration that this command belongs to. */
    ConfigId config;

    /** New value to use. */
    LoadSharing parameters;
}; // struct LoadSharingRequest
#ifdef OSPL_IDLPP
#pragma keylist LoadSharingRequest requestId
#endif

struct LoadSharingStatus {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Configuration that these values belong to. */
    ConfigId config;

    /** Parameter values. */
    LoadSharing parameters;
}; // struct LoadSharingStatus
#ifdef OSPL_IDLPP
#pragma keylist LoadSharingStatus deviceId
#endif

struct LoadEstimate {

    /** The device described by this structure. */
    Fingerprint deviceId;

    /** Center frequency used in this estimate, f_0. Usually the nominal line frequency. */
    float centerFrequency; // [Hz]

    /** Real power, P_P. */
    float realPower; // [W]

    /** Real current, P_I. */
    float realCurrent; // [A]

    /** Real impedance, P_Z, represented as conductance. */
    float realImpedance; // [S]

    /** Real power sensitivity to frequency changes, P_f. */
    float realFrequency; // [s]

    /** Reactive power, Q_Q. */
    float reactivePower; // [var]

    /** Reactive current, Q_I. */
    float reactiveCurrent; // [A]

    /** Reactive impedance, Q_Z, represented as susceptance. */
    float reactiveImpedance; // [S]

    /** Reactive power sensitivity to frequency changes, Q_f. */
    float reactiveFrequency; // [s]
}; // struct LoadEstimate

struct LoadChange {

    /** Present minimum load. This value may be measured or estimated. */
    float initPowerMin; // [W]

    /** Present maximum load. This value may be measured or estimated. */
    float initPowerMax; // [W]

    /** Estimates the minimum transient load during this change. */
    float transPowerMin; // [W]

    /** Estimates the maximum transient load during this change. */
    float transPowerMax; // [W]

    /** Bounds the expected rate of change during this change. */
    float transSlope; // [W/s]

    /** Estimates the greatest amount of time from transient start (when the load exits the initial bounds) to transient end (when the load settles within the final bounds). */
    float transDuration; // [s]

    /** Estimates the minimum load after completing this change. */
    float finalPowerMin; // [W]

    /** Estimates the maximum load after completing this change. */
    float finalPowerMax; // [W]

    /** Predicted load after the transition completes. */
    LoadEstimate finalLoadEstimate;
}; // struct LoadChange

struct LoadChangeRequest {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Requested power consumption change. */
    LoadChange desiredTransition;
}; // struct LoadChangeRequest
#ifdef OSPL_IDLPP
#pragma keylist LoadChangeRequest requestId
#endif

struct SimulationCapabilities {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** Indicates whether scaled time is supported. */
    boolean scaledTime;

    /** Indicates the maximum supported time scale. */
    float scaledTimeMax;

    /** Indicates whether stepped time is supported. */
    boolean steppedTime;

    /** Indicates the minimum real time required for a simulation step. (For example, such constraints may be introduced by internal event loops.) */
    ClockMonotonic realStepDurationMin;
}; // struct SimulationCapabilities
#ifdef OSPL_IDLPP
#pragma keylist SimulationCapabilities deviceId
#endif

enum TimeMode {
    TM_REAL_TIME, // Unmodified wall-clock time.
    TM_SCALED_TIME, // Wall-clock time that is sped up or slowed down.
    TM_STEPPED_TIME // Small time steps, coordinated by the time controller.
}; // enum TimeMode

struct TimeScheme {

    /** Indicates which operating mode is in use. */
    TimeMode mode;

    /** The simulation speed multiplier (virtual time to real time). */
    float scale; // [s/s]

    /** Origin of the simulation in real time. */
    ClockRealtime realBase;

    /** Origin of the simulated time. */
    ClockMonotonic virtualBase;

    /** How long the time controller will wait for this step to complete. After this time, it may abort the simulation or proceed without waiting for TimeAdvance messages. */
    ClockMonotonic realStepDuration;

    /** How long of a step to take. */
    ClockMonotonic virtualStepDuration;

    /** The current step to process. */
    long stepCount;
}; // struct TimeScheme

struct TimeAdvance {

    /** The device described by this structure. */
    @key Fingerprint deviceId; //@key

    /** What time this device finished processing. */
    ClockMonotonic virtualTime;

    /** A copy of the most recent TimeScheme value. (For the time controller to track synchronization.) */
    long stepCount;
}; // struct TimeAdvance
#ifdef OSPL_IDLPP
#pragma keylist TimeAdvance deviceId
#endif

enum MicrogridMembership {
    MM_UNINITIALIZED, // Uninitialized value.
    MM_JOIN, // Join or stay in the microgrid.
    MM_LEAVE // Leave or stay out of the microgrid.
}; // enum MicrogridMembership

struct MicrogridMembershipRequest {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** The device requesting a membership change. May be a platformId, indicating that all deviceIds on the platform are affected. */
    Fingerprint deviceId;

    /** The desired membership state. */
    MicrogridMembership membership;
}; // struct MicrogridMembershipRequest
#ifdef OSPL_IDLPP
#pragma keylist MicrogridMembershipRequest requestId
#endif

enum MicrogridMembershipResult {
    MMR_UNINITIALIZED, // Uninitialized value.
    MMR_REPLACED, // New request received before preparation for this request was complete. Device should discard this request and wait for the new request to complete.
    MMR_COMPLETE, // Completed preparation for the requested action. No significant issues were encountered.
    MMR_BLOCKED // Preparation could not be completed without a significant negative impact such as shedding load. Operator should resolve the issue before proceeding.
}; // enum MicrogridMembershipResult

struct MicrogridMembershipApproval {

    /** Identity of this request */
    @key SampleId requestId; //@key

    /** Copy of the corresponding MicrogridMembershipRequest.requestId. */
    SampleId relatedRequestId;

    /** Device (or platform) that has been approved. */
    Fingerprint deviceId;

    /** Requested state. */
    MicrogridMembership membership;

    /** Indicate whether the microgrid is ready to complete this request. */
    MicrogridMembershipResult result;

    /** Short, human-readable text description of a blocked request. This should summarize to the operator what the issue is (e.g. ``blocked by interruptible load'', ``blocked by critical load'', or ``manual action required''). */
    string<MAXLEN_hint> hint;
}; // struct MicrogridMembershipApproval
#ifdef OSPL_IDLPP
#pragma keylist MicrogridMembershipApproval requestId
#endif

}; // module tms
